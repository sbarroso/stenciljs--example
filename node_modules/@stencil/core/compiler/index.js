'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ts = require('typescript');

/**
 * SSR Attribute Names
 */
const SSR_VNODE_ID = 'data-ssrv';
const SSR_CHILD_ID = 'data-ssrc';
/**
 * Default style mode id
 */
const DEFAULT_STYLE_MODE = '$';
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
/**
 * Key Name to Key Code Map
 */
const KEY_CODE_MAP = {
    'enter': 13,
    'escape': 27,
    'space': 32,
    'tab': 9,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40
};
/**
 * Namespaces
 */



/**
 * File names and value
 */
const BANNER = `Built with http://stenciljs.com`;
const COLLECTION_MANIFEST_FILE_NAME = 'collection-manifest.json';

const GLOBAL_NAME = 'global';
const LOADER_NAME = 'loader';
const APP_NAMESPACE_REGEX = /["']__APP__['"]/g;

function getBuildContext(ctx) {
    // create the build context if it doesn't exist
    ctx = ctx || {};
    ctx.diagnostics = ctx.diagnostics || [];
    ctx.manifest = ctx.manifest || {};
    ctx.registry = ctx.registry || {};
    ctx.filesToWrite = ctx.filesToWrite || {};
    ctx.appFiles = ctx.appFiles || {};
    ctx.moduleFiles = ctx.moduleFiles || {};
    ctx.jsFiles = ctx.jsFiles || {};
    ctx.cssFiles = ctx.cssFiles || {};
    ctx.dependentManifests = ctx.dependentManifests || {};
    ctx.compiledFileCache = ctx.compiledFileCache || {};
    ctx.moduleBundleOutputs = ctx.moduleBundleOutputs || {};
    ctx.styleSassUnscopedOutputs = ctx.styleSassUnscopedOutputs || {};
    ctx.styleSassScopedOutputs = ctx.styleSassScopedOutputs || {};
    ctx.styleCssUnscopedOutputs = ctx.styleCssUnscopedOutputs || {};
    ctx.styleCssScopedOutputs = ctx.styleCssScopedOutputs || {};
    ctx.changedFiles = ctx.changedFiles || [];
    return ctx;
}
function resetBuildContext(ctx) {
    ctx.registry = {};
    ctx.manifest = {};
    ctx.diagnostics = [];
    ctx.sassBuildCount = 0;
    ctx.transpileBuildCount = 0;
    ctx.indexBuildCount = 0;
    ctx.moduleBundleCount = 0;
    ctx.styleBundleCount = 0;
    ctx.prerenderedUrls = 0;
    delete ctx.localPrerenderServer;
}
function getJsFile(sys, ctx, jsFilePath) {
    jsFilePath = normalizePath(jsFilePath);
    if (typeof ctx.filesToWrite[jsFilePath] === 'string') {
        return Promise.resolve(ctx.filesToWrite[jsFilePath]);
    }
    if (typeof ctx.jsFiles[jsFilePath] === 'string') {
        return Promise.resolve(ctx.jsFiles[jsFilePath]);
    }
    return new Promise((resolve, reject) => {
        sys.fs.readFile(jsFilePath, 'utf-8', (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                ctx.jsFiles[jsFilePath] = data;
                resolve(data);
            }
        });
    });
}
function readFile(sys, filePath) {
    return new Promise((resolve, reject) => {
        sys.fs.readFile(filePath, 'utf-8', (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
}
function writeFiles(sys, rootDir, filesToWrite) {
    const directories = getDirectoriesFromFiles(sys, filesToWrite);
    return ensureDirectoriesExist(sys, directories, [rootDir]).then(() => {
        return writeToDisk(sys, filesToWrite);
    });
}
function writeToDisk(sys, filesToWrite) {
    // assumes directories to be saved in already exit
    return new Promise((resolve, reject) => {
        const filePathsToWrite = Object.keys(filesToWrite);
        let doneWriting = 0;
        let rejected = false;
        if (!filePathsToWrite.length) {
            // shouldn't be possible, but ya never know
            resolve();
            return;
        }
        filePathsToWrite.forEach(filePathToWrite => {
            sys.fs.writeFile(filePathToWrite, filesToWrite[filePathToWrite], (err) => {
                if (err) {
                    rejected = true;
                    reject(err);
                }
                else {
                    doneWriting++;
                    if (doneWriting >= filePathsToWrite.length && !rejected) {
                        resolve();
                    }
                }
            });
        });
    });
}
function ensureDirectoriesExist(sys, directories, existingDirectories) {
    return new Promise(resolve => {
        const knowExistingDirPaths = existingDirectories.map(existingDirectory => {
            return normalizePath(existingDirectory).split('/');
        });
        const checkDirectories = sortDirectories(directories).slice();
        function ensureDir() {
            if (checkDirectories.length === 0) {
                resolve();
                return;
            }
            // double check this path has been normalized with / paths
            const checkDirectory = normalizePath(checkDirectories.shift());
            const dirPaths = checkDirectory.split('/');
            let pathSections = 1;
            function ensureSection() {
                if (pathSections > dirPaths.length) {
                    ensureDir();
                    return;
                }
                const checkDirPaths = dirPaths.slice(0, pathSections);
                // should have already been normalized to / paths
                const dirPath = checkDirPaths.join('/');
                for (var i = 0; i < knowExistingDirPaths.length; i++) {
                    var existingDirPaths = knowExistingDirPaths[i];
                    var alreadyExists = true;
                    for (var j = 0; j < checkDirPaths.length; j++) {
                        if (checkDirPaths[j] !== existingDirPaths[j]) {
                            alreadyExists = false;
                            break;
                        }
                    }
                    if (alreadyExists) {
                        pathSections++;
                        ensureSection();
                        return;
                    }
                }
                sys.fs.mkdir(normalizePath(dirPath), () => {
                    // not worrying about the error here
                    // if there's an error, it's probably because this directory already exists
                    // which is what we want, no need to check access AND mkdir
                    // should have already been normalized to / paths
                    knowExistingDirPaths.push(dirPath.split('/'));
                    pathSections++;
                    ensureSection();
                });
            }
            ensureSection();
        }
        ensureDir();
    });
}
function getDirectoriesFromFiles(sys, filesToWrite) {
    const directories = [];
    Object.keys(filesToWrite).forEach(filePath => {
        const dir = normalizePath(sys.path.dirname(filePath));
        if (directories.indexOf(dir) === -1) {
            directories.push(dir);
        }
    });
    return directories;
}
function sortDirectories(directories) {
    return directories.sort((a, b) => {
        // should have already been normalized to / paths
        const aPaths = a.split('/').length;
        const bPaths = b.split('/').length;
        if (aPaths < bPaths)
            return -1;
        if (aPaths > bPaths)
            return 1;
        if (a < b)
            return -1;
        if (a > b)
            return 1;
        return 0;
    });
}
function isTsFile(filePath) {
    const parts = filePath.toLowerCase().split('.');
    if (parts.length > 1) {
        if (parts[parts.length - 1] === 'ts' || parts[parts.length - 1] === 'tsx') {
            if (parts.length > 2 && (parts[parts.length - 2] === 'd' || parts[parts.length - 2] === 'spec')) {
                return false;
            }
            return true;
        }
    }
    return false;
}
function isDtsFile(filePath) {
    const parts = filePath.toLowerCase().split('.');
    if (parts.length > 2) {
        return (parts[parts.length - 2] === 'd' && parts[parts.length - 1] === 'ts');
    }
    return false;
}
function isJsFile(filePath) {
    const parts = filePath.toLowerCase().split('.');
    if (parts.length > 1) {
        if (parts[parts.length - 1] === 'js') {
            if (parts.length > 2 && parts[parts.length - 2] === 'spec') {
                return false;
            }
            return true;
        }
    }
    return false;
}
function isSassFile(filePath) {
    const ext = filePath.split('.').pop().toLowerCase();
    return ext === 'scss' || ext === 'sass';
}
function isCssFile(filePath) {
    return filePath.split('.').pop().toLowerCase() === 'css';
}
function isHtmlFile(filePath) {
    const ext = filePath.split('.').pop().toLowerCase();
    return ext === 'html' || ext === 'htm';
}
function isWebDevFile(filePath) {
    const ext = filePath.split('.').pop().toLowerCase();
    return (WEB_DEV_EXT.indexOf(ext) > -1 || isTsFile(filePath));
}
const WEB_DEV_EXT = ['js', 'jsx', 'html', 'htm', 'css', 'scss', 'sass'];
function generatePreamble(config, sourceTarget) {
    let preamble = [];
    if (config.preamble) {
        preamble = config.preamble.split('\n');
    }
    preamble.push(BANNER);
    if (preamble.length > 1) {
        preamble = preamble.map(l => ` * ${l}`);
        preamble.unshift(`/*!`);
        preamble.push(` */\n`);
        return preamble.join('\n');
    }
    return `/*! ${BANNER}${sourceTarget === 'es5' ? ' (es5)' : ''} */\n`;
}
function buildError(diagnostics) {
    const d = {
        level: 'error',
        type: 'build',
        header: 'build error',
        messageText: 'build error',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    diagnostics.push(d);
    return d;
}
function buildWarn(diagnostics) {
    const d = {
        level: 'warn',
        type: 'build',
        header: 'build warn',
        messageText: 'build warn',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    diagnostics.push(d);
    return d;
}
function catchError(diagnostics, err) {
    const d = {
        level: 'error',
        type: 'build',
        header: 'build error',
        messageText: 'build error',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    if (err) {
        if (err.stack) {
            d.messageText = err.stack.toString();
        }
        else {
            if (err.message) {
                d.messageText = err.message.toString();
            }
            else {
                d.messageText = err.toString();
            }
        }
    }
    diagnostics.push(d);
    return d;
}
function hasError(diagnostics) {
    if (!diagnostics) {
        return false;
    }
    return diagnostics.some(d => d.level === 'error' && d.type !== 'runtime');
}
function componentRequiresScopedStyles(encapsulation) {
    return (encapsulation === 2 /* ScopedCss */ || encapsulation === 1 /* ShadowDom */);
}
function pathJoin(config, ...paths) {
    return normalizePath(config.sys.path.join.apply(config.sys.path, paths));
}
function normalizePath(str) {
    // Convert Windows backslash paths to slash paths: foo\\bar ➔ foo/bar
    // https://github.com/sindresorhus/slash MIT
    // By Sindre Sorhus
    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {
        return str;
    }
    return str.replace(SLASH_REGEX, '/');
}
const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
const NON_ASCII_REGEX = /[^\x00-\x80]+/;
const SLASH_REGEX = /\\/g;

function buildExpressionReplacer(config, input) {
    return input
        .replace(/process.env.NODE_ENV(\s*)(===|==)(\s*)['"`]production['"`]/g, (!config.devMode).toString())
        .replace(/process.env.NODE_ENV(\s*)(!==|!=)(\s*)['"`]development['"`]/g, (!config.devMode).toString())
        .replace(/process.env.NODE_ENV(\s*)(===|==)(\s*)['"`]development['"`]/g, (config.devMode).toString())
        .replace(/process.env.NODE_ENV(\s*)(!==|!=)(\s*)['"`]production['"`]/g, (config.devMode).toString());
}

function cleanDiagnostics(diagnostics) {
    const cleaned = [];
    const maxErrors = Math.min(diagnostics.length, MAX_ERRORS);
    const dups = {};
    for (var i = 0; i < maxErrors; i++) {
        var d = diagnostics[i];
        var key = d.absFilePath + d.code + d.messageText + d.type;
        if (dups[key]) {
            continue;
        }
        dups[key] = true;
        if (d.messageText) {
            if (typeof d.messageText.message === 'string') {
                d.messageText = d.messageText.message;
            }
            else if (typeof d.messageText === 'string' && d.messageText.indexOf('Error: ') === 0) {
                d.messageText = d.messageText.substr(7);
            }
        }
        cleaned.push(d);
    }
    return cleaned;
}
function formatFileName(rootDir, fileName) {
    if (!rootDir || !fileName)
        return '';
    fileName = fileName.replace(rootDir, '');
    if (/\/|\\/.test(fileName.charAt(0))) {
        fileName = fileName.substr(1);
    }
    if (fileName.length > 80) {
        fileName = '...' + fileName.substr(fileName.length - 80);
    }
    return fileName;
}
function formatHeader(type, fileName, rootDir, startLineNumber = null, endLineNumber = null) {
    let header = `${type}: ${formatFileName(rootDir, fileName)}`;
    if (startLineNumber !== null && startLineNumber > 0) {
        if (endLineNumber !== null && endLineNumber > startLineNumber) {
            header += `, lines: ${startLineNumber} - ${endLineNumber}`;
        }
        else {
            header += `, line: ${startLineNumber}`;
        }
    }
    return header;
}

function splitLineBreaks(sourceText) {
    if (!sourceText)
        return [];
    sourceText = sourceText.replace(/\\r/g, '\n');
    return sourceText.split('\n');
}

const MAX_ERRORS = 15;

/**
 * Ported from highlight.js
 * Syntax highlighting with language autodetection.
 * https://highlightjs.org/
 * Copyright (c) 2006, Ivan Sagalaev
 * https://github.com/isagalaev/highlight.js/blob/master/LICENSE
 */
var hljs = {};
// Convenience variables for build-in objects
var objectKeys = Object.keys;
// Global internal variables used within the highlight.js library.
var languages = {};
var aliases = {};
var spanEndTag = '</span>';
// Global options used when within external APIs. This is modified when
// calling the `hljs.configure` function.
var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
};
// Object map that is used to escape some common HTML characters.
var escapeRegexMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
};
/* Utility functions */
function escape(value) {
    return value.replace(/[&<>]/gm, function (character) {
        return escapeRegexMap[character];
    });
}
function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
}
function inherit(parent, obj) {
    var key;
    var result = {};
    for (key in parent)
        result[key] = parent[key];
    if (obj)
        for (key in obj)
            result[key] = obj[key];
    return result;
}
/* Initialization */
function compileLanguage(language) {
    function reStr(re) {
        return (re && re.source) || re;
    }
    function langRe(value, global) {
        return new RegExp(reStr(value), 'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : ''));
    }
    function compileMode(mode, parent) {
        if (mode.compiled)
            return;
        mode.compiled = true;
        mode.keywords = mode.keywords || mode.beginKeywords;
        if (mode.keywords) {
            var compiled_keywords = {};
            var flatten = function (className, str) {
                if (language.case_insensitive) {
                    str = str.toLowerCase();
                }
                str.split(' ').forEach(function (kw) {
                    var pair = kw.split('|');
                    compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
                });
            };
            if (typeof mode.keywords === 'string') {
                flatten('keyword', mode.keywords);
            }
            else {
                objectKeys(mode.keywords).forEach(function (className) {
                    flatten(className, mode.keywords[className]);
                });
            }
            mode.keywords = compiled_keywords;
        }
        mode.lexemesRe = langRe(mode.lexemes || /\w+/, true);
        if (parent) {
            if (mode.beginKeywords) {
                mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
            }
            if (!mode.begin)
                mode.begin = /\B|\b/;
            mode.beginRe = langRe(mode.begin);
            if (!mode.end && !mode.endsWithParent)
                mode.end = /\B|\b/;
            if (mode.end)
                mode.endRe = langRe(mode.end);
            mode.terminator_end = reStr(mode.end) || '';
            if (mode.endsWithParent && parent.terminator_end)
                mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
        }
        if (mode.illegal)
            mode.illegalRe = langRe(mode.illegal);
        if (mode.relevance == null)
            mode.relevance = 1;
        if (!mode.contains) {
            mode.contains = [];
        }
        var expanded_contains = [];
        mode.contains.forEach(function (c) {
            if (c.variants) {
                c.variants.forEach(function (v) { expanded_contains.push(inherit(c, v)); });
            }
            else {
                expanded_contains.push(c === 'self' ? mode : c);
            }
        });
        mode.contains = expanded_contains;
        mode.contains.forEach(function (c) { compileMode(c, mode); });
        if (mode.starts) {
            compileMode(mode.starts, parent);
        }
        var terminators = mode.contains.map(function (c) {
            return c.beginKeywords ? '\\.?(' + c.begin + ')\\.?' : c.begin;
        })
            .concat([mode.terminator_end, mode.illegal])
            .map(reStr)
            .filter(Boolean);
        mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : { exec: function () { return null; } };
    }
    compileMode(language);
}

/*
Core highlighting function. Accepts a language name, or an alias, and a
string with the code to highlight. Returns an object with the following
properties:

- relevance (int)
- value (an HTML string with highlighting markup)

*/
function highlight(name, value, ignore_illegals, continuation) {
    function subMode(lexeme, mode) {
        var i, length;
        for (i = 0, length = mode.contains.length; i < length; i++) {
            if (testRe(mode.contains[i].beginRe, lexeme)) {
                return mode.contains[i];
            }
        }
    }
    function endOfMode(mode, lexeme) {
        if (testRe(mode.endRe, lexeme)) {
            while (mode.endsParent && mode.parent) {
                mode = mode.parent;
            }
            return mode;
        }
        if (mode.endsWithParent) {
            return endOfMode(mode.parent, lexeme);
        }
    }
    function isIllegal(lexeme, mode) {
        return !ignore_illegals && testRe(mode.illegalRe, lexeme);
    }
    function keywordMatch(mode, match) {
        var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
        return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }
    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {
        var classPrefix = noPrefix ? '' : options.classPrefix, openSpan = '<span class="' + classPrefix, closeSpan = leaveOpen ? '' : spanEndTag;
        openSpan += classname + '">';
        return openSpan + insideSpan + closeSpan;
    }
    function processKeywords() {
        var keyword_match, last_index, match, result;
        if (!top.keywords)
            return escape(mode_buffer);
        result = '';
        last_index = 0;
        top.lexemesRe.lastIndex = 0;
        match = top.lexemesRe.exec(mode_buffer);
        while (match) {
            result += escape(mode_buffer.substr(last_index, match.index - last_index));
            keyword_match = keywordMatch(top, match);
            if (keyword_match) {
                relevance += keyword_match[1];
                result += buildSpan(keyword_match[0], escape(match[0]));
            }
            else {
                result += escape(match[0]);
            }
            last_index = top.lexemesRe.lastIndex;
            match = top.lexemesRe.exec(mode_buffer);
        }
        return result + escape(mode_buffer.substr(last_index));
    }
    function processSubLanguage() {
        var explicit = typeof top.subLanguage === 'string';
        if (explicit && !languages[top.subLanguage]) {
            return escape(mode_buffer);
        }
        var result = explicit ?
            highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) :
            highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);
        // Counting embedded language score towards the host language may be disabled
        // with zeroing the containing mode relevance. Usecase in point is Markdown that
        // allows XML everywhere and makes every XML snippet to have a much larger Markdown
        // score.
        if (top.relevance > 0) {
            relevance += result.relevance;
        }
        if (explicit) {
            continuations[top.subLanguage] = result.top;
        }
        return buildSpan(result.language, result.value, false, true);
    }
    function processBuffer() {
        result += (top.subLanguage != null ? processSubLanguage() : processKeywords());
        mode_buffer = '';
    }
    function startNewMode(mode) {
        result += mode.className ? buildSpan(mode.className, '', true) : '';
        top = Object.create(mode, { parent: { value: top } });
    }
    function processLexeme(buffer, lexeme) {
        mode_buffer += buffer;
        if (lexeme == null) {
            processBuffer();
            return 0;
        }
        var new_mode = subMode(lexeme, top);
        if (new_mode) {
            if (new_mode.skip) {
                mode_buffer += lexeme;
            }
            else {
                if (new_mode.excludeBegin) {
                    mode_buffer += lexeme;
                }
                processBuffer();
                if (!new_mode.returnBegin && !new_mode.excludeBegin) {
                    mode_buffer = lexeme;
                }
            }
            startNewMode(new_mode);
            return new_mode.returnBegin ? 0 : lexeme.length;
        }
        var end_mode = endOfMode(top, lexeme);
        if (end_mode) {
            var origin = top;
            if (origin.skip) {
                mode_buffer += lexeme;
            }
            else {
                if (!(origin.returnEnd || origin.excludeEnd)) {
                    mode_buffer += lexeme;
                }
                processBuffer();
                if (origin.excludeEnd) {
                    mode_buffer = lexeme;
                }
            }
            do {
                if (top.className) {
                    result += spanEndTag;
                }
                if (!top.skip) {
                    relevance += top.relevance;
                }
                top = top.parent;
            } while (top !== end_mode.parent);
            if (end_mode.starts) {
                startNewMode(end_mode.starts);
            }
            return origin.returnEnd ? 0 : lexeme.length;
        }
        if (isIllegal(lexeme, top))
            throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
        /*
        Parser should not reach this point as all types of lexemes should be caught
        earlier, but if it does due to some bug make sure it advances at least one
        character forward to prevent infinite looping.
        */
        mode_buffer += lexeme;
        return lexeme.length || 1;
    }
    var language = getLanguage(name);
    if (!language) {
        throw new Error('Unknown language: "' + name + '"');
    }
    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '', current;
    for (current = top; current !== language; current = current.parent) {
        if (current.className) {
            result = buildSpan(current.className, '', true) + result;
        }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
        var match, count, index = 0;
        while (true) {
            top.terminators.lastIndex = index;
            match = top.terminators.exec(value);
            if (!match)
                break;
            count = processLexeme(value.substr(index, match.index - index), match[0]);
            index = match.index + count;
        }
        processLexeme(value.substr(index));
        for (current = top; current.parent; current = current.parent) {
            if (current.className) {
                result += spanEndTag;
            }
        }
        return {
            relevance: relevance,
            value: result,
            language: name,
            top: top
        };
    }
    catch (e) {
        if (e.message && e.message.indexOf('Illegal') !== -1) {
            return {
                relevance: 0,
                value: escape(value)
            };
        }
        else {
            throw e;
        }
    }
}
/*
Highlighting with language detection. Accepts a string with the code to
highlight. Returns an object with the following properties:

- language (detected language)
- relevance (int)
- value (an HTML string with highlighting markup)
- second_best (object with the same structure for second-best heuristically
  detected language, may be absent)

*/
function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
        relevance: 0,
        value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).forEach(function (name) {
        var current = highlight(name, text, false);
        current.language = name;
        if (current.relevance > second_best.relevance) {
            second_best = current;
        }
        if (current.relevance > result.relevance) {
            second_best = result;
            result = current;
        }
    });
    if (second_best.language) {
        result.second_best = second_best;
    }
    return result;
}
/*
Updates highlight.js global options with values passed in the form of an object.
*/
function configure(user_options) {
    options = inherit(options, user_options);
}
function registerLanguage(name, language) {
    var lang = languages[name] = language(hljs);
    if (lang.aliases) {
        lang.aliases.forEach(function (alias) { aliases[alias] = name; });
    }
}
function listLanguages() {
    return objectKeys(languages);
}
function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
}
/* Interface definition */
hljs.highlight = highlight;
hljs.highlightAuto = highlightAuto;
hljs.configure = configure;
hljs.registerLanguage = registerLanguage;
hljs.listLanguages = listLanguages;
hljs.getLanguage = getLanguage;
hljs.inherit = inherit;
// Common regexps
hljs.IDENT_RE = '[a-zA-Z]\\w*';
hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';
// Common modes
hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
};
hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
};
hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
};
hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\b/
};
hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit({
        className: 'comment',
        begin: begin, end: end,
        contains: []
    }, inherits || {});
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
        className: 'doctag',
        begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
        relevance: 0
    });
    return mode;
};
hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
};
hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
};
hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
};
hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' +
        '%|em|ex|ch|rem' +
        '|vw|vh|vmin|vmax' +
        '|cm|mm|in|pt|pc|px' +
        '|deg|grad|rad|turn' +
        '|s|ms' +
        '|Hz|kHz' +
        '|dpi|dpcm|dppx' +
        ')?',
    relevance: 0
};
hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
        hljs.BACKSLASH_ESCAPE,
        {
            begin: /\[/, end: /\]/,
            relevance: 0,
            contains: [hljs.BACKSLASH_ESCAPE]
        }
    ]
};
hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
};
hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
};
hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
};
hljs.registerLanguage('typescript', typescript);
function typescript(hljs) {
    var KEYWORDS = {
        keyword: 'in if for while finally var new function do return void else break catch ' +
            'instanceof with throw case default try this switch continue typeof delete ' +
            'let yield const class public private protected get set super ' +
            'static implements enum export import declare type namespace abstract',
        literal: 'true false null undefined NaN Infinity',
        built_in: 'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' +
            'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' +
            'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' +
            'TypeError URIError Number Math Date String RegExp Array Float32Array ' +
            'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' +
            'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' +
            'module console window document any number boolean string void'
    };
    return {
        aliases: ['ts'],
        keywords: KEYWORDS,
        contains: [
            {
                className: 'meta',
                begin: /^\s*['"]use strict['"]/
            },
            hljs.APOS_STRING_MODE,
            hljs.QUOTE_STRING_MODE,
            {
                className: 'string',
                begin: '`', end: '`',
                contains: [
                    hljs.BACKSLASH_ESCAPE,
                    {
                        className: 'subst',
                        begin: '\\$\\{', end: '\\}'
                    }
                ]
            },
            hljs.C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE,
            {
                className: 'number',
                variants: [
                    { begin: '\\b(0[bB][01]+)' },
                    { begin: '\\b(0[oO][0-7]+)' },
                    { begin: hljs.C_NUMBER_RE }
                ],
                relevance: 0
            },
            {
                begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
                keywords: 'return throw case',
                contains: [
                    hljs.C_LINE_COMMENT_MODE,
                    hljs.C_BLOCK_COMMENT_MODE,
                    hljs.REGEXP_MODE
                ],
                relevance: 0
            },
            {
                className: 'function',
                begin: 'function', end: /[\{;]/, excludeEnd: true,
                keywords: KEYWORDS,
                contains: [
                    'self',
                    hljs.inherit(hljs.TITLE_MODE, { begin: /[A-Za-z$_][0-9A-Za-z$_]*/ }),
                    {
                        className: 'params',
                        begin: /\(/, end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS,
                        contains: [
                            hljs.C_LINE_COMMENT_MODE,
                            hljs.C_BLOCK_COMMENT_MODE
                        ],
                        illegal: /["'\(]/
                    }
                ],
                illegal: /%/,
                relevance: 0 // () => {} is more typical in TypeScript
            },
            {
                beginKeywords: 'constructor', end: /\{/, excludeEnd: true
            },
            {
                begin: /module\./,
                keywords: { built_in: 'module' },
                relevance: 0
            },
            {
                beginKeywords: 'module', end: /\{/, excludeEnd: true
            },
            {
                beginKeywords: 'interface', end: /\{/, excludeEnd: true,
                keywords: 'interface extends'
            },
            {
                begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
            },
            {
                begin: '\\.' + hljs.IDENT_RE, relevance: 0 // hack: prevents detection of keywords after dots
            }
        ]
    };
}
hljs.registerLanguage('scss', scss);
function scss(hljs) {
    var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
    var VARIABLE = {
        className: 'variable',
        begin: '(\\$' + IDENT_RE + ')\\b'
    };
    var HEXCOLOR = {
        className: 'number', begin: '#[0-9A-Fa-f]+'
    };
    // var DEF_INTERNALS = {
    //   className: 'attribute',
    //   begin: '[A-Z\\_\\.\\-]+', end: ':',
    //   excludeEnd: true,
    //   illegal: '[^\\s]',
    //   starts: {
    //     endsWithParent: true, excludeEnd: true,
    //     contains: [
    //       HEXCOLOR,
    //       hljs.CSS_NUMBER_MODE,
    //       hljs.QUOTE_STRING_MODE,
    //       hljs.APOS_STRING_MODE,
    //       hljs.C_BLOCK_COMMENT_MODE,
    //       {
    //         className: 'meta', begin: '!important'
    //       }
    //     ]
    //   }
    // };
    return {
        case_insensitive: true,
        illegal: '[=/|\']',
        contains: [
            hljs.C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE,
            {
                className: 'selector-id', begin: '\\#[A-Za-z0-9_-]+',
                relevance: 0
            },
            {
                className: 'selector-class', begin: '\\.[A-Za-z0-9_-]+',
                relevance: 0
            },
            {
                className: 'selector-attr', begin: '\\[', end: '\\]',
                illegal: '$'
            },
            {
                className: 'selector-tag',
                begin: '\\b(a|abbr|acronym|address|area|article|aside|audio|b|base|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|command|datalist|dd|del|details|dfn|div|dl|dt|em|embed|fieldset|figcaption|figure|footer|form|frame|frameset|(h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|keygen|label|legend|li|link|map|mark|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|pre|progress|q|rp|rt|ruby|samp|script|section|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|tt|ul|var|video)\\b',
                relevance: 0
            },
            {
                begin: ':(visited|valid|root|right|required|read-write|read-only|out-range|optional|only-of-type|only-child|nth-of-type|nth-last-of-type|nth-last-child|nth-child|not|link|left|last-of-type|last-child|lang|invalid|indeterminate|in-range|hover|focus|first-of-type|first-line|first-letter|first-child|first|enabled|empty|disabled|default|checked|before|after|active)'
            },
            {
                begin: '::(after|before|choices|first-letter|first-line|repeat-index|repeat-item|selection|value)'
            },
            VARIABLE,
            {
                className: 'attribute',
                begin: '\\b(z-index|word-wrap|word-spacing|word-break|width|widows|white-space|visibility|vertical-align|unicode-bidi|transition-timing-function|transition-property|transition-duration|transition-delay|transition|transform-style|transform-origin|transform|top|text-underline-position|text-transform|text-shadow|text-rendering|text-overflow|text-indent|text-decoration-style|text-decoration-line|text-decoration-color|text-decoration|text-align-last|text-align|tab-size|table-layout|right|resize|quotes|position|pointer-events|perspective-origin|perspective|page-break-inside|page-break-before|page-break-after|padding-top|padding-right|padding-left|padding-bottom|padding|overflow-y|overflow-x|overflow-wrap|overflow|outline-width|outline-style|outline-offset|outline-color|outline|orphans|order|opacity|object-position|object-fit|normal|none|nav-up|nav-right|nav-left|nav-index|nav-down|min-width|min-height|max-width|max-height|mask|marks|margin-top|margin-right|margin-left|margin-bottom|margin|list-style-type|list-style-position|list-style-image|list-style|line-height|letter-spacing|left|justify-content|initial|inherit|ime-mode|image-orientation|image-resolution|image-rendering|icon|hyphens|height|font-weight|font-variant-ligatures|font-variant|font-style|font-stretch|font-size-adjust|font-size|font-language-override|font-kerning|font-feature-settings|font-family|font|float|flex-wrap|flex-shrink|flex-grow|flex-flow|flex-direction|flex-basis|flex|filter|empty-cells|display|direction|cursor|counter-reset|counter-increment|content|column-width|column-span|column-rule-width|column-rule-style|column-rule-color|column-rule|column-gap|column-fill|column-count|columns|color|clip-path|clip|clear|caption-side|break-inside|break-before|break-after|box-sizing|box-shadow|box-decoration-break|bottom|border-width|border-top-width|border-top-style|border-top-right-radius|border-top-left-radius|border-top-color|border-top|border-style|border-spacing|border-right-width|border-right-style|border-right-color|border-right|border-radius|border-left-width|border-left-style|border-left-color|border-left|border-image-width|border-image-source|border-image-slice|border-image-repeat|border-image-outset|border-image|border-color|border-collapse|border-bottom-width|border-bottom-style|border-bottom-right-radius|border-bottom-left-radius|border-bottom-color|border-bottom|border|background-size|background-repeat|background-position|background-origin|background-image|background-color|background-clip|background-attachment|background-blend-mode|background|backface-visibility|auto|animation-timing-function|animation-play-state|animation-name|animation-iteration-count|animation-fill-mode|animation-duration|animation-direction|animation-delay|animation|align-self|align-items|align-content)\\b',
                illegal: '[^\\s]'
            },
            {
                begin: '\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b'
            },
            {
                begin: ':', end: ';',
                contains: [
                    VARIABLE,
                    HEXCOLOR,
                    hljs.CSS_NUMBER_MODE,
                    hljs.QUOTE_STRING_MODE,
                    hljs.APOS_STRING_MODE,
                    {
                        className: 'meta', begin: '!important'
                    }
                ]
            },
            {
                begin: '@', end: '[{;]',
                keywords: 'mixin include extend for if else each while charset import debug media page content font-face namespace warn',
                contains: [
                    VARIABLE,
                    hljs.QUOTE_STRING_MODE,
                    hljs.APOS_STRING_MODE,
                    HEXCOLOR,
                    hljs.CSS_NUMBER_MODE,
                    {
                        begin: '\\s[A-Za-z0-9_.-]+',
                        relevance: 0
                    }
                ]
            }
        ]
    };
}
hljs.registerLanguage('xml', xml);
function xml(hljs) {
    var XML_IDENT_RE = '[A-Za-z0-9\\._:-]+';
    var TAG_INTERNALS = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [
            {
                className: 'attr',
                begin: XML_IDENT_RE,
                relevance: 0
            },
            {
                begin: /=\s*/,
                relevance: 0,
                contains: [
                    {
                        className: 'string',
                        endsParent: true,
                        variants: [
                            { begin: /"/, end: /"/ },
                            { begin: /'/, end: /'/ },
                            { begin: /[^\s"'=<>`]+/ }
                        ]
                    }
                ]
            }
        ]
    };
    return {
        aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist'],
        case_insensitive: true,
        contains: [
            {
                className: 'meta',
                begin: '<!DOCTYPE', end: '>',
                relevance: 10,
                contains: [{ begin: '\\[', end: '\\]' }]
            },
            hljs.COMMENT('<!--', '-->', {
                relevance: 10
            }),
            {
                begin: '<\\!\\[CDATA\\[', end: '\\]\\]>',
                relevance: 10
            },
            {
                begin: /<\?(php)?/, end: /\?>/,
                subLanguage: 'php',
                contains: [{ begin: '/\\*', end: '\\*/', skip: true }]
            },
            {
                className: 'tag',
                /*
                The lookahead pattern (?=...) ensures that 'begin' only matches
                '<style' as a single word, followed by a whitespace or an
                ending braket. The '$' is needed for the lexeme to be recognized
                by hljs.subMode() that tests lexemes outside the stream.
                */
                begin: '<style(?=\\s|>|$)', end: '>',
                keywords: { name: 'style' },
                contains: [TAG_INTERNALS],
                starts: {
                    end: '</style>', returnEnd: true,
                    subLanguage: ['css', 'xml']
                }
            },
            {
                className: 'tag',
                // See the comment in the <style tag about the lookahead pattern
                begin: '<script(?=\\s|>|$)', end: '>',
                keywords: { name: 'script' },
                contains: [TAG_INTERNALS],
                starts: {
                    end: '\<\/script\>', returnEnd: true,
                    subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']
                }
            },
            {
                className: 'meta',
                variants: [
                    { begin: /<\?xml/, end: /\?>/, relevance: 10 },
                    { begin: /<\?\w+/, end: /\?>/ }
                ]
            },
            {
                className: 'tag',
                begin: '</?', end: '/?>',
                contains: [
                    {
                        className: 'name', begin: /[^\/><\s]+/, relevance: 0
                    },
                    TAG_INTERNALS
                ]
            }
        ]
    };
}

function loadRollupDiagnostics(config, resultsDiagnostics, rollupError) {
    const d = {
        level: 'error',
        type: 'build',
        language: 'javascript',
        header: 'build error',
        code: rollupError.code,
        messageText: rollupError.message,
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    if (rollupError.loc && rollupError.loc.file) {
        d.absFilePath = rollupError.loc.file;
        d.relFilePath = formatFileName(config.rootDir, d.absFilePath);
        try {
            let sourceText = config.sys.fs.readFileSync(d.absFilePath, 'utf-8');
            let srcLines = splitLineBreaks(sourceText);
            let htmlLines = srcLines;
            try {
                htmlLines = splitLineBreaks(highlight(d.language, sourceText, true).value);
            }
            catch (e) { }
            const errorLine = {
                lineIndex: rollupError.loc.line - 1,
                lineNumber: rollupError.loc.line,
                text: srcLines[rollupError.loc.line - 1],
                html: htmlLines[rollupError.loc.line - 1],
                errorCharStart: rollupError.loc.column,
                errorLength: 0
            };
            let highlightLine = errorLine.text.substr(rollupError.loc.column);
            for (var i = 0; i < highlightLine.length; i++) {
                if (CHAR_BREAK.indexOf(highlightLine.charAt(i)) > -1) {
                    break;
                }
                errorLine.errorLength++;
            }
            if (errorLine.html && errorLine.html.indexOf('class="hljs') === -1) {
                try {
                    errorLine.html = highlight(d.language, errorLine.text, true).value;
                }
                catch (e) { }
            }
            d.lines.push(errorLine);
            if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
                errorLine.errorLength = 1;
                errorLine.errorCharStart--;
            }
            d.header = formatHeader('bundling', d.absFilePath, config.rootDir, errorLine.lineNumber);
            if (errorLine.lineIndex > 0) {
                const previousLine = {
                    lineIndex: errorLine.lineIndex - 1,
                    lineNumber: errorLine.lineNumber - 1,
                    text: srcLines[errorLine.lineIndex - 1],
                    html: htmlLines[errorLine.lineIndex - 1],
                    errorCharStart: -1,
                    errorLength: -1
                };
                if (previousLine.html && previousLine.html.indexOf('class="hljs') === -1) {
                    try {
                        previousLine.html = highlight(d.language, previousLine.text, true).value;
                    }
                    catch (e) { }
                }
                d.lines.unshift(previousLine);
            }
            if (errorLine.lineIndex + 1 < srcLines.length) {
                const nextLine = {
                    lineIndex: errorLine.lineIndex + 1,
                    lineNumber: errorLine.lineNumber + 1,
                    text: srcLines[errorLine.lineIndex + 1],
                    html: htmlLines[errorLine.lineIndex + 1],
                    errorCharStart: -1,
                    errorLength: -1
                };
                if (nextLine.html && nextLine.html.indexOf('class="hljs') === -1) {
                    try {
                        nextLine.html = highlight(d.language, nextLine.text, true).value;
                    }
                    catch (e) { }
                }
                d.lines.push(nextLine);
            }
        }
        catch (e) {
            d.messageText = `Error parsing: ${rollupError.loc.file}, line: ${rollupError.loc.line}, column: ${rollupError.loc.column}`;
        }
    }
    resultsDiagnostics.push(d);
}
const CHAR_BREAK = [' ', '=', '.', ',', '?', ':', ';', '(', ')', '{', '}', '[', ']', '|', `'`, `"`, '`'];
function createOnWarnFn(diagnostics, bundleModulesFiles) {
    const previousWarns = {};
    return function onWarningMessage(warning) {
        if (warning && warning.message in previousWarns) {
            return;
        }
        if (warning && warning.code) {
            if (INGORE_BUNDLE_CODES.indexOf(warning.code) > -1) {
                return;
            }
        }
        previousWarns[warning.message] = true;
        let label = '';
        if (bundleModulesFiles) {
            label = bundleModulesFiles.map(moduleFile => moduleFile.cmpMeta.tagNameMeta).join(', ').trim();
            if (label.length) {
                label += ': ';
            }
        }
        buildWarn(diagnostics).messageText = label + (warning.message || warning);
    };
}
const INGORE_BUNDLE_CODES = [
    `THIS_IS_UNDEFINED`, `NON_EXISTENT_EXPORT`
];

const isDef = (v) => v !== undefined && v !== null;
const isUndef = (v) => v === undefined || v === null;





const toLowerCase = (str) => str.toLowerCase();
const toDashCase = (str) => str.replace(/([A-Z])/g, (g) => '-' + toLowerCase(g[0]));

const dashToPascalCase = (word) => word.split('-').map((segment) => {
    segment = segment.toLocaleLowerCase();
    return segment.charAt(0).toUpperCase() + segment.slice(1);
}).join('');
const noop = () => { };

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function localResolver(config) {
    return {
        resolveId(importee, importer) {
            return __awaiter(this, void 0, void 0, function* () {
                if (importee.indexOf('./') === -1) {
                    return null;
                }
                if (!importer) {
                    return null;
                }
                const basename = config.sys.path.basename(importer);
                const directory = importer.split(basename)[0];
                const dirIndexFile = config.sys.path.join(directory + importee, 'index.js');
                try {
                    yield config.sys.ensureFile(dirIndexFile);
                    return dirIndexFile;
                }
                catch (e) { }
                return null;
            });
        },
    };
}

function generateComponentModules(config, ctx, manifestBundle) {
    const bundleCacheKey = getModuleBundleCacheKey(manifestBundle.moduleFiles.map(m => m.cmpMeta.tagNameMeta));
    if (canSkipBuild(config, ctx, manifestBundle.moduleFiles, bundleCacheKey)) {
        // don't bother bundling if this is a change build but
        // none of the changed files are modules or components
        manifestBundle.compiledModuleText = ctx.moduleBundleOutputs[bundleCacheKey];
        return Promise.resolve();
    }
    // create the input file for the bundler
    // returned value is array of strings so it needs to be joined here
    const moduleBundleInput = createInMemoryBundleInput(manifestBundle.moduleFiles).join('\n');
    return bundleComponents(config, ctx, manifestBundle, moduleBundleInput, bundleCacheKey);
}
function bundleComponents(config, ctx, manifestBundle, moduleBundleInput, bundleCacheKey) {
    // start the bundler on our temporary file
    return config.sys.rollup.rollup({
        input: IN_MEMORY_INPUT,
        plugins: [
            config.sys.rollup.plugins.nodeResolve({
                jsnext: true,
                main: true
            }),
            config.sys.rollup.plugins.commonjs({
                include: 'node_modules/**',
                sourceMap: false
            }),
            entryInMemoryPlugin(IN_MEMORY_INPUT, moduleBundleInput),
            transpiledInMemoryPlugin(config, ctx),
            localResolver(config),
        ],
        onwarn: createOnWarnFn(ctx.diagnostics, manifestBundle.moduleFiles)
    }).catch(err => {
        loadRollupDiagnostics(config, ctx.diagnostics, err);
    }).then(rollupBundle => {
        if (hasError(ctx.diagnostics) || !rollupBundle) {
            return Promise.resolve();
        }
        // generate the bundler results
        return rollupBundle.generate({
            format: 'es'
        }).then(results => {
            bundleComponentsResults(config, ctx, manifestBundle, bundleCacheKey, results.code.trim());
        });
    });
}
function bundleComponentsResults(config, ctx, manifestBundle, bundleCacheKey, resultsCode) {
    // module bundling finished, assign its content to the user's bundle
    manifestBundle.compiledModuleText = resultsCode;
    // replace build time expressions, like process.env.NODE_ENV === 'production'
    // with a hard coded boolean
    manifestBundle.compiledModuleText = buildExpressionReplacer(config, manifestBundle.compiledModuleText);
    // cache for later
    ctx.moduleBundleOutputs[bundleCacheKey] = manifestBundle.compiledModuleText;
    // keep track of module bundling for testing
    ctx.moduleBundleCount++;
}
function wrapComponentImports(content) {
    return `function importComponent(exports, h, Context, publicPath) {\n"use strict";\n${content}\n}`;
}
function transpiledInMemoryPlugin(config, ctx) {
    const sys = config.sys;
    const assetsCache = {};
    return {
        name: 'transpiledInMemoryPlugin',
        resolveId(importee, importer) {
            if (!sys.path.isAbsolute(importee)) {
                importee = normalizePath(sys.path.resolve(importer ? sys.path.dirname(importer) : sys.path.resolve(), importee));
                if (importee.indexOf('.js') === -1) {
                    importee += '.js';
                }
            }
            // it's possible the importee is a file pointing directly to the source ts file
            // if it is a ts file path, then we're good to go
            var moduleFile = ctx.moduleFiles[importee];
            if (ctx.moduleFiles[importee]) {
                return moduleFile.jsFilePath;
            }
            const tsFileNames = Object.keys(ctx.moduleFiles);
            for (var i = 0; i < tsFileNames.length; i++) {
                // see if we can find by importeE
                moduleFile = ctx.moduleFiles[tsFileNames[i]];
                if (moduleFile.jsFilePath === importee) {
                    // awesome, there's a module file for this js file, we're good here
                    return importee;
                }
            }
            // let's check all of the asset directories for this path
            // think slide's swiper dependency
            for (i = 0; i < tsFileNames.length; i++) {
                // see if we can find by importeR
                moduleFile = ctx.moduleFiles[tsFileNames[i]];
                if (moduleFile.jsFilePath === importer) {
                    // awesome, there's a module file for this js file via importeR
                    // now let's check if this module has an assets directory
                    if (moduleFile.cmpMeta && moduleFile.cmpMeta.assetsDirsMeta) {
                        for (var j = 0; j < moduleFile.cmpMeta.assetsDirsMeta.length; j++) {
                            var assetsAbsPath = moduleFile.cmpMeta.assetsDirsMeta[j].absolutePath;
                            var importeeFileName = sys.path.basename(importee);
                            var assetsFilePath = normalizePath(sys.path.join(assetsAbsPath, importeeFileName));
                            // ok, we've got a potential absolute path where the file "could" be
                            try {
                                // let's see if it actually exists, but with readFileSync :(
                                assetsCache[assetsFilePath] = sys.fs.readFileSync(assetsFilePath, 'utf-8');
                                if (typeof assetsCache[assetsFilePath] === 'string') {
                                    return assetsFilePath;
                                }
                            }
                            catch (e) {
                                config.logger.debug(`asset ${assetsFilePath} did not exist`);
                            }
                        }
                    }
                }
            }
            return null;
        },
        load(sourcePath) {
            sourcePath = normalizePath(sourcePath);
            if (typeof ctx.jsFiles[sourcePath] === 'string') {
                // perfect, we already got this js file cached
                return ctx.jsFiles[sourcePath];
            }
            if (typeof assetsCache[sourcePath] === 'string') {
                // awesome, this is one of the cached asset file we already read in resolveId
                return assetsCache[sourcePath];
            }
            // ok so it's not in one of our caches, so let's look it up directly
            // but with readFileSync :(
            const jsText = sys.fs.readFileSync(sourcePath, 'utf-8');
            ctx.moduleFiles[sourcePath] = {
                jsFilePath: sourcePath,
            };
            ctx.jsFiles[sourcePath] = jsText;
            return jsText;
        }
    };
}
function entryInMemoryPlugin(entryKey, moduleBundleInput) {
    // used just so we don't have to write a temporary file to disk
    // just to turn around and immediately have rollup open and read it
    return {
        name: 'entryInMemoryPlugin',
        resolveId(importee) {
            if (importee === entryKey) {
                return entryKey;
            }
            return null;
        },
        load(sourcePath) {
            if (sourcePath === entryKey) {
                return moduleBundleInput;
            }
            return null;
        }
    };
}
function createInMemoryBundleInput(moduleFiles) {
    const entryFileLines = [];
    moduleFiles.sort((a, b) => {
        if (a.cmpMeta.tagNameMeta.toLowerCase() < b.cmpMeta.tagNameMeta.toLowerCase())
            return -1;
        if (a.cmpMeta.tagNameMeta.toLowerCase() > b.cmpMeta.tagNameMeta.toLowerCase())
            return 1;
        return 0;
    }).forEach(moduleFile => {
        // create a full path to the modules to import
        const importPath = moduleFile.jsFilePath;
        const asName = dashToPascalCase(moduleFile.cmpMeta.tagNameMeta);
        // manually create the content for our temporary entry file for the bundler
        entryFileLines.push(generateBundleImport(moduleFile.cmpMeta.componentClass, asName, importPath));
        // export map should always use UPPER CASE tag name
        entryFileLines.push(generateBundleExport(moduleFile.cmpMeta.tagNameMeta, asName));
    });
    // create the entry file for the bundler
    return entryFileLines;
}
function generateBundleImport(cmpClassName, asName, importPath) {
    return `import { ${cmpClassName} as ${asName} } from "${normalizePath(importPath)}";`;
}
function generateBundleExport(tagName, asName) {
    return `exports['${tagName.toLowerCase()}'] = ${asName};`;
}
function canSkipBuild(config, ctx, moduleFiles, cacheKey) {
    // must build if it's not a change build
    if (!ctx.isChangeBuild) {
        return false;
    }
    // cannot skip if there isn't anything cached
    if (!ctx.moduleBundleOutputs[cacheKey]) {
        return false;
    }
    // must rebuild if it's non-component changes
    // basically don't know of deps of deps changed, so play it safe
    if (ctx.changeHasNonComponentModules) {
        return false;
    }
    // ok to skip if it wasn't a component module change
    if (!ctx.changeHasComponentModules) {
        return true;
    }
    // check if this bundle has one of the changed files
    const bundleContainsChangedFile = bundledComponentContainsChangedFile(config, moduleFiles, ctx.changedFiles);
    if (!bundleContainsChangedFile) {
        // don't bother bundling, none of the changed files have the same filename
        return true;
    }
    // idk, probs need to bundle, can't skip
    return false;
}
function bundledComponentContainsChangedFile(config, bundlesModuleFiles, changedFiles) {
    // loop through all the changed typescript filenames and see if there are corresponding js filenames
    // if there are no filenames that match then let's not bundle
    // yes...there could be two files that have the same filename in different directories
    // but worst case scenario is that both of them run their bundling, which isn't a performance problem
    return bundlesModuleFiles.some(moduleFile => {
        const distFileName = config.sys.path.basename(moduleFile.jsFilePath, '.js');
        return changedFiles.some(f => {
            const changedFileName = config.sys.path.basename(f);
            return (changedFileName === distFileName + '.ts' || changedFileName === distFileName + '.tsx');
        });
    });
}
function getModuleBundleCacheKey(components) {
    return components.map(c => c.toLocaleLowerCase().trim()).sort().join('.');
}
const IN_MEMORY_INPUT = '__IN_MEMORY_INPUT__';

function bundleModules(config, ctx, manifestBundles) {
    // create main module results object
    if (hasError(ctx.diagnostics)) {
        return Promise.resolve();
    }
    // do bundling if this is not a change build
    // or it's a change build that has either changed modules or components
    const doBundling = (!ctx.isChangeBuild || ctx.changeHasComponentModules || ctx.changeHasNonComponentModules);
    const timeSpan = config.logger.createTimeSpan(`bundle modules started`, !doBundling);
    return Promise.all(manifestBundles.map(manifestBundle => {
        return generateComponentModules(config, ctx, manifestBundle);
    })).catch(err => {
        catchError(ctx.diagnostics, err);
    }).then(() => {
        timeSpan.finish('bundle modules finished');
    });
}

/**
 * This file is a port of shadow_css.ts from Angular,
 * which is a port of shadowCSS from webcomponents.js to TypeScript.
 * https://github.com/angular/angular/blob/master/packages/compiler/src/shadow_css.ts
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
 *
 * Please make sure to keep to edits in sync with the source file.
 *
 * Source:
 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
 *
 * The original file level comment is reproduced below
 */
/*
  This is a limited shim for ShadowDOM css styling.
  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

  The intention here is to support only the styling features which can be
  relatively simply implemented. The goal is to allow users to avoid the
  most obvious pitfalls and do so without compromising performance significantly.
  For ShadowDOM styling that's not covered here, a set of best practices
  can be provided that should allow users to accomplish more complex styling.

  The following is a list of specific ShadowDOM styling features and a brief
  discussion of the approach used to shim.

  Shimmed features:

  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
  element using the :host rule. To shim this feature, the :host styles are
  reformatted and prefixed with a given scope name and promoted to a
  document level stylesheet.
  For example, given a scope name of .foo, a rule like this:

    :host {
        background: red;
      }
    }

  becomes:

    .foo {
      background: red;
    }

  * encapsulation: Styles defined within ShadowDOM, apply only to
  dom inside the ShadowDOM. Polymer uses one of two techniques to implement
  this feature.

  By default, rules are prefixed with the host element tag name
  as a descendant selector. This ensures styling does not leak out of the 'top'
  of the element's ShadowDOM. For example,

  div {
      font-weight: bold;
    }

  becomes:

  x-foo div {
      font-weight: bold;
    }

  becomes:


  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
  selectors are scoped by adding an attribute selector suffix to each
  simple selector that contains the host element tag name. Each element
  in the element's ShadowDOM template is also given the scope attribute.
  Thus, these rules match only elements that have the scope attribute.
  For example, given a scope name of x-foo, a rule like this:

    div {
      font-weight: bold;
    }

  becomes:

    div[x-foo] {
      font-weight: bold;
    }

  Note that elements that are dynamically added to a scope must have the scope
  selector added to them manually.

  * upper/lower bound encapsulation: Styles which are defined outside a
  shadowRoot should not cross the ShadowDOM boundary and should not apply
  inside a shadowRoot.

  This styling behavior is not emulated. Some possible ways to do this that
  were rejected due to complexity and/or performance concerns include: (1) reset
  every possible property for every possible selector for a given scope name;
  (2) re-implement css in javascript.

  As an alternative, users should make sure to use selectors
  specific to the scope in which they are working.

  * ::distributed: This behavior is not emulated. It's often not necessary
  to style the contents of a specific insertion point and instead, descendants
  of the host element can be styled selectively. Users can also create an
  extra node around an insertion point and style that node's contents
  via descendent selectors. For example, with a shadowRoot like this:

    <style>
      ::content(div) {
        background: red;
      }
    </style>
    <content></content>

  could become:

    <style>
      / *@polyfill .content-container div * /
      ::content(div) {
        background: red;
      }
    </style>
    <div class="content-container">
      <content></content>
    </div>

  Note the use of @polyfill in the comment above a ShadowDOM specific style
  declaration. This is a directive to the styling shim to use the selector
  in comments in lieu of the next selector when running under polyfill.
*/
class ShadowCss {
    constructor() {
        this.strictStyling = true;
    }
    /*
    * Shim some cssText with the given selector. Returns cssText that can
    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
    *
    * When strictStyling is true:
    * - selector is the attribute added to all elements inside the host,
    * - hostSelector is the attribute added to the host itself.
    */
    shimCssText(cssText, selector, hostSelector = '', slotSelector = '') {
        const sourceMappingUrl = extractSourceMappingUrl(cssText);
        cssText = stripComments(cssText);
        cssText = this._insertDirectives(cssText);
        return this._scopeCssText(cssText, selector, hostSelector, slotSelector) + sourceMappingUrl;
    }
    _insertDirectives(cssText) {
        cssText = this._insertPolyfillDirectivesInCssText(cssText);
        return this._insertPolyfillRulesInCssText(cssText);
    }
    /*
     * Process styles to convert native ShadowDOM rules that will trip
     * up the css parser; we rely on decorating the stylesheet with inert rules.
     *
     * For example, we convert this rule:
     *
     * polyfill-next-selector { content: ':host menu-item'; }
     * ::content menu-item {
     *
     * to this:
     *
     * scopeName menu-item {
     *
    **/
    _insertPolyfillDirectivesInCssText(cssText) {
        // Difference with webcomponents.js: does not handle comments
        return cssText.replace(_cssContentNextSelectorRe, function (...m) { return m[2] + '{'; });
    }
    /*
     * Process styles to add rules which will only apply under the polyfill
     *
     * For example, we convert this rule:
     *
     * polyfill-rule {
     *   content: ':host menu-item';
     * ...
     * }
     *
     * to this:
     *
     * scopeName menu-item {...}
     *
    **/
    _insertPolyfillRulesInCssText(cssText) {
        // Difference with webcomponents.js: does not handle comments
        return cssText.replace(_cssContentRuleRe, (...m) => {
            const rule = m[0].replace(m[1], '').replace(m[2], '');
            return m[4] + rule;
        });
    }
    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
     *
     *  .foo {... }
     *
     *  and converts this to
     *
     *  scopeName .foo { ... }
    */
    _scopeCssText(cssText, scopeSelector, hostSelector, slotSelector) {
        const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
        cssText = this._insertPolyfillHostInCssText(cssText);
        cssText = this._convertColonHost(cssText);
        cssText = this._convertColonHostContext(cssText);
        cssText = this._convertColonSlotted(cssText, slotSelector);
        cssText = this._convertShadowDOMSelectors(cssText);
        if (scopeSelector) {
            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector, slotSelector);
        }
        cssText = cssText + '\n' + unscopedRules;
        cssText = cssText.replace(/-shadowcsshost-no-combinator/g, `[${hostSelector}]`);
        return cssText.trim();
    }
    /*
     * Process styles to add rules which will only apply under the polyfill
     * and do not process via CSSOM. (CSSOM is destructive to rules on rare
     * occasions, e.g. -webkit-calc on Safari.)
     * For example, we convert this rule:
     *
     * @polyfill-unscoped-rule {
     *   content: 'menu-item';
     * ... }
     *
     * to this:
     *
     * menu-item {...}
     *
    **/
    _extractUnscopedRulesFromCssText(cssText) {
        // Difference with webcomponents.js: does not handle comments
        let r = '';
        let m;
        _cssContentUnscopedRuleRe.lastIndex = 0;
        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
            const rule = m[0].replace(m[2], '').replace(m[1], m[4]);
            r += rule + '\n\n';
        }
        return r;
    }
    /*
     * convert a rule like :host(.foo) > .bar { }
     *
     * to
     *
     * .foo<scopeName> > .bar
    */
    _convertColonHost(cssText) {
        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
    }
    /*
     * convert a rule like ::slotted(.foo) { }
    */
    _convertColonSlotted(cssText, slotAttr) {
        const regExp = _cssColonSlottedRe;
        return cssText.replace(regExp, function (...m) {
            if (m[2]) {
                let compound = m[2].trim();
                let suffix = m[3];
                let sel = '[' + slotAttr + '] > ' + compound + suffix;
                return sel;
            }
            else {
                return _polyfillHostNoCombinator + m[3];
            }
        });
    }
    /*
     * convert a rule like :host-context(.foo) > .bar { }
     *
     * to
     *
     * .foo<scopeName> > .bar, .foo scopeName > .bar { }
     *
     * and
     *
     * :host-context(.foo:host) .bar { ... }
     *
     * to
     *
     * .foo<scopeName> .bar { ... }
    */
    _convertColonHostContext(cssText) {
        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
    }
    _convertColonRule(cssText, regExp, partReplacer) {
        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
        return cssText.replace(regExp, function (...m) {
            if (m[2]) {
                const parts = m[2].split(',');
                const r = [];
                for (let i = 0; i < parts.length; i++) {
                    const p = parts[i].trim();
                    if (!p)
                        break;
                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                }
                return r.join(',');
            }
            else {
                return _polyfillHostNoCombinator + m[3];
            }
        });
    }
    _colonHostContextPartReplacer(host, part, suffix) {
        if (part.indexOf(_polyfillHost) > -1) {
            return this._colonHostPartReplacer(host, part, suffix);
        }
        else {
            return host + part + suffix + ', ' + part + ' ' + host + suffix;
        }
    }
    _colonHostPartReplacer(host, part, suffix) {
        return host + part.replace(_polyfillHost, '') + suffix;
    }
    /*
     * Convert combinators like ::shadow and pseudo-elements like ::content
     * by replacing with space.
    */
    _convertShadowDOMSelectors(cssText) {
        return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
    }
    // change a selector like 'div' to 'name div'
    _scopeSelectors(cssText, scopeSelector, hostSelector, slotSelector) {
        return processRules(cssText, (rule) => {
            let selector = rule.selector;
            let content = rule.content;
            if (rule.selector[0] !== '@') {
                selector =
                    this._scopeSelector(rule.selector, scopeSelector, hostSelector, slotSelector, this.strictStyling);
            }
            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
                content = this._scopeSelectors(rule.content, scopeSelector, hostSelector, slotSelector);
            }
            return new CssRule(selector, content);
        });
    }
    _scopeSelector(selector, scopeSelector, hostSelector, slotSelector, strict) {
        return selector.split(',')
            .map(part => part.trim().split(_shadowDeepSelectors))
            .map((deepParts) => {
            const [shallowPart, ...otherParts] = deepParts;
            const applyScope = (shallowPart) => {
                if (shallowPart.indexOf('[' + slotSelector + ']') > -1) {
                    return shallowPart;
                }
                if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
                    return strict ?
                        this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
                        this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
                }
                else {
                    return shallowPart;
                }
            };
            return [applyScope(shallowPart), ...otherParts].join(' ');
        })
            .join(', ');
    }
    _selectorNeedsScoping(selector, scopeSelector) {
        const re = this._makeScopeMatcher(scopeSelector);
        return !re.test(selector);
    }
    _makeScopeMatcher(scopeSelector) {
        const lre = /\[/g;
        const rre = /\]/g;
        scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
    }
    _applySelectorScope(selector, scopeSelector, hostSelector) {
        // Difference from webcomponents.js: scopeSelector could not be an array
        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    }
    // scope via name and [is=name]
    _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
        _polyfillHostRe.lastIndex = 0;
        if (_polyfillHostRe.test(selector)) {
            const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;
            return selector
                .replace(_polyfillHostNoCombinatorRe, (_, selector) => {
                return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
                    return before + replaceBy + colon + after;
                });
            })
                .replace(_polyfillHostRe, replaceBy + ' ');
        }
        return scopeSelector + ' ' + selector;
    }
    // return a selector with [name] suffix on each simple selector
    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
    _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
        const isRe = /\[is=([^\]]*)\]/g;
        scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
        const attrName = '[' + scopeSelector + ']';
        const _scopeSelectorPart = (p) => {
            let scopedP = p.trim();
            if (!scopedP) {
                return '';
            }
            if (p.indexOf(_polyfillHostNoCombinator) > -1) {
                scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
            }
            else {
                // remove :host since it should be unnecessary
                const t = p.replace(_polyfillHostRe, '');
                if (t.length > 0) {
                    const matches = t.match(/([^:]*)(:*)(.*)/);
                    if (matches) {
                        scopedP = matches[1] + attrName + matches[2] + matches[3];
                    }
                }
            }
            return scopedP;
        };
        const safeContent = new SafeSelector(selector);
        selector = safeContent.content();
        let scopedSelector = '';
        let startIndex = 0;
        let res;
        const sep = /( |>|\+|~(?!=))\s*/g;
        const scopeAfter = selector.indexOf(_polyfillHostNoCombinator);
        while ((res = sep.exec(selector)) !== null) {
            const separator = res[1];
            const part = selector.slice(startIndex, res.index).trim();
            // if a selector appears before :host-context it should not be shimmed as it
            // matches on ancestor elements and not on elements in the host's shadow
            const scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;
            scopedSelector += `${scopedPart} ${separator} `;
            startIndex = sep.lastIndex;
        }
        scopedSelector += _scopeSelectorPart(selector.substring(startIndex));
        // replace the placeholders with their original values
        return safeContent.restore(scopedSelector);
    }
    _insertPolyfillHostInCssText(selector) {
        return selector
            .replace(_colonHostContextRe, _polyfillHostContext)
            .replace(_colonHostRe, _polyfillHost)
            .replace(_colonSlottedRe, _polyfillSlotted);
    }
}
class SafeSelector {
    constructor(selector) {
        this.placeholders = [];
        this.index = 0;
        // Replaces attribute selectors with placeholders.
        // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
        selector = selector.replace(/(\[[^\]]*\])/g, (_, keep) => {
            const replaceBy = `__ph-${this.index}__`;
            this.placeholders.push(keep);
            this.index++;
            return replaceBy;
        });
        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
        // WS and "+" would otherwise be interpreted as selector separators.
        this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
            const replaceBy = `__ph-${this.index}__`;
            this.placeholders.push(exp);
            this.index++;
            return pseudo + replaceBy;
        });
    }
    restore(content) {
        return content.replace(/__ph-(\d+)__/g, (_, index) => this.placeholders[+index]);
    }
    content() { return this._content; }
}
const _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
const _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
const _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
const _polyfillHost = '-shadowcsshost';
const _polyfillSlotted = '-shadowcssslotted';
// note: :host-context pre-processed to -shadowcsshostcontext.
const _polyfillHostContext = '-shadowcsscontext';
const _parenSuffix = ')(?:\\((' +
    '(?:\\([^)(]*\\)|[^)(]*)+?' +
    ')\\))?([^,{]*)';
const _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
const _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
const _cssColonSlottedRe = new RegExp('(' + _polyfillSlotted + _parenSuffix, 'gim');
const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
const _shadowDOMSelectorsRe = [
    /::shadow/g,
    /::content/g,
    // Deprecated selectors
    /\/shadow-deep\//g,
    /\/shadow\//g,
];
// The deep combinator is deprecated in the CSS spec
// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.
// see https://github.com/angular/angular/pull/17677
const _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
const _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
const _polyfillHostRe = /-shadowcsshost/gim;
const _colonHostRe = /:host/gim;
const _colonSlottedRe = /::slotted/gim;
const _colonHostContextRe = /:host-context/gim;
const _commentRe = /\/\*\s*[\s\S]*?\*\//g;
function stripComments(input) {
    return input.replace(_commentRe, '');
}
// all comments except inline source mapping
const _sourceMappingUrlRe = /\/\*\s*#\s*sourceMappingURL=[\s\S]+?\*\//;
function extractSourceMappingUrl(input) {
    const matcher = input.match(_sourceMappingUrlRe);
    return matcher ? matcher[0] : '';
}
const _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
const _curlyRe = /([{}])/g;
const OPEN_CURLY = '{';
const CLOSE_CURLY = '}';
const BLOCK_PLACEHOLDER = '%BLOCK%';
class CssRule {
    constructor(selector, content) {
        this.selector = selector;
        this.content = content;
    }
}
function processRules(input, ruleCallback) {
    const inputWithEscapedBlocks = escapeBlocks(input);
    let nextBlockIndex = 0;
    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function (...m) {
        const selector = m[2];
        let content = '';
        let suffix = m[4];
        let contentPrefix = '';
        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
            contentPrefix = '{';
        }
        const rule = ruleCallback(new CssRule(selector, content));
        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
    });
}
class StringWithEscapedBlocks {
    constructor(escapedString, blocks) {
        this.escapedString = escapedString;
        this.blocks = blocks;
    }
}
function escapeBlocks(input) {
    const inputParts = input.split(_curlyRe);
    const resultParts = [];
    const escapedBlocks = [];
    let bracketCount = 0;
    let currentBlockParts = [];
    for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {
        const part = inputParts[partIndex];
        if (part === CLOSE_CURLY) {
            bracketCount--;
        }
        if (bracketCount > 0) {
            currentBlockParts.push(part);
        }
        else {
            if (currentBlockParts.length > 0) {
                escapedBlocks.push(currentBlockParts.join(''));
                resultParts.push(BLOCK_PLACEHOLDER);
                currentBlockParts = [];
            }
            resultParts.push(part);
        }
        if (part === OPEN_CURLY) {
            bracketCount++;
        }
    }
    if (currentBlockParts.length > 0) {
        escapedBlocks.push(currentBlockParts.join(''));
        resultParts.push(BLOCK_PLACEHOLDER);
    }
    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
}

function scopeComponentCss(ctx, cmpMeta, cssText) {
    try {
        const scopeAttribute = getScopeAttribute(cmpMeta);
        const hostScopeAttr = getHostScopeAttribute(cmpMeta);
        const slotScopeAttr = getSlotScopeAttribute(cmpMeta);
        cssText = scopeCss(cssText, scopeAttribute, hostScopeAttr, slotScopeAttr);
    }
    catch (e) {
        catchError(ctx.diagnostics, e);
    }
    return cssText;
}
function scopeCss(cssText, scopeAttribute, hostScopeAttr, slotScopeAttr) {
    const sc = new ShadowCss();
    return sc.shimCssText(cssText, scopeAttribute, hostScopeAttr, slotScopeAttr);
}
function getScopeAttribute(cmpMeta) {
    return `data-${cmpMeta.tagNameMeta}`;
}
function getHostScopeAttribute(cmpMeta) {
    return `data-${cmpMeta.tagNameMeta}-host`;
}
function getSlotScopeAttribute(cmpMeta) {
    return `data-${cmpMeta.tagNameMeta}-slot`;
}

function generateComponentStyles(config, ctx, moduleFile) {
    const modes = Object.keys(moduleFile.cmpMeta.stylesMeta);
    const promises = modes.map(modeName => {
        return generateComponentModeStyles(config, ctx, moduleFile, modeName);
    });
    return Promise.all(promises).then(componentModeStyles => {
        if (componentModeStyles.some(c => c.writeFile)) {
            ctx.styleBundleCount++;
        }
        return componentModeStyles;
    });
}
function generateComponentModeStyles(config, ctx, moduleFile, modeName) {
    return generateAllComponentModeStyles(config, ctx, moduleFile, modeName).then(allCmpStyleDetails => {
        const compiledModeStyles = groupComponentModeStyles(moduleFile.cmpMeta.tagNameMeta, modeName, allCmpStyleDetails);
        setHydratedCss(config, moduleFile.cmpMeta, compiledModeStyles);
        return compiledModeStyles;
    });
}
function generateAllComponentModeStyles(config, ctx, moduleFile, modeName) {
    const modeStyleMeta = moduleFile.cmpMeta.stylesMeta[modeName];
    const promises = [];
    if (modeStyleMeta) {
        // used to remember the exact order the user wants
        // sass render and file reads are async so it could mess with the order
        let styleOrder = 0;
        if (modeStyleMeta.absolutePaths) {
            modeStyleMeta.absolutePaths.forEach(absStylePath => {
                styleOrder++;
                absStylePath = normalizePath(absStylePath);
                if (isSassFile(absStylePath)) {
                    // sass file needs to be compiled
                    promises.push(compileSassFile(config, ctx, moduleFile, absStylePath, styleOrder));
                }
                else if (isCssFile(absStylePath)) {
                    // plain ol' css file
                    promises.push(readCssFile(config, ctx, moduleFile.cmpMeta, absStylePath, styleOrder));
                }
                else {
                    // idk
                    const d = buildError(ctx.diagnostics);
                    d.messageText = `style url "${absStylePath}", in component "${moduleFile.cmpMeta.tagNameMeta}", is not a supported file type`;
                }
            });
        }
        if (typeof modeStyleMeta.styleStr === 'string') {
            // plain styles as a string
            promises.push(readInlineStyles(config, ctx, moduleFile.cmpMeta, modeStyleMeta.styleStr, styleOrder));
        }
    }
    return Promise.all(promises);
}
function groupComponentModeStyles(tag, modeName, allCmpStyleDetails) {
    const compiledModeStyles = {
        tag: tag,
        modeName: modeName,
        writeFile: allCmpStyleDetails.some(c => c.writeFile)
    };
    if (allCmpStyleDetails.length === 0) {
        return compiledModeStyles;
    }
    allCmpStyleDetails = allCmpStyleDetails.sort((a, b) => {
        if (a.styleOrder < b.styleOrder)
            return -1;
        if (a.styleOrder > b.styleOrder)
            return 1;
        return 0;
    });
    // create the unscoped css by combining
    // all of the styles this component should use
    compiledModeStyles.unscopedStyles = joinCmpStyleDetails(allCmpStyleDetails.map(s => s.unscopedStyles || ''));
    // group all scoped css
    compiledModeStyles.scopedStyles = joinCmpStyleDetails(allCmpStyleDetails.map(s => s.scopedStyles || ''));
    return compiledModeStyles;
}
function joinCmpStyleDetails(styles) {
    let content = styles.join('\n\n').trim();
    content = content.replace(/\@/g, `\\@`);
    return content;
}
function setHydratedCss(config, cmpMeta, compiledModeStyles) {
    const tagSelector = `${cmpMeta.tagNameMeta}.${config.hydratedCssClass}`;
    if (cmpMeta.encapsulation === 1 /* ShadowDom */) {
        const hostSelector = `:host(.${config.hydratedCssClass})`;
        compiledModeStyles.unscopedStyles = appendHydratedCss(compiledModeStyles.unscopedStyles, hostSelector, true);
    }
    else {
        compiledModeStyles.unscopedStyles = appendHydratedCss(compiledModeStyles.unscopedStyles, tagSelector);
    }
    if (cmpMeta.encapsulation === 1 /* ShadowDom */ || cmpMeta.encapsulation === 2 /* ScopedCss */) {
        compiledModeStyles.scopedStyles = appendHydratedCss(compiledModeStyles.scopedStyles, tagSelector);
    }
}
function appendHydratedCss(styles, selector, important) {
    return `${styles || ''}\n${selector}{visibility:inherit${important ? ' !important' : ''}}`;
}
function compileSassFile(config, ctx, moduleFile, absStylePath, styleOrder) {
    const compileSassDetails = {
        styleOrder: styleOrder,
        writeFile: false
    };
    if (ctx.isChangeBuild && !ctx.changeHasSass) {
        // if this is a change build, but there wasn't specifically a sass file change
        // however we may still need to build sass if its typescript module changed
        // loop through all the changed typescript filename and see if there are corresponding js filenames
        // if there are no filenames that match then let's not run sass
        // yes...there could be two files that have the same filename in different directories
        // but worst case scenario is that both of them run sass, which isn't a performance problem
        const distFileName = config.sys.path.basename(moduleFile.jsFilePath, '.js');
        const hasChangedFileName = ctx.changedFiles.some(f => {
            const changedFileName = config.sys.path.basename(f);
            return (changedFileName === distFileName + '.ts' || changedFileName === distFileName + '.tsx');
        });
        if (!hasChangedFileName && ctx.styleSassUnscopedOutputs[absStylePath]) {
            // don't bother running sass on this, none of the changed files have the same filename
            // use the cached version
            compileSassDetails.unscopedStyles = ctx.styleSassUnscopedOutputs[absStylePath];
            compileSassDetails.scopedStyles = ctx.styleSassScopedOutputs[absStylePath];
            return Promise.resolve(compileSassDetails);
        }
    }
    return new Promise(resolve => {
        const sassConfig = Object.assign({}, config.sassConfig, { file: absStylePath, outputStyle: config.minifyCss ? 'compressed' : 'expanded' });
        config.sys.sass.render(sassConfig, (err, result) => {
            if (err) {
                const d = buildError(ctx.diagnostics);
                d.absFilePath = absStylePath;
                d.messageText = err;
            }
            else {
                fillStyleText(config, ctx, moduleFile.cmpMeta, compileSassDetails, result.css.toString());
                compileSassDetails.writeFile = true;
                ctx.sassBuildCount++;
                // cache for later
                ctx.styleSassUnscopedOutputs[absStylePath] = compileSassDetails.unscopedStyles;
                ctx.styleSassScopedOutputs[absStylePath] = compileSassDetails.scopedStyles;
            }
            resolve(compileSassDetails);
        });
    });
}
function readCssFile(config, ctx, cmpMeta, absStylePath, styleOrder) {
    const readCssDetails = {
        styleOrder: styleOrder,
        writeFile: false
    };
    if (ctx.isChangeBuild && !ctx.changeHasCss) {
        // if this is a change build, but there were no sass changes then don't bother
        readCssDetails.unscopedStyles = ctx.styleCssUnscopedOutputs[absStylePath];
        readCssDetails.scopedStyles = ctx.styleCssScopedOutputs[absStylePath];
        return Promise.resolve(readCssDetails);
    }
    // this is just a plain css file
    // only open it up for its content
    const sys = config.sys;
    return readFile(sys, absStylePath).then(cssText => {
        fillStyleText(config, ctx, cmpMeta, readCssDetails, cssText.toString());
        readCssDetails.writeFile = true;
        // cache for later
        ctx.styleCssUnscopedOutputs[absStylePath] = readCssDetails.unscopedStyles;
        ctx.styleCssScopedOutputs[absStylePath] = readCssDetails.scopedStyles;
    }).catch(err => {
        const d = buildError(ctx.diagnostics);
        d.messageText = `Error opening CSS file. ${err}`;
        d.absFilePath = absStylePath;
    }).then(() => {
        return readCssDetails;
    });
}
function readInlineStyles(config, ctx, cmpMeta, styleStr, styleOrder) {
    const inlineStylesDetail = {
        styleOrder: styleOrder
    };
    fillStyleText(config, ctx, cmpMeta, inlineStylesDetail, styleStr);
    return Promise.resolve(inlineStylesDetail);
}
function fillStyleText(config, ctx, cmpMeta, compiledModeStyles, unscopedStyles) {
    compiledModeStyles.unscopedStyles = null;
    compiledModeStyles.scopedStyles = null;
    if (typeof unscopedStyles === 'string') {
        compiledModeStyles.unscopedStyles = unscopedStyles.trim();
        if (config.minifyCss) {
            // minify css
            const minifyCssResults = config.sys.minifyCss(compiledModeStyles.unscopedStyles);
            minifyCssResults.diagnostics.forEach(d => {
                ctx.diagnostics.push(d);
            });
            if (minifyCssResults.output) {
                compiledModeStyles.unscopedStyles = minifyCssResults.output;
            }
        }
        if (cmpMeta.encapsulation === 2 /* ScopedCss */ || cmpMeta.encapsulation === 1 /* ShadowDom */) {
            // only create scoped styles if we need to
            compiledModeStyles.scopedStyles = scopeComponentCss(ctx, cmpMeta, unscopedStyles);
        }
    }
}

function bundleStyles(config, ctx, manifestBundles) {
    // create main style results object
    if (hasError(ctx.diagnostics)) {
        return Promise.resolve();
    }
    // do bundling if this is not a change build
    // or it's a change build that has either changed sass or css
    const doBundling = (!ctx.isChangeBuild || ctx.changeHasCss || ctx.changeHasSass);
    const timeSpan = config.logger.createTimeSpan(`bundle styles started`, !doBundling);
    // go through each bundle the user wants created
    // and create css files for each mode for each bundle
    return Promise.all(manifestBundles.map(manifestBundle => {
        return generateBundleComponentStyles(config, ctx, manifestBundle);
    }))
        .catch(err => {
        catchError(ctx.diagnostics, err);
    })
        .then(() => {
        timeSpan.finish('bundle styles finished');
    });
}
function generateBundleComponentStyles(config, ctx, manifestBundle) {
    const moduleFilesWithStyles = getModuleFilesWithStyles(manifestBundle.moduleFiles);
    const promises = moduleFilesWithStyles.map(moduleFile => {
        return generateComponentStyles(config, ctx, moduleFile).then(compiledModeStyles => {
            manifestBundle.compiledModeStyles.push(...compiledModeStyles);
        });
    });
    return Promise.all(promises);
}
function getModuleFilesWithStyles(allModuleFiles) {
    return allModuleFiles
        .filter(m => m.cmpMeta && m.cmpMeta.stylesMeta && Object.keys(m.cmpMeta.stylesMeta).length)
        .sort((a, b) => {
        if (a.cmpMeta.tagNameMeta < b.cmpMeta.tagNameMeta)
            return -1;
        if (a.cmpMeta.tagNameMeta > b.cmpMeta.tagNameMeta)
            return 1;
        return 0;
    });
}

function formatComponentLoader(cmpMeta) {
    const d = [
        cmpMeta.tagNameMeta,
        formatBundleIds(cmpMeta.bundleIds),
        formatHasStyles(cmpMeta.stylesMeta),
        formatProps(cmpMeta.membersMeta),
        formatEncapsulation(cmpMeta.encapsulation),
        formatSlot(cmpMeta.slotMeta),
        formatListeners(cmpMeta.listenersMeta),
        cmpMeta.loadPriority
    ];
    return trimFalsyData(d);
}
function formatBundleIds(bundleIds) {
    if (!bundleIds) {
        return 'invalid-bundle-id';
    }
    if (typeof bundleIds === 'string') {
        return bundleIds;
    }
    const modes = Object.keys(bundleIds).sort();
    if (!modes.length) {
        return 'invalid-bundle-id';
    }
    if (modes.length === 1) {
        return [
            bundleIds[modes[0]].es2015,
            bundleIds[modes[0]].es5
        ];
    }
    const bundleIdObj = {};
    modes.forEach(modeName => {
        bundleIdObj[modeName] = [
            bundleIds[modeName].es2015,
            bundleIds[modeName].es5
        ];
    });
    return bundleIdObj;
}
function formatHasStyles(stylesMeta) {
    if (stylesMeta && Object.keys(stylesMeta).length > 0) {
        return 1;
    }
    return 0;
}
function formatSlot(val) {
    if (val === 1 /* HasSlots */) {
        return 1 /* HasSlots */;
    }
    if (val === 2 /* HasNamedSlots */) {
        return 2 /* HasNamedSlots */;
    }
    return 0 /* NoSlots */;
}
function formatProps(membersMeta) {
    if (!membersMeta) {
        return 0;
    }
    const observeAttrs = [];
    const memberNames = Object.keys(membersMeta).sort();
    memberNames.forEach(memberName => {
        const memberMeta = membersMeta[memberName];
        const d = [
            memberName,
            memberMeta.memberType
        ];
        if (typeof memberMeta.attribName === 'string') {
            // observe the attribute
            d.push(1);
        }
        else {
            // do not observe the attribute
            d.push(0);
        }
        if (memberMeta.propType === 3 /* Boolean */ || memberMeta.propType === 4 /* Number */ || memberMeta.propType === 2 /* String */ || memberMeta.propType === 1 /* Any */) {
            d.push(memberMeta.propType);
        }
        else {
            d.push(0 /* Unknown */);
        }
        if (memberMeta.ctrlId) {
            d.push(memberMeta.ctrlId);
        }
        observeAttrs.push(d);
    });
    if (!observeAttrs.length) {
        return 0;
    }
    return observeAttrs.map(p => {
        return trimFalsyData(p);
    });
}
function formatListeners(listeners) {
    if (!listeners || !listeners.length) {
        return 0;
    }
    return listeners.map(listener => {
        const d = [
            listener.eventName,
            listener.eventMethodName,
            listener.eventDisabled ? 1 : 0,
            listener.eventPassive ? 1 : 0,
            listener.eventCapture ? 1 : 0
        ];
        return trimFalsyData(d);
    });
}
function formatComponentRegistry(registry) {
    // ensure we've got a standard order of the components
    return Object.keys(registry).sort().map(tag => {
        if (registry[tag]) {
            return formatComponentLoader(registry[tag]);
        }
        return null;
    }).filter(c => c);
}
function formatLoadComponents(namespace, moduleId, moduleBundleOutput, moduleFiles) {
    // ensure we've got a standard order of the components
    moduleFiles = moduleFiles.sort((a, b) => {
        if (a.cmpMeta.tagNameMeta < b.cmpMeta.tagNameMeta)
            return -1;
        if (a.cmpMeta.tagNameMeta > b.cmpMeta.tagNameMeta)
            return 1;
        return 0;
    });
    const componentMetaStr = moduleFiles.map(moduleFile => {
        return formatComponentMeta(moduleFile.cmpMeta);
    }).join(',\n');
    // wrap our component code with our own iife
    moduleBundleOutput = wrapComponentImports(moduleBundleOutput);
    return [
        `${getWindowNamespace(namespace)}.loadComponents(\n`,
        `/**** module id (dev mode) ****/`,
        `"${moduleId}",\n`,
        `/**** component modules ****/`,
        `${moduleBundleOutput},\n`,
        `${componentMetaStr}`,
        `);`
    ].join('\n');
}
function formatLoadStyles(namespace, bundleStyles, scoped) {
    const args = [];
    bundleStyles = bundleStyles.sort((a, b) => {
        if (a.tag < b.tag)
            return -1;
        if (a.tag > b.tag)
            return 1;
        return 0;
    });
    bundleStyles.forEach(bundleStyle => {
        const styles = (scoped ? bundleStyle.scopedStyles : bundleStyle.unscopedStyles).replace(/\n/g, `\\n`).replace(/\"/g, `\\"`).trim();
        if (styles.length > 0) {
            // arg EVEN
            let styleId = bundleStyle.tag;
            if (bundleStyle.modeName !== DEFAULT_STYLE_MODE) {
                styleId += '_' + bundleStyle.modeName;
            }
            args.push(styleId);
            // arg ODD
            args.push(styles);
        }
    });
    if (args.length < 2) {
        return '';
    }
    return `${getWindowNamespace(namespace)}.loadStyles("${args.join(`","`)}");`;
}
function getWindowNamespace(namespace) {
    if (namespace.includes('-')) {
        return `window['${namespace}']`;
    }
    return namespace;
}
function formatComponentMeta(cmpMeta) {
    const tag = cmpMeta.tagNameMeta.toLowerCase();
    const members = formatMembers(cmpMeta.membersMeta);
    const host = formatHost(cmpMeta.hostMeta);
    const propWillChanges = formatPropChanges(tag, 'prop will change', cmpMeta.propsWillChangeMeta);
    const propDidChanges = formatPropChanges(tag, 'prop did change', cmpMeta.propsDidChangeMeta);
    const events = formatEvents(tag, cmpMeta.eventsMeta);
    const d = [];
    d.push(`/** ${tag}: tag **/\n"${tag}"`);
    d.push(`/** ${tag}: members **/\n${members}`);
    d.push(`/** ${tag}: host **/\n${host}`);
    d.push(`/** ${tag}: events **/\n${events}`);
    d.push(`/** ${tag}: propWillChanges **/\n${propWillChanges}`);
    d.push(`/** ${tag}: propDidChanges **/\n${propDidChanges}`);
    return `\n/***************** ${tag} *****************/\n[\n` + trimFalsyDataStr(d).join(',\n\n') + `\n\n]`;
}
function formatMembers(membersMeta) {
    if (!membersMeta) {
        return '0 /* no members */';
    }
    const memberNames = Object.keys(membersMeta).sort((a, b) => {
        if (a.toLowerCase() < b.toLowerCase())
            return -1;
        if (a.toLowerCase() > b.toLowerCase())
            return 1;
        return 0;
    });
    if (!memberNames.length) {
        return '0 /* no members */';
    }
    const members = memberNames.map(memberName => {
        return formatMemberMeta(memberName, membersMeta[memberName]);
    });
    return `[${members}\n]`;
}
function formatMemberMeta(memberName, memberMeta) {
    const d = [];
    d.push(`"${memberName}"`);
    d.push(formatMemberType(memberMeta.memberType));
    if (typeof memberMeta.attribName === 'string') {
        // observe the attribute
        d.push('/** observe attribute **/ 1');
    }
    else {
        // do not observe the attribute
        d.push('/** do not observe attribute **/ 0');
    }
    d.push(formatPropType(memberMeta.propType));
    d.push(formatPropContext(memberMeta.ctrlId));
    return '\n  [ ' + trimFalsyDataStr(d).join(', ') + ' ]';
}
function formatMemberType(val) {
    if (val === 7 /* Element */) {
        return `/** element ref **/ ${7 /* Element */}`;
    }
    if (val === 6 /* Method */) {
        return `/** method **/ ${6 /* Method */}`;
    }
    if (val === 1 /* Prop */) {
        return `/** prop **/ ${1 /* Prop */}`;
    }
    if (val === 2 /* PropMutable */) {
        return `/** prop mutable **/ ${2 /* PropMutable */}`;
    }
    if (val === 5 /* State */) {
        return `/** state **/ ${5 /* State */}`;
    }
    if (val === 4 /* PropConnect */) {
        return `/** prop connect **/ ${4 /* PropConnect */}`;
    }
    if (val === 3 /* PropContext */) {
        return `/** prop context **/ ${3 /* PropContext */}`;
    }
    return `/** unknown ****/ 0`;
}
function formatPropType(val) {
    if (val === 2 /* String */) {
        return `/** type string **/ ${2 /* String */}`;
    }
    if (val === 3 /* Boolean */) {
        return `/** type boolean **/ ${3 /* Boolean */}`;
    }
    if (val === 4 /* Number */) {
        return `/** type number **/ ${4 /* Number */}`;
    }
    return `/** type any **/ ${1 /* Any */}`;
}
function formatPropContext(val) {
    if (val === undefined) {
        return `0`;
    }
    return `/** context ***/ "${val}"`;
}
function formatHost(val) {
    if (val === undefined) {
        return '0 /* no host data */';
    }
    return JSON.stringify(val);
}
function formatBoolean(val) {
    return val ?
        '1 /* true **/' :
        '0 /* false */';
}
function formatPropChanges(label, propChangeType, propChange) {
    if (!propChange || !propChange.length) {
        return `0 /* no ${propChangeType} methods */`;
    }
    const t = [];
    propChange.forEach((propChange, index) => {
        t.push(formatPropChangeOpts(label, propChangeType, propChange, index));
    });
    return `[\n` + t.join(',\n') + `\n]`;
}
function formatPropChangeOpts(label, propChangeType, propChange, index) {
    const t = [
        `    /*****  ${label} ${propChangeType} [${index}] ***** /\n` +
            `    /* prop name **/ "${propChange[0]}"`,
        `    /* call fn *****/ "${propChange[1]}"`
    ];
    return `  [\n` + t.join(',\n') + `\n  ]`;
}
function formatEvents(label, events) {
    if (!events || !events.length) {
        return '0 /* no events */';
    }
    const t = [];
    events.forEach(eventMeta => {
        t.push(formatEventOpts(label, eventMeta));
    });
    return `[\n` + t.join(',\n') + `\n]`;
}
function formatEventOpts(label, eventMeta) {
    const t = [
        `    /*****  ${label} ${eventMeta.eventName} ***** /\n` +
            `    /* event name ***/ "${eventMeta.eventName}"`,
        `    /* method name **/ ${eventMeta.eventMethodName !== eventMeta.eventName ? '"' + eventMeta.eventMethodName + '"' : 0}`,
        `    /* disable bubbles **/ ${formatBoolean(!eventMeta.eventBubbles)}`,
        `    /* disable cancelable **/ ${formatBoolean(!eventMeta.eventCancelable)}`,
        `    /* disable composed **/ ${formatBoolean(!eventMeta.eventComposed)}`
    ];
    return `  [\n` + trimFalsyDataStr(t).join(',\n') + `\n  ]`;
}
function formatEncapsulation(val) {
    if (val === 1 /* ShadowDom */) {
        return 1 /* ShadowDom */;
    }
    if (val === 2 /* ScopedCss */) {
        return 2 /* ScopedCss */;
    }
    return 0 /* NoEncapsulation */;
}
function trimFalsyData(d) {
    for (var i = d.length - 1; i >= 0; i--) {
        if (d[i]) {
            break;
        }
        // if falsy, safe to pop()
        d.pop();
    }
    return d;
}
function trimFalsyDataStr(d) {
    const arrData = new Function(`return [${d.join(',').replace(/\n/gm, '')}]`)();
    for (var i = arrData.length - 1; i >= 0; i--) {
        if (arrData[i]) {
            break;
        }
        // if falsy, safe to pop()
        d.pop();
    }
    return d;
}

function getAppFileName(config) {
    return config.namespace.toLowerCase();
}
function getAppWWWBuildDir(config) {
    const appFileName = getAppFileName(config);
    return pathJoin(config, config.buildDir, appFileName);
}
function getAppDistDir(config) {
    const appFileName = getAppFileName(config);
    return pathJoin(config, config.distDir, appFileName);
}
function getRegistryJsonWWW(config) {
    const appFileName = getAppFileName(config);
    return pathJoin(config, getAppWWWBuildDir(config), `${appFileName}.registry.json`);
}
function getRegistryJsonDist(config) {
    const appFileName = getAppFileName(config);
    return pathJoin(config, config.distDir, `${appFileName}.registry.json`);
}
function getLoaderFileName(config) {
    const appFileName = getAppFileName(config);
    return `${appFileName}.js`;
}
function getGlobalFileName(config) {
    const appFileName = getAppFileName(config);
    return `${appFileName}.${GLOBAL_NAME}.js`;
}
function getGlobalWWW(config) {
    return pathJoin(config, getAppWWWBuildDir(config), getGlobalFileName(config));
}
function getGlobalDist(config) {
    return pathJoin(config, getAppDistDir(config), getGlobalFileName(config));
}
function getCoreFilename(config, coreId, jsContent) {
    const appFileName = getAppFileName(config);
    if (config.hashFileNames) {
        // prod mode renames the core file with its hashed content
        const contentHash = config.sys.generateContentHash(jsContent, config.hashedFileNameLength);
        return `${appFileName}.${contentHash}.js`;
    }
    // dev file name
    return `${appFileName}.${coreId}.js`;
}
function getBundleFileName(bundleId, scoped) {
    return `${bundleId}${scoped ? '.sc' : ''}.js`;
}
function getAppPublicPath(config) {
    return pathJoin(config, config.publicPath, getAppFileName(config)) + '/';
}

function buildConditionalsTransform(coreBuild) {
    return (transformContext) => {
        function visitPropertyAccessExpression(node) {
            let variableName = node.getText();
            if (!variableName.startsWith('Build.')) {
                return node;
            }
            variableName = variableName.split('.')[1];
            if (!variableName) {
                return node;
            }
            if (coreBuild[variableName]) {
                return ts.createTrue();
            }
            return ts.createFalse();
        }
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.PropertyAccessExpression:
                    return visitPropertyAccessExpression(node);
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(node);
                    }, transformContext);
            }
        }
        return (tsSourceFile) => {
            return visit(tsSourceFile);
        };
    };
}

/**
 * Ok, so formatting overkill, we know. But whatever, it makes for great
 * error reporting within a terminal. So, yeah, let's code it up, shall we?
 */
function loadTypeScriptDiagnostics(rootDir, resultsDiagnostics, tsDiagnostics) {
    const maxErrors = Math.min(tsDiagnostics.length, MAX_ERRORS);
    for (var i = 0; i < maxErrors; i++) {
        resultsDiagnostics.push(loadDiagnostic(rootDir, tsDiagnostics[i]));
    }
}
function loadDiagnostic(rootDir, tsDiagnostic) {
    const d = {
        level: 'error',
        type: 'typescript',
        language: 'typescript',
        header: 'typescript error',
        code: tsDiagnostic.code.toString(),
        messageText: ts.flattenDiagnosticMessageText(tsDiagnostic.messageText, '\n'),
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    if (tsDiagnostic.file) {
        d.absFilePath = tsDiagnostic.file.fileName;
        d.relFilePath = formatFileName(rootDir, d.absFilePath);
        let sourceText = tsDiagnostic.file.getText();
        let srcLines = splitLineBreaks(sourceText);
        let htmlLines = srcLines;
        try {
            htmlLines = splitLineBreaks(highlight(d.language, sourceText, true).value);
        }
        catch (e) { }
        const posData = tsDiagnostic.file.getLineAndCharacterOfPosition(tsDiagnostic.start);
        const errorLine = {
            lineIndex: posData.line,
            lineNumber: posData.line + 1,
            text: srcLines[posData.line],
            html: htmlLines[posData.line],
            errorCharStart: posData.character,
            errorLength: Math.max(tsDiagnostic.length, 1)
        };
        if (errorLine.html && errorLine.html.indexOf('class="hljs') === -1) {
            try {
                errorLine.html = highlight(d.language, errorLine.text, true).value;
            }
            catch (e) { }
        }
        d.lines.push(errorLine);
        if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
            errorLine.errorLength = 1;
            errorLine.errorCharStart--;
        }
        d.header = formatHeader('typescript', tsDiagnostic.file.fileName, rootDir, errorLine.lineNumber);
        if (errorLine.lineIndex > 0) {
            const previousLine = {
                lineIndex: errorLine.lineIndex - 1,
                lineNumber: errorLine.lineNumber - 1,
                text: srcLines[errorLine.lineIndex - 1],
                html: htmlLines[errorLine.lineIndex - 1],
                errorCharStart: -1,
                errorLength: -1
            };
            if (previousLine.html && previousLine.html.indexOf('class="hljs') === -1) {
                try {
                    previousLine.html = highlight(d.language, previousLine.text, true).value;
                }
                catch (e) { }
            }
            d.lines.unshift(previousLine);
        }
        if (errorLine.lineIndex + 1 < srcLines.length) {
            const nextLine = {
                lineIndex: errorLine.lineIndex + 1,
                lineNumber: errorLine.lineNumber + 1,
                text: srcLines[errorLine.lineIndex + 1],
                html: htmlLines[errorLine.lineIndex + 1],
                errorCharStart: -1,
                errorLength: -1
            };
            if (nextLine.html && nextLine.html.indexOf('class="hljs') === -1) {
                try {
                    nextLine.html = highlight(d.language, nextLine.text, true).value;
                }
                catch (e) { }
            }
            d.lines.push(nextLine);
        }
    }
    return d;
}

function transpileCoreBuild(coreBuild, input) {
    const diagnostics = [];
    const results = {
        code: null,
        diagnostics: null
    };
    const transpileOpts = {
        compilerOptions: getCompilerOptions(coreBuild),
        transformers: {
            before: [
                buildConditionalsTransform(coreBuild)
            ]
        }
    };
    const tsResults = ts.transpileModule(input, transpileOpts);
    loadTypeScriptDiagnostics('', diagnostics, tsResults.diagnostics);
    if (diagnostics.length) {
        results.diagnostics = diagnostics;
        results.code = input;
        return results;
    }
    results.code = tsResults.outputText;
    return results;
}
function transpileToEs5(input) {
    const diagnostics = [];
    const results = {
        code: null,
        diagnostics: null
    };
    const transpileOpts = {
        compilerOptions: {
            allowJs: true,
            declaration: false,
            target: ts.ScriptTarget.ES5
        }
    };
    const tsResults = ts.transpileModule(input, transpileOpts);
    loadTypeScriptDiagnostics('', diagnostics, tsResults.diagnostics);
    if (diagnostics.length > 0) {
        results.diagnostics = diagnostics;
        results.code = input;
        return results;
    }
    results.code = tsResults.outputText;
    return results;
}
function getCompilerOptions(coreBuild) {
    const opts = {
        allowJs: true,
        declaration: false
    };
    if (coreBuild.es5) {
        opts.target = ts.ScriptTarget.ES5;
    }
    else {
        opts.target = ts.ScriptTarget.ES2015;
    }
    return opts;
}

function generateBundles(config, ctx, manifestBundles, sourceTarget) {
    const timeSpan = config.logger.createTimeSpan(`generate ${sourceTarget} bundles started`, config.devMode);
    manifestBundles.forEach(manifestBundle => {
        generateBundleFiles(config, ctx, manifestBundle, sourceTarget);
    });
    ctx.registry = generateComponentRegistry(manifestBundles);
    timeSpan.finish(`generate ${sourceTarget} bundles finished`);
    return manifestBundles;
}
function generateBundleFiles(config, ctx, manifestBundle, sourceTarget) {
    manifestBundle.moduleFiles.forEach(moduleFile => {
        moduleFile.cmpMeta.bundleIds = moduleFile.cmpMeta.bundleIds || {};
    });
    let compiledModuleText = manifestBundle.compiledModuleText;
    if (sourceTarget === 'es5') {
        const transpileResults = transpileToEs5(compiledModuleText);
        const transpileDiagnostics = transpileResults.diagnostics;
        if (transpileDiagnostics && transpileDiagnostics.length > 0) {
            ctx.diagnostics.push(...transpileResults.diagnostics);
        }
        if (hasError(transpileDiagnostics)) {
            return;
        }
        compiledModuleText = transpileResults.code;
    }
    let moduleText = formatLoadComponents(config.namespace, MODULE_ID, compiledModuleText, manifestBundle.moduleFiles);
    if (config.minifyJs) {
        // minify js
        const opts = { output: {}, compress: {}, mangle: {} };
        if (sourceTarget === 'es5') {
            opts.ecma = 5;
            opts.output.ecma = 5;
            opts.compress.ecma = 5;
            opts.compress.arrows = false;
        }
        if (config.logLevel === 'debug') {
            opts.mangle.keep_fnames = true;
            opts.compress.drop_console = false;
            opts.compress.drop_debugger = false;
            opts.output.beautify = true;
            opts.output.bracketize = true;
            opts.output.indent_level = 2;
            opts.output.comments = 'all';
            opts.output.preserve_line = true;
        }
        const minifyJsResults = config.sys.minifyJs(moduleText, opts);
        minifyJsResults.diagnostics.forEach(d => {
            ctx.diagnostics.push(d);
        });
        if (!minifyJsResults.diagnostics.length) {
            moduleText = minifyJsResults.output + ';';
        }
    }
    const modes = getManifestBundleModes(manifestBundle.moduleFiles);
    const hasDefaultMode = containsDefaultMode(modes);
    const hasNonDefaultModes = containsNonDefaultModes(modes);
    if (hasDefaultMode && hasNonDefaultModes) {
        modes.filter(m => m !== DEFAULT_STYLE_MODE).forEach(modeName => {
            const bundleStyles = manifestBundle.compiledModeStyles.filter(cms => cms.modeName === DEFAULT_STYLE_MODE);
            bundleStyles.push(...manifestBundle.compiledModeStyles.filter(cms => cms.modeName === modeName));
            writeBundleFile(config, ctx, manifestBundle, moduleText, modeName, bundleStyles, sourceTarget);
        });
    }
    else if (modes.length) {
        modes.forEach(modeName => {
            const bundleStyles = manifestBundle.compiledModeStyles.filter(cms => cms.modeName === modeName);
            writeBundleFile(config, ctx, manifestBundle, moduleText, modeName, bundleStyles, sourceTarget);
        });
    }
    else {
        writeBundleFile(config, ctx, manifestBundle, moduleText, null, [], sourceTarget);
    }
}
function writeBundleFile(config, ctx, manifestBundle, moduleText, modeName, bundleStyles, sourceTarget) {
    const unscopedStyleText = formatLoadStyles(config.namespace, bundleStyles, false);
    const unscopedContents = [
        generatePreamble(config, sourceTarget)
    ];
    if (unscopedStyleText.length) {
        unscopedContents.push(unscopedStyleText);
    }
    unscopedContents.push(moduleText);
    let unscopedContent = unscopedContents.join('\n');
    const bundleId = getBundleId(config, manifestBundle.moduleFiles.map(m => m.cmpMeta.tagNameMeta), modeName, unscopedContent);
    unscopedContent = replaceDefaulBundleId(unscopedContent, bundleId);
    const unscopedFileName = getBundleFileName(bundleId, false);
    setBundleModeIds(manifestBundle.moduleFiles, modeName, bundleId, sourceTarget);
    const unscopedWwwBuildPath = pathJoin(config, getAppWWWBuildDir(config), unscopedFileName);
    // use wwwFilePath as the cache key
    if (ctx.compiledFileCache[unscopedWwwBuildPath] === unscopedContent) {
        // unchanged, no need to resave
        return;
    }
    // cache for later
    ctx.compiledFileCache[unscopedWwwBuildPath] = unscopedContent;
    if (config.generateWWW) {
        // write the unscoped css to the www build
        ctx.filesToWrite[unscopedWwwBuildPath] = unscopedContent;
    }
    if (config.generateDistribution) {
        // write the unscoped css to the dist build
        const unscopedDistPath = pathJoin(config, config.distDir, getAppFileName(config), unscopedFileName);
        ctx.filesToWrite[unscopedDistPath] = unscopedContent;
    }
    if (modeName && bundleRequiresScopedStyles(manifestBundle.moduleFiles)) {
        const scopedStyleText = formatLoadStyles(config.namespace, bundleStyles, true);
        const scopedContents = [
            generatePreamble(config, sourceTarget)
        ];
        if (scopedStyleText.length) {
            scopedContents.push(scopedStyleText);
        }
        scopedContents.push(moduleText);
        const scopedFileContent = replaceDefaulBundleId(scopedContents.join('\n'), bundleId);
        const scopedFileName = getBundleFileName(bundleId, true);
        if (config.generateWWW) {
            // write the scoped css to the www build
            const scopedWwwPath = pathJoin(config, getAppWWWBuildDir(config), scopedFileName);
            ctx.filesToWrite[scopedWwwPath] = scopedFileContent;
        }
        if (config.generateDistribution) {
            // write the scoped css to the dist build
            const scopedDistPath = pathJoin(config, scopedFileName);
            ctx.filesToWrite[scopedDistPath] = scopedFileContent;
        }
    }
}
function setBundleModeIds(moduleFiles, modeName, bundleId, sourceTarget) {
    moduleFiles.forEach(moduleFile => {
        if (modeName) {
            moduleFile.cmpMeta.bundleIds[modeName] = moduleFile.cmpMeta.bundleIds[modeName] || {};
            if (sourceTarget === 'es5') {
                moduleFile.cmpMeta.bundleIds[modeName].es5 = bundleId;
            }
            else {
                moduleFile.cmpMeta.bundleIds[modeName].es2015 = bundleId;
            }
        }
        else {
            moduleFile.cmpMeta.bundleIds[DEFAULT_STYLE_MODE] = moduleFile.cmpMeta.bundleIds[DEFAULT_STYLE_MODE] || {};
            if (sourceTarget === 'es5') {
                moduleFile.cmpMeta.bundleIds[DEFAULT_STYLE_MODE].es5 = bundleId;
            }
            else {
                moduleFile.cmpMeta.bundleIds[DEFAULT_STYLE_MODE].es2015 = bundleId;
            }
        }
    });
}
function generateComponentRegistry(manifestBundles) {
    const registryComponents = [];
    const registry = {};
    manifestBundles.forEach(manifestBundle => {
        manifestBundle.moduleFiles.filter(m => m.cmpMeta).forEach(moduleFile => {
            registryComponents.push(moduleFile.cmpMeta);
        });
    });
    registryComponents.sort((a, b) => {
        if (a.tagNameMeta < b.tagNameMeta)
            return -1;
        if (a.tagNameMeta > b.tagNameMeta)
            return 1;
        return 0;
    }).forEach(cmpMeta => {
        registry[cmpMeta.tagNameMeta] = cmpMeta;
    });
    return registry;
}
function getBundleId(config, components, modeName, content) {
    if (config.hashFileNames) {
        // create style id from hashing the content
        return config.sys.generateContentHash(content, config.hashedFileNameLength);
    }
    if (modeName === DEFAULT_STYLE_MODE || !modeName) {
        return components[0];
    }
    return components[0] + '.' + modeName;
}
function getManifestBundleModes(moduleFiles) {
    const modes = [];
    moduleFiles.forEach(m => {
        if (m.cmpMeta && m.cmpMeta.stylesMeta) {
            Object.keys(m.cmpMeta.stylesMeta).forEach(modeName => {
                if (modes.indexOf(modeName) === -1) {
                    modes.push(modeName);
                }
            });
        }
    });
    return modes.sort();
}
function bundleRequiresScopedStyles(moduleFiles) {
    return moduleFiles
        .filter(m => m.cmpMeta && m.cmpMeta.stylesMeta)
        .some(m => componentRequiresScopedStyles(m.cmpMeta.encapsulation));
}
function containsDefaultMode(modes) {
    return modes.some(m => m === DEFAULT_STYLE_MODE);
}
function containsNonDefaultModes(modes) {
    return modes.length > 0 && modes.some(m => m !== DEFAULT_STYLE_MODE);
}
function replaceDefaulBundleId(fileContent, newModuleId) {
    return fileContent.replace(MODULE_ID_REGEX, newModuleId);
}
const MODULE_ID = '__STENCIL__MODULE__ID__';
const MODULE_ID_REGEX = new RegExp(MODULE_ID, 'g');

function bundle(config, ctx) {
    if (hasError(ctx.diagnostics)) {
        return Promise.resolve();
    }
    if (config.generateWWW) {
        config.logger.debug(`bundle, buildDir: ${config.buildDir}`);
    }
    if (config.generateDistribution) {
        config.logger.debug(`bundle, distDir: ${config.distDir}`);
    }
    ctx.manifestBundles = getManifestBundles(ctx.manifest.modulesFiles, ctx.manifest.bundles, ctx.diagnostics);
    ctx.manifestBundles = validateBundleModules(ctx.manifestBundles);
    ctx.manifestBundles = sortBundles(ctx.manifestBundles);
    // kick off style and module bundling at the same time
    return Promise.all([
        bundleStyles(config, ctx, ctx.manifestBundles),
        bundleModules(config, ctx, ctx.manifestBundles)
    ]).then(() => {
        // both styles and modules are done bundling
        // generate the actual files to write
        generateBundles(config, ctx, ctx.manifestBundles, 'es2015');
        if (config.es5Fallback) {
            generateBundles(config, ctx, ctx.manifestBundles, 'es5');
        }
    }).catch(err => {
        catchError(ctx.diagnostics, err);
    });
}
function getManifestBundles(moduleFiles, bundles, diagnostics) {
    const manifestBundles = [];
    bundles.filter(b => b.components && b.components.length).forEach(bundle => {
        const manifestBundle = createManifestBundle([], bundle.priority);
        bundle.components.forEach(tag => {
            const cmpMeta = moduleFiles.find(modulesFile => modulesFile.cmpMeta.tagNameMeta === tag);
            if (cmpMeta) {
                manifestBundle.moduleFiles.push(cmpMeta);
            }
            else {
                buildError(diagnostics).messageText = `Component tag "${tag}" is defined in a bundle but no matching component was found within this app or its collections.`;
            }
        });
        if (manifestBundle.moduleFiles.length > 0) {
            manifestBundles.push(manifestBundle);
        }
    });
    return manifestBundles;
}
function validateBundleModules(manifestBundles) {
    // can't mix and match different types of encapsulation in the same bundle
    const validatedBundles = [];
    manifestBundles.forEach(manifestBundle => {
        validateManifestBundle(validatedBundles, manifestBundle);
    });
    return validatedBundles;
}
function validateManifestBundle(validatedBundles, manifestBundle) {
    // ok, so this method is used to clean up the bundles to make sure that
    // all of the components in this bundle share the same encapsulation type
    // we could throw an error if the user mix and matches, but that's confusing
    // and they'd have to manually do what we're doing below. So let's just do it for them
    // so make sure each bundle has the same encapsulation type, and for those who
    // don't have the same type, then create new bundles which share the same type
    if (manifestBundle.moduleFiles.length === 0) {
        // no components, no bundle (not sure how this could happen, but whatever)
        return;
    }
    if (manifestBundle.moduleFiles.length === 1) {
        // only one component, so we couldn't have issues with
        // different encapsulation types in the bundle
        validatedBundles.push(manifestBundle);
        return;
    }
    // there are multiple components in this bundle
    // figure out which encapsulation type we see the most of in this bundle
    const primaryEncapsulation = findPrimaryEncapsulation(manifestBundle.moduleFiles);
    // used to collect all the same encapsulation type in this main bundle
    const primaryCss = [];
    // used to collect all the types that shouldn't be grouped in this module
    const scopedCss = [];
    const shadowCss = [];
    const plainCss = [];
    // pick out only
    manifestBundle.moduleFiles.forEach(moduleFile => {
        const cmpMeta = moduleFile.cmpMeta;
        if (cmpMeta.encapsulation === primaryEncapsulation || !cmpMeta.stylesMeta) {
            // this component uses the same encapsulation type as everyone else
            // or it doesn't have styles at all so it doesn't matter
            primaryCss.push(moduleFile);
        }
        else if (moduleFile.cmpMeta.encapsulation === 2 /* ScopedCss */) {
            scopedCss.push(moduleFile);
        }
        else if (moduleFile.cmpMeta.encapsulation === 1 /* ShadowDom */) {
            shadowCss.push(moduleFile);
        }
        else {
            plainCss.push(moduleFile);
        }
    });
    if (primaryCss.length) {
        manifestBundle.moduleFiles = primaryCss;
        validatedBundles.push(manifestBundle);
    }
    if (scopedCss.length) {
        validatedBundles.push(createManifestBundle(scopedCss, manifestBundle.priority));
    }
    if (shadowCss.length) {
        validatedBundles.push(createManifestBundle(shadowCss, manifestBundle.priority));
    }
    if (plainCss.length) {
        validatedBundles.push(createManifestBundle(plainCss, manifestBundle.priority));
    }
}
function findPrimaryEncapsulation(moduleFiles) {
    const plainCssCmps = moduleFiles.filter(m => m.cmpMeta.encapsulation !== 2 /* ScopedCss */ && m.cmpMeta.encapsulation !== 1 /* ShadowDom */);
    const scopedCssCmps = moduleFiles.filter(m => m.cmpMeta.encapsulation === 2 /* ScopedCss */);
    const shadowCssCmps = moduleFiles.filter(m => m.cmpMeta.encapsulation === 1 /* ShadowDom */);
    // figure out which encapsulation type we have the most of
    const sorted = [plainCssCmps, scopedCssCmps, shadowCssCmps].sort((a, b) => {
        if (a.length < b.length)
            return 1;
        if (a.length > b.length)
            return -1;
        return 0;
    });
    if (sorted.length && sorted[0].length) {
        return sorted[0][0].cmpMeta.encapsulation;
    }
    return null;
}
function createManifestBundle(moduleFiles, priority) {
    const manifestBundle = {
        moduleFiles: moduleFiles,
        compiledModeStyles: [],
        compiledModuleText: '',
        priority: priority
    };
    return manifestBundle;
}
function sortBundles(manifestBundles) {
    manifestBundles.forEach(m => {
        m.moduleFiles = m.moduleFiles.sort((a, b) => {
            if (a.cmpMeta.tagNameMeta < b.cmpMeta.tagNameMeta)
                return -1;
            if (a.cmpMeta.tagNameMeta > b.cmpMeta.tagNameMeta)
                return 1;
            return 0;
        });
    });
    return manifestBundles.sort((a, b) => {
        if (a.moduleFiles[0].cmpMeta.tagNameMeta < b.moduleFiles[0].cmpMeta.tagNameMeta)
            return -1;
        if (a.moduleFiles[0].cmpMeta.tagNameMeta > b.moduleFiles[0].cmpMeta.tagNameMeta)
            return 1;
        return 0;
    });
}

function getTsHost(config, ctx, tsCompilerOptions, transpileResults) {
    const tsHost = ts.createCompilerHost(tsCompilerOptions);
    tsHost.getSourceFile = (tsFilePath) => {
        tsFilePath = normalizePath(tsFilePath);
        const module = getModuleFileSync(config, ctx, tsFilePath);
        if (module && typeof module.tsText === 'string') {
            return ts.createSourceFile(tsFilePath, module.tsText, ts.ScriptTarget.ES2015);
        }
        config.logger.error(`tsHost.getSourceFile unable to find ${tsFilePath}`);
        return null;
    };
    tsHost.fileExists = (tsFilePath) => {
        tsFilePath = normalizePath(tsFilePath);
        return moduleFileExistsSync(config, ctx, tsFilePath);
    },
        tsHost.readFile = (tsFilePath) => {
            tsFilePath = normalizePath(tsFilePath);
            let moduleFile = getModuleFileSync(config, ctx, tsFilePath);
            return moduleFile.tsText;
        },
        tsHost.writeFile = (outputFilePath, outputText, writeByteOrderMark, onError, sourceFiles) => {
            sourceFiles.forEach(sourceFile => {
                writeFileInMemory(config, ctx, transpileResults, sourceFile, outputFilePath, outputText);
            });
            
        };
    return tsHost;
}
function writeFileInMemory(config, ctx, transpileResults, sourceFile, outputFilePath, outputText) {
    const tsFilePath = normalizePath(sourceFile.fileName);
    outputFilePath = normalizePath(outputFilePath);
    if (isJsFile(outputFilePath)) {
        // transpiled file is a js file
        const jsFilePath = outputFilePath;
        let moduleFile = ctx.moduleFiles[tsFilePath];
        if (moduleFile) {
            // we got the module we already cached
            moduleFile.jsFilePath = jsFilePath;
        }
        else {
            // this actually shouldn't happen, but just in case
            moduleFile = ctx.moduleFiles[tsFilePath] = {
                tsFilePath: tsFilePath,
                jsFilePath: jsFilePath,
            };
        }
        // cache the js content
        ctx.jsFiles[jsFilePath] = outputText;
        // add this module to the list of files that were just transpiled
        transpileResults.moduleFiles[tsFilePath] = moduleFile;
    }
    else if (isDtsFile(outputFilePath)) {
        // transpiled file is a .d.ts file
        const dtsFilePath = outputFilePath;
        let moduleFile = ctx.moduleFiles[tsFilePath];
        if (moduleFile) {
            // we got the module we already cached
            moduleFile.dtsFilePath = dtsFilePath;
        }
        else {
            // this actually shouldn't happen, but just in case
            moduleFile = ctx.moduleFiles[tsFilePath] = {
                tsFilePath: tsFilePath,
                dtsFilePath: dtsFilePath,
            };
        }
        // write the .d.ts file
        ctx.filesToWrite[dtsFilePath] = outputText;
        // add this module to the list of files that were just transpiled
        transpileResults.moduleFiles[tsFilePath] = moduleFile;
    }
    else {
        // idk, this shouldn't happen
        config.logger.debug(`unknown transpiled output: ${outputFilePath}`);
    }
}
function getModuleFile(config, ctx, tsFilePath) {
    tsFilePath = normalizePath(tsFilePath);
    let moduleFile = ctx.moduleFiles[tsFilePath];
    if (moduleFile) {
        if (typeof moduleFile.tsText === 'string') {
            // cool, already have the ts source content
            return Promise.resolve(moduleFile);
        }
        // we have the module, but no source content, let's load it up
        return readFile(config.sys, tsFilePath).then(tsText => {
            moduleFile.tsText = tsText;
            return moduleFile;
        });
    }
    // never seen this ts file before, let's start a new module file
    return readFile(config.sys, tsFilePath).then(tsText => {
        moduleFile = ctx.moduleFiles[tsFilePath] = {
            tsFilePath: tsFilePath,
            tsText: tsText
        };
        return moduleFile;
    });
}
function getModuleFileSync(config, ctx, tsFilePath) {
    tsFilePath = normalizePath(tsFilePath);
    let moduleFile = ctx.moduleFiles[tsFilePath];
    try {
        if (moduleFile) {
            // sweet, we already have this module in our cache!
            if (typeof moduleFile.tsText !== 'string') {
                // we have the module, but no source content, let's load it up
                moduleFile.tsText = config.sys.fs.readFileSync(tsFilePath, 'utf-8');
            }
        }
        else {
            // never seen this ts file before, let's start a new module file
            moduleFile = ctx.moduleFiles[tsFilePath] = {
                tsFilePath: tsFilePath,
                tsText: config.sys.fs.readFileSync(tsFilePath, 'utf-8')
            };
        }
    }
    catch (e) {
        moduleFile = ctx.moduleFiles[tsFilePath] = {
            tsFilePath: tsFilePath,
            tsText: null
        };
    }
    return moduleFile;
}
function moduleFileExistsSync(config, ctx, tsFilePath) {
    let moduleFile = ctx.moduleFiles[tsFilePath];
    if (moduleFile) {
        return (typeof moduleFile.tsText === 'string');
    }
    const module = getModuleFileSync(config, ctx, tsFilePath);
    return (typeof module.tsText === 'string');
}

function getUserTsConfig(config) {
    // force defaults
    const options = {
        // to allow jsx to work
        jsx: ts.JsxEmit.React,
        // the factory function to use
        jsxFactory: 'h',
        // transpileModule does not write anything to disk so there is no need
        // to verify that there are no conflicts between input and output paths.
        suppressOutputPathCheck: true,
        // Clear out other settings that would not be used in transpiling this module
        lib: [
            'lib.dom.d.ts',
            'lib.es5.d.ts',
            'lib.es2015.d.ts',
            'lib.es2016.d.ts',
            'lib.es2017.d.ts'
        ],
        allowSyntheticDefaultImports: true,
        // must always allow decorators
        experimentalDecorators: true,
        // create es2015 modules
        module: ts.ModuleKind.ES2015,
        // resolve using NodeJs style
        moduleResolution: ts.ModuleResolutionKind.NodeJs,
        target: ts.ScriptTarget.ES2015
    };
    if (config._isTesting) {
        options.module = ts.ModuleKind.CommonJS;
    }
    // apply user config to tsconfig
    options.outDir = config.collectionDir;
    options.rootDir = config.srcDir;
    // generate .d.ts files when generating a distribution and in prod mode
    options.declaration = config.generateDistribution;
    return options;
}

function updateComponentClass(classNode) {
    return ts.createClassDeclaration(undefined, // <-- that's what's removing the decorator
    // Make the component the default export
    [ts.createToken(ts.SyntaxKind.ExportKeyword)], 
    // everything else should be the same
    classNode.name, classNode.typeParameters, classNode.heritageClauses, classNode.members);
}


function isInstanceOfObjectMap(object) {
    return (!object.hasOwnProperty('kind') &&
        !object.hasOwnProperty('flags') &&
        !object.hasOwnProperty('pos') &&
        !object.hasOwnProperty('end'));
}
function getTextOfPropertyName(name) {
    switch (name.kind) {
        case ts.SyntaxKind.Identifier:
            return name.text;
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.NumericLiteral:
            return name.text;
        case ts.SyntaxKind.ComputedPropertyName:
            const expression = name.expression;
            if (ts.isStringLiteral(expression) || ts.isNumericLiteral(expression)) {
                return name.expression.text;
            }
    }
    return undefined;
}
function objectLiteralToObjectMap(objectLiteral) {
    const attrs = objectLiteral.properties;
    return attrs.reduce((final, attr) => {
        const name = getTextOfPropertyName(attr.name);
        let val;
        switch (attr.initializer.kind) {
            case ts.SyntaxKind.ObjectLiteralExpression:
                val = objectLiteralToObjectMap(attr.initializer);
                break;
            case ts.SyntaxKind.StringLiteral:
            case ts.SyntaxKind.Identifier:
            case ts.SyntaxKind.PropertyAccessExpression:
            default:
                val = attr.initializer;
        }
        final[name] = val;
        return final;
    }, {});
}
function objectMapToObjectLiteral(objMap) {
    const newProperties = Object.keys(objMap).map((key) => {
        let value = objMap[key];
        if (!ts.isIdentifier(value) && isInstanceOfObjectMap(value)) {
            return ts.createPropertyAssignment(ts.createLiteral(key), objectMapToObjectLiteral(value));
        }
        return ts.createPropertyAssignment(ts.createLiteral(key), value);
    });
    return ts.createObjectLiteral(newProperties);
}
/**
 * Convert a js value into typescript AST
 * @param val array, object, string, boolean, or number
 * @returns Typescript Object Literal, Array Literal, String Literal, Boolean Literal, Numeric Literal
 */

/**
 * Execute an array of transforms over a string containing typescript source
 * @param sourceText Typescript source as a string
 * @param transformers Array of transforms to run agains the source string
 * @returns a string
 */
function transformSourceString(fileName, sourceText, transformers) {
    const transformed = ts.transform(ts.createSourceFile(fileName, sourceText, ts.ScriptTarget.ES2015), transformers);
    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed }, {
        onEmitNode: transformed.emitNodeWithNotification,
        substituteNode: transformed.substituteNode
    });
    const result = printer.printBundle(ts.createBundle(transformed.transformed));
    transformed.dispose();
    return result;
}
/**
 * Execute transforms over a string containing typescript source
 * @param sourceText Typescript source as a string
 * @param transformers Object containing before and after transforms to run against the source string
 * @returns a string
 */

// this maps the json data to our internal data structure
// apping is so that the internal data structure "could"
// change, but the external user data will always use the same api
// over the top lame mapping functions is basically so we can loosly
// couple core component meta data between specific versions of the compiler
function writeAppManifest(config, ctx, buildResults) {
    // get the absolute path to the directory where the manifest will be saved
    const manifestDir = normalizePath(config.collectionDir);
    // create an absolute file path to the actual manifest json file
    const manifestFilePath = normalizePath(config.sys.path.join(manifestDir, COLLECTION_MANIFEST_FILE_NAME));
    config.logger.debug(`manifest, serializeAppManifest: ${manifestFilePath}`);
    // serialize the manifest into a json string and
    // add it to the list of files we need to write when we're ready
    buildResults.manifest = serializeAppManifest(config, manifestDir, ctx.manifest);
    if (config.generateDistribution) {
        // don't bother serializing/writing the manifest if we're not creating a distribution
        ctx.filesToWrite[manifestFilePath] = JSON.stringify(buildResults.manifest, null, 2);
    }
}
function serializeAppManifest(config, manifestDir, manifest) {
    // create the single manifest we're going to fill up with data
    const manifestData = {
        components: [],
        bundles: [],
        compiler: {
            name: config.sys.compiler.name,
            version: config.sys.compiler.version,
            typescriptVersion: config.sys.compiler.typescriptVersion
        }
    };
    // add component data for each of the manifest files
    manifest.modulesFiles.forEach(modulesFile => {
        if (!modulesFile.excludeFromCollection) {
            const cmpData = serializeComponent(config, manifestDir, modulesFile);
            if (cmpData) {
                manifestData.components.push(cmpData);
            }
        }
    });
    // sort it alphabetically, cuz
    manifestData.components.sort((a, b) => {
        if (a.tag < b.tag)
            return -1;
        if (a.tag > b.tag)
            return 1;
        return 0;
    });
    // add to the manifest what the bundles should be
    serializeBundles(manifestData, manifest);
    // set the global path if it exists
    serializeAppGlobal(config, manifestDir, manifestData, manifest);
    // success!
    return manifestData;
}
function parseDependentManifest(config, collectionName, manifestDir, manifestJson) {
    const manifestData = JSON.parse(manifestJson);
    const manifest = {
        manifestName: collectionName,
        compiler: {
            name: manifestData.compiler.name,
            version: manifestData.compiler.version,
            typescriptVersion: manifestData.compiler.typescriptVersion
        }
    };
    parseComponents(config, manifestDir, manifestData, manifest);
    parseBundles(manifestData, manifest);
    parseGlobal(config, manifestDir, manifestData, manifest);
    return manifest;
}
function parseComponents(config, manifestDir, manifestData, manifest) {
    const componentsData = manifestData.components;
    if (!componentsData || !Array.isArray(componentsData)) {
        manifest.modulesFiles = [];
        return;
    }
    manifest.modulesFiles = componentsData.map(cmpData => {
        return parseComponentDataToModuleFile(config, manifest, manifestDir, cmpData);
    });
}
function excludeFromCollection(config, cmpData) {
    // this is a component from a collection dependency
    // however, this project may also become a collection
    // for example, "ionicons" is a dependency of "ionic"
    // and "ionic" is it's own stand-alone collection, so within
    // ionic's collection we want ionicons to just work
    // cmpData is a component from a collection dependency
    // if this component is listed in this config's bundles
    // then we'll need to ensure it also becomes apart of this collection
    const isInBundle = config.bundles && config.bundles.some(bundle => {
        return bundle.components && bundle.components.some(tag => tag === cmpData.tag);
    });
    // if it's not in the config bundle then it's safe to exclude
    // this component from going into this build's collection
    return !isInBundle;
}
function serializeComponent(config, manifestDir, moduleFile) {
    if (!moduleFile || !moduleFile.cmpMeta)
        return null;
    const cmpData = {};
    const cmpMeta = moduleFile.cmpMeta;
    // get the absolute path to the compiled component's output javascript file
    const compiledComponentAbsoluteFilePath = normalizePath(moduleFile.jsFilePath);
    // create a relative path from the manifest file to the compiled component's output javascript file
    const compiledComponentRelativeFilePath = normalizePath(config.sys.path.relative(manifestDir, compiledComponentAbsoluteFilePath));
    // create a relative path to the directory where the compiled component's output javascript is sitting in
    const compiledComponentRelativeDirPath = normalizePath(config.sys.path.dirname(compiledComponentRelativeFilePath));
    serializeTag(cmpData, cmpMeta);
    serializeComponentClass(cmpData, cmpMeta);
    serializeComponentPath(config, manifestDir, moduleFile, compiledComponentAbsoluteFilePath, cmpData);
    serializeStyles(config, moduleFile, compiledComponentRelativeDirPath, cmpData, cmpMeta);
    serializeAssetsDir(config, moduleFile, compiledComponentRelativeDirPath, cmpData, cmpMeta);
    serializeProps(cmpData, cmpMeta);
    serializePropsWillChange(cmpData, cmpMeta);
    serializePropsDidChange(cmpData, cmpMeta);
    serializeStates(cmpData, cmpMeta);
    serializeListeners(cmpData, cmpMeta);
    serializeMethods(cmpData, cmpMeta);
    serializeContextMember(cmpData, cmpMeta);
    serializeConnectMember(cmpData, cmpMeta);
    serializeHostElementMember(cmpData, cmpMeta);
    serializeEvents(cmpData, cmpMeta);
    serializeHost(cmpData, cmpMeta);
    serializeSlots(cmpData, cmpMeta);
    serializeEncapsulation(cmpData, cmpMeta);
    serializeLoadPriority(cmpData, cmpMeta);
    return cmpData;
}
function parseComponentDataToModuleFile(config, manifest, manifestDir, cmpData) {
    const moduleFile = {
        cmpMeta: {},
        isCollectionDependency: true,
        excludeFromCollection: excludeFromCollection(config, cmpData)
    };
    const cmpMeta = moduleFile.cmpMeta;
    parseTag(cmpData, cmpMeta);
    parseComponentClass(cmpData, cmpMeta);
    parseModuleJsFilePath(config, manifestDir, cmpData, moduleFile);
    parseStyles(config, manifestDir, cmpData, cmpMeta);
    parseAssetsDir(config, manifestDir, cmpData, cmpMeta);
    parseProps(config, manifest, cmpData, cmpMeta);
    parsePropsWillChange(cmpData, cmpMeta);
    parsePropsDidChange(cmpData, cmpMeta);
    parseStates(cmpData, cmpMeta);
    parseListeners(cmpData, cmpMeta);
    parseMethods(cmpData, cmpMeta);
    parseContextMember(cmpData, cmpMeta);
    parseConnectMember(cmpData, cmpMeta);
    parseHostElementMember(cmpData, cmpMeta);
    parseEvents(cmpData, cmpMeta);
    parseHost(cmpData, cmpMeta);
    parseEncapsulation(cmpData, cmpMeta);
    parseSlots(cmpData, cmpMeta);
    parseLoadPriority(cmpData, cmpMeta);
    return moduleFile;
}
function serializeTag(cmpData, cmpMeta) {
    cmpData.tag = cmpMeta.tagNameMeta;
}
function parseTag(cmpData, cmpMeta) {
    cmpMeta.tagNameMeta = cmpData.tag;
}
function serializeComponentPath(config, manifestDir, moduleFile, compiledComponentAbsoluteFilePath, cmpData) {
    if (moduleFile.isCollectionDependency && moduleFile.originalCollectionComponentPath) {
        // use the original path from its collection if there was one
        cmpData.componentPath = normalizePath(config.sys.path.join(COLLECTION_DEPENDENCIES_DIR, moduleFile.originalCollectionComponentPath));
    }
    else {
        // convert absolute path into a path that's relative to the manifest file
        cmpData.componentPath = normalizePath(config.sys.path.relative(manifestDir, compiledComponentAbsoluteFilePath));
    }
}
function parseModuleJsFilePath(config, manifestDir, cmpData, moduleFile) {
    // convert the path that's relative to the manifest file
    // into an absolute path to the component's js file path
    moduleFile.jsFilePath = normalizePath(config.sys.path.join(manifestDir, cmpData.componentPath));
    // remember the original component path from its collection
    moduleFile.originalCollectionComponentPath = cmpData.componentPath;
}
function serializeComponentClass(cmpData, cmpMeta) {
    cmpData.componentClass = cmpMeta.componentClass;
}
function parseComponentClass(cmpData, cmpMeta) {
    cmpMeta.componentClass = cmpData.componentClass;
}
function serializeStyles(config, moduleFile, compiledComponentRelativeDirPath, cmpData, cmpMeta) {
    if (cmpMeta.stylesMeta) {
        cmpData.styles = {};
        const modeNames = Object.keys(cmpMeta.stylesMeta).map(m => m.toLowerCase()).sort();
        modeNames.forEach(modeName => {
            cmpData.styles[modeName] = serializeStyle(config, moduleFile, compiledComponentRelativeDirPath, cmpMeta.stylesMeta[modeName]);
        });
    }
}
function parseStyles(config, manifestDir, cmpData, cmpMeta) {
    const stylesData = cmpData.styles;
    cmpMeta.stylesMeta = {};
    if (stylesData) {
        Object.keys(stylesData).forEach(modeName => {
            modeName = modeName.toLowerCase();
            cmpMeta.stylesMeta[modeName] = parseStyle(config, manifestDir, cmpData, stylesData[modeName]);
        });
    }
}
function serializeStyle(config, moduleFile, compiledComponentRelativeDirPath, modeStyleMeta) {
    const modeStyleData = {};
    if (modeStyleMeta.cmpRelativePaths) {
        if (moduleFile.isCollectionDependency) {
            // this is from a collection, let's use the original paths
            modeStyleData.stylePaths = modeStyleMeta.originalCollectionPaths.map(originalCollectionPath => {
                return normalizePath(config.sys.path.join(COLLECTION_DEPENDENCIES_DIR, originalCollectionPath));
            });
        }
        else {
            modeStyleData.stylePaths = modeStyleMeta.cmpRelativePaths.map(componentRelativeStylePath => {
                // convert style paths which are relative to the component file
                // to be style paths that are relative to the manifest file
                // we've already figured out the component's relative path from the manifest file
                // use the value we already created in serializeComponentPath()
                // create a relative path from the manifest file to the style path
                return normalizePath(config.sys.path.join(compiledComponentRelativeDirPath, componentRelativeStylePath));
            });
        }
        modeStyleData.stylePaths.sort();
    }
    if (typeof modeStyleMeta.styleStr === 'string') {
        modeStyleData.style = modeStyleMeta.styleStr;
    }
    return modeStyleData;
}
function parseStyle(config, manifestDir, cmpData, modeStyleData) {
    const modeStyle = {
        styleStr: modeStyleData.style
    };
    if (modeStyleData.stylePaths) {
        modeStyle.absolutePaths = modeStyleData.stylePaths.map(stylePath => {
            return normalizePath(config.sys.path.join(manifestDir, stylePath));
        });
        modeStyle.cmpRelativePaths = modeStyleData.stylePaths.map(stylePath => {
            return normalizePath(config.sys.path.relative(config.sys.path.dirname(cmpData.componentPath), stylePath));
        });
        modeStyle.originalCollectionPaths = modeStyleData.stylePaths.slice();
    }
    return modeStyle;
}
function serializeAssetsDir(config, moduleFile, compiledComponentRelativeDirPath, cmpData, cmpMeta) {
    if (invalidArrayData(cmpMeta.assetsDirsMeta)) {
        return;
    }
    // convert asset paths which are relative to the component file
    // to be asset paths that are relative to the manifest file
    // we've already figured out the component's relative path from the manifest file
    // use the value we already created in serializeComponentPath()
    // create a relative path from the manifest file to the asset path
    cmpData.assetPaths = cmpMeta.assetsDirsMeta.map(assetMeta => {
        if (moduleFile.isCollectionDependency && assetMeta.originalCollectionPath) {
            return normalizePath(config.sys.path.join(COLLECTION_DEPENDENCIES_DIR, assetMeta.originalCollectionPath));
        }
        return normalizePath(config.sys.path.join(compiledComponentRelativeDirPath, assetMeta.cmpRelativePath));
    }).sort();
}
function parseAssetsDir(config, manifestDir, cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.assetPaths)) {
        return;
    }
    cmpMeta.assetsDirsMeta = cmpData.assetPaths.map(assetsPath => {
        const assetsMeta = {
            absolutePath: normalizePath(config.sys.path.join(manifestDir, assetsPath)),
            cmpRelativePath: normalizePath(config.sys.path.relative(config.sys.path.dirname(cmpData.componentPath), assetsPath)),
            originalCollectionPath: normalizePath(assetsPath)
        };
        return assetsMeta;
    }).sort((a, b) => {
        if (a.cmpRelativePath < b.cmpRelativePath)
            return -1;
        if (a.cmpRelativePath > b.cmpRelativePath)
            return 1;
        return 0;
    });
}
function serializeProps(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.memberType === 1 /* Prop */ || member.memberType === 2 /* PropMutable */) {
            cmpData.props = cmpData.props || [];
            const propData = {
                name: memberName
            };
            if (member.propType === 3 /* Boolean */) {
                propData.type = 'boolean';
            }
            else if (member.propType === 4 /* Number */) {
                propData.type = 'number';
            }
            else if (member.propType === 2 /* String */) {
                propData.type = 'string';
            }
            else if (member.propType === 1 /* Any */) {
                propData.type = 'any';
            }
            if (member.memberType === 2 /* PropMutable */) {
                propData.mutable = true;
            }
            cmpData.props.push(propData);
        }
    });
}
function parseProps(config, manifest, cmpData, cmpMeta) {
    const propsData = cmpData.props;
    if (invalidArrayData(propsData)) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    propsData.forEach(propData => {
        cmpMeta.membersMeta[propData.name] = {};
        if (propData.mutable) {
            cmpMeta.membersMeta[propData.name].memberType = 2 /* PropMutable */;
        }
        else {
            cmpMeta.membersMeta[propData.name].memberType = 1 /* Prop */;
        }
        if (propData.type === 'boolean') {
            cmpMeta.membersMeta[propData.name].propType = 3 /* Boolean */;
        }
        else if (propData.type === 'number') {
            cmpMeta.membersMeta[propData.name].propType = 4 /* Number */;
        }
        else if (propData.type === 'string') {
            cmpMeta.membersMeta[propData.name].propType = 2 /* String */;
        }
        else if (propData.type === 'any') {
            cmpMeta.membersMeta[propData.name].propType = 1 /* Any */;
        }
        else if (!manifest.compiler || !manifest.compiler.version || config.sys.semver.lt(manifest.compiler.version, '0.0.6-23')) {
            // older compilers didn't remember "any" type
            cmpMeta.membersMeta[propData.name].propType = 1 /* Any */;
        }
        if (cmpMeta.membersMeta[propData.name].propType) {
            cmpMeta.membersMeta[propData.name].attribName = propData.name;
        }
    });
}
function serializePropsWillChange(cmpData, cmpMeta) {
    if (invalidArrayData(cmpMeta.propsWillChangeMeta)) {
        return;
    }
    cmpData.propsWillChange = cmpMeta.propsWillChangeMeta.map(propWillChangeMeta => {
        const propWillChangeData = {
            name: propWillChangeMeta[0],
            method: propWillChangeMeta[1]
        };
        return propWillChangeData;
    });
}
function parsePropsWillChange(cmpData, cmpMeta) {
    const propWillChangeData = cmpData.propsWillChange;
    if (invalidArrayData(propWillChangeData)) {
        return;
    }
    cmpMeta.propsWillChangeMeta = propWillChangeData.map(propWillChangeData => {
        const propWillChangeMeta = [
            propWillChangeData.name,
            propWillChangeData.method
        ];
        return propWillChangeMeta;
    });
}
function serializePropsDidChange(cmpData, cmpMeta) {
    if (invalidArrayData(cmpMeta.propsDidChangeMeta)) {
        return;
    }
    cmpData.propsDidChange = cmpMeta.propsDidChangeMeta.map(propDidChangeMeta => {
        const propDidChangeData = {
            name: propDidChangeMeta[0],
            method: propDidChangeMeta[1]
        };
        return propDidChangeData;
    });
}
function parsePropsDidChange(cmpData, cmpMeta) {
    const propDidChangeData = cmpData.propsDidChange;
    if (invalidArrayData(propDidChangeData)) {
        return;
    }
    cmpMeta.propsDidChangeMeta = propDidChangeData.map(propDidChangeData => {
        const propDidChangeMeta = [
            propDidChangeData.name,
            propDidChangeData.method
        ];
        return propDidChangeMeta;
    });
}
function serializeStates(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.memberType === 5 /* State */) {
            cmpData.states = cmpData.states || [];
            cmpData.states.push({
                name: memberName
            });
        }
    });
}
function parseStates(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.states)) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    cmpData.states.forEach(stateData => {
        cmpMeta.membersMeta[stateData.name] = {
            memberType: 5 /* State */
        };
    });
}
function serializeListeners(cmpData, cmpMeta) {
    if (invalidArrayData(cmpMeta.listenersMeta)) {
        return;
    }
    cmpData.listeners = cmpMeta.listenersMeta.map(listenerMeta => {
        const listenerData = {
            event: listenerMeta.eventName,
            method: listenerMeta.eventMethodName
        };
        if (listenerMeta.eventPassive === false) {
            listenerData.passive = false;
        }
        if (listenerMeta.eventDisabled === true) {
            listenerData.enabled = false;
        }
        if (listenerMeta.eventCapture === false) {
            listenerData.capture = false;
        }
        return listenerData;
    }).sort((a, b) => {
        if (a.event.toLowerCase() < b.event.toLowerCase())
            return -1;
        if (a.event.toLowerCase() > b.event.toLowerCase())
            return 1;
        return 0;
    });
}
function parseListeners(cmpData, cmpMeta) {
    const listenersData = cmpData.listeners;
    if (invalidArrayData(listenersData)) {
        return;
    }
    cmpMeta.listenersMeta = listenersData.map(listenerData => {
        const listener = {
            eventName: listenerData.event,
            eventMethodName: listenerData.method,
            eventPassive: (listenerData.passive !== false),
            eventDisabled: (listenerData.enabled === false),
            eventCapture: (listenerData.capture !== false)
        };
        return listener;
    });
}
function serializeMethods(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.memberType === 6 /* Method */) {
            cmpData.methods = cmpData.methods || [];
            cmpData.methods.push({
                name: memberName
            });
        }
    });
}
function parseMethods(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.methods)) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    cmpData.methods.forEach(methodData => {
        cmpMeta.membersMeta[methodData.name] = {
            memberType: 6 /* Method */
        };
    });
}
function serializeContextMember(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.ctrlId && member.memberType === 3 /* PropContext */) {
            cmpData.context = cmpData.context || [];
            cmpData.context.push({
                name: memberName,
                id: member.ctrlId
            });
        }
    });
}
function parseContextMember(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.context)) {
        return;
    }
    cmpData.context.forEach(methodData => {
        if (methodData.id) {
            cmpMeta.membersMeta = cmpMeta.membersMeta || {};
            cmpMeta.membersMeta[methodData.name] = {
                memberType: 3 /* PropContext */,
                ctrlId: methodData.id
            };
        }
    });
}
function serializeConnectMember(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.ctrlId && member.memberType === 4 /* PropConnect */) {
            cmpData.connect = cmpData.connect || [];
            cmpData.connect.push({
                name: memberName,
                tag: member.ctrlId
            });
        }
    });
}
function parseConnectMember(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.connect)) {
        return;
    }
    cmpData.connect.forEach(methodData => {
        if (methodData.tag) {
            cmpMeta.membersMeta = cmpMeta.membersMeta || {};
            cmpMeta.membersMeta[methodData.name] = {
                memberType: 4 /* PropConnect */,
                ctrlId: methodData.tag
            };
        }
    });
}
function serializeHostElementMember(cmpData, cmpMeta) {
    if (!cmpMeta.membersMeta)
        return;
    Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        const member = cmpMeta.membersMeta[memberName];
        if (member.memberType === 7 /* Element */) {
            cmpData.hostElement = {
                name: memberName
            };
        }
    });
}
function parseHostElementMember(cmpData, cmpMeta) {
    if (!cmpData.hostElement) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    cmpMeta.membersMeta[cmpData.hostElement.name] = {
        memberType: 7 /* Element */
    };
}
function serializeEvents(cmpData, cmpMeta) {
    if (invalidArrayData(cmpMeta.eventsMeta)) {
        return;
    }
    cmpData.events = cmpMeta.eventsMeta.map(eventMeta => {
        const eventData = {
            event: eventMeta.eventName
        };
        if (eventMeta.eventMethodName !== eventMeta.eventName) {
            eventData.method = eventMeta.eventMethodName;
        }
        if (eventMeta.eventBubbles === false) {
            eventData.bubbles = false;
        }
        if (eventMeta.eventCancelable === false) {
            eventData.cancelable = false;
        }
        if (eventMeta.eventComposed === false) {
            eventData.composed = false;
        }
        return eventData;
    }).sort((a, b) => {
        if (a.event.toLowerCase() < b.event.toLowerCase())
            return -1;
        if (a.event.toLowerCase() > b.event.toLowerCase())
            return 1;
        return 0;
    });
}
function parseEvents(cmpData, cmpMeta) {
    const eventsData = cmpData.events;
    if (invalidArrayData(eventsData)) {
        return;
    }
    cmpMeta.eventsMeta = eventsData.map(eventData => {
        const eventMeta = {
            eventName: eventData.event,
            eventMethodName: eventData.event
        };
        if (eventData.method) {
            eventMeta.eventMethodName = eventData.method;
        }
        eventMeta.eventBubbles = (eventData.bubbles !== false);
        eventMeta.eventCancelable = (eventData.cancelable !== false);
        eventMeta.eventComposed = (eventData.composed !== false);
        return eventMeta;
    });
}
function serializeHost(cmpData, cmpMeta) {
    if (!cmpMeta.hostMeta || Array.isArray(cmpMeta.hostMeta) || !Object.keys(cmpMeta.hostMeta).length) {
        return;
    }
    cmpData.host = cmpMeta.hostMeta;
}
function parseHost(cmpData, cmpMeta) {
    if (!cmpData.host) {
        return;
    }
    cmpMeta.hostMeta = cmpData.host;
}
function serializeSlots(cmpData, cmpMeta) {
    if (cmpMeta.slotMeta === 1 /* HasSlots */) {
        cmpData.slot = 'hasSlots';
    }
    else if (cmpMeta.slotMeta === 2 /* HasNamedSlots */) {
        cmpData.slot = 'hasNamedSlots';
    }
}
function parseSlots(cmpData, cmpMeta) {
    if (cmpData.slot === 'hasSlots') {
        cmpMeta.slotMeta = 1 /* HasSlots */;
    }
    else if (cmpData.slot === 'hasNamedSlots') {
        cmpMeta.slotMeta = 2 /* HasNamedSlots */;
    }
}
function serializeEncapsulation(cmpData, cmpMeta) {
    if (cmpMeta.encapsulation === 1 /* ShadowDom */) {
        cmpData.shadow = true;
    }
    else if (cmpMeta.encapsulation === 2 /* ScopedCss */) {
        cmpData.scoped = true;
    }
}
function parseEncapsulation(cmpData, cmpMeta) {
    if (cmpData.shadow === true) {
        cmpMeta.encapsulation = 1 /* ShadowDom */;
    }
    else if (cmpData.scoped === true) {
        cmpMeta.encapsulation = 2 /* ScopedCss */;
    }
    else {
        cmpMeta.encapsulation = 0 /* NoEncapsulation */;
    }
}
function serializeLoadPriority(cmpData, cmpMeta) {
    if (cmpMeta.loadPriority === 1 /* Low */) {
        cmpData.priority = 'low';
    }
}
function parseLoadPriority(cmpData, cmpMeta) {
    if (cmpData.priority === 'low') {
        cmpMeta.loadPriority = 1 /* Low */;
    }
}
function serializeBundles(manifestData, manifest) {
    manifestData.bundles = [];
    const bundles = manifest.bundles;
    if (invalidArrayData(bundles)) {
        return;
    }
    bundles.forEach(bundle => {
        if (invalidArrayData(bundle.components)) {
            return;
        }
        const bundleData = {
            components: bundle.components.map(tag => tag.toLowerCase()).sort()
        };
        if (bundle.priority === 1 /* Low */) {
            bundleData.priority = 'low';
        }
        manifestData.bundles.push(bundleData);
    });
    manifestData.bundles.sort((a, b) => {
        if (a.components[0] < b.components[0])
            return -1;
        if (a.components[0] > b.components[0])
            return 1;
        return 0;
    });
}
function parseBundles(manifestData, manifest) {
    manifest.bundles = [];
    if (invalidArrayData(manifestData.bundles)) {
        return;
    }
    manifestData.bundles.forEach(bundleData => {
        if (invalidArrayData(bundleData.components)) {
            return;
        }
        const bundle = {
            components: bundleData.components.sort()
        };
        if (bundleData.priority === 'low') {
            bundle.priority = 1 /* Low */;
        }
        manifest.bundles.push(bundle);
    });
}
function serializeAppGlobal(config, manifestDir, manifestData, manifest) {
    if (!manifest.global) {
        return;
    }
    manifestData.global = normalizePath(config.sys.path.relative(manifestDir, manifest.global.jsFilePath));
}
function parseGlobal(config, manifestDir, manifestData, manifest) {
    if (typeof manifestData.global !== 'string')
        return;
    manifest.global = {
        jsFilePath: normalizePath(config.sys.path.join(manifestDir, manifestData.global))
    };
}
function invalidArrayData(arr) {
    return (!arr || !Array.isArray(arr) || arr.length === 0);
}
function nameSort(a, b) {
    if (a.toLowerCase() < b.toLowerCase())
        return -1;
    if (a.toLowerCase() > b.toLowerCase())
        return 1;
    return 0;
}
const COLLECTION_DEPENDENCIES_DIR = 'dependencies';

function normalizeAssetsDir(config, userOpts, moduleFile, cmpMeta) {
    if (userOpts.assetsDir) {
        normalizeAssetDir(config, moduleFile, cmpMeta, userOpts.assetsDir);
    }
    if (Array.isArray(userOpts.assetsDirs)) {
        userOpts.assetsDirs.forEach(assetsDir => {
            normalizeAssetDir(config, moduleFile, cmpMeta, assetsDir);
        });
    }
}
function normalizeAssetDir(config, moduleFile, cmpMeta, assetsDir) {
    if (typeof assetsDir !== 'string' || assetsDir.trim() === '')
        return;
    const assetsMeta = {};
    // get the absolute path of the directory which the component is sitting in
    const componentDir = normalizePath(config.sys.path.dirname(moduleFile.tsFilePath));
    // get the relative path from the component file to the assets directory
    assetsDir = normalizePath(assetsDir.trim());
    if (config.sys.path.isAbsolute(assetsDir)) {
        // this path is absolute already!
        // add as the absolute path
        assetsMeta.absolutePath = assetsDir;
        // if this is an absolute path already, let's convert it to be relative
        assetsMeta.cmpRelativePath = config.sys.path.relative(componentDir, assetsDir);
    }
    else {
        // this path is relative to the component
        assetsMeta.cmpRelativePath = assetsDir;
        // create the absolute path to the asset dir
        assetsMeta.absolutePath = normalizePath(config.sys.path.join(componentDir, assetsDir));
    }
    (cmpMeta.assetsDirsMeta = cmpMeta.assetsDirsMeta || []).push(assetsMeta);
}
function copyComponentAssets(config, ctx) {
    if (skipAssetsCopy(config, ctx)) {
        // no need to recopy all assets again
        return Promise.resolve();
    }
    const timeSpan = config.logger.createTimeSpan(`copy assets started`, true);
    // get a list of all the directories to copy
    // these paths should be absolute
    const copyToBuildDir = [];
    const copyToCollectionDir = [];
    ctx.manifest.modulesFiles.forEach(moduleFile => {
        if (!moduleFile.cmpMeta.assetsDirsMeta || !moduleFile.cmpMeta.assetsDirsMeta.length)
            return;
        moduleFile.cmpMeta.assetsDirsMeta.forEach(assetsMeta => {
            copyToBuildDir.push(assetsMeta);
            if (!moduleFile.excludeFromCollection) {
                copyToCollectionDir.push(assetsMeta);
            }
        });
    });
    const dirCopyPromises = [];
    // copy all of the files in asset directories to the app's build and/or dist directory
    copyToBuildDir.forEach(assetsMeta => {
        // figure out what the path is to the component directory
        if (config.generateWWW) {
            const wwwBuildDirDestination = normalizePath(config.sys.path.join(getAppWWWBuildDir(config), assetsMeta.cmpRelativePath));
            // let's copy to the www/build directory!
            const copyToWWWBuildDir = config.sys.copy(assetsMeta.absolutePath, wwwBuildDirDestination);
            dirCopyPromises.push(copyToWWWBuildDir);
        }
        if (config.generateDistribution) {
            const distDirDestination = normalizePath(config.sys.path.join(getAppDistDir(config), assetsMeta.cmpRelativePath));
            // let's copy to the www/build directory!
            const copyToDistDir = config.sys.copy(assetsMeta.absolutePath, distDirDestination);
            dirCopyPromises.push(copyToDistDir);
        }
    });
    // copy all of the files in asset directories to the dist/collection directory
    // but only do this copy when the generateCollection flag is set to true
    if (config.generateDistribution) {
        // copy all of the files in asset directories to the app's collection directory
        copyToCollectionDir.forEach(assetsMeta => {
            // figure out what the path is to the component directory
            const collectionDirDestination = getCollectionDirDestination(config, assetsMeta);
            // let's copy to the dist/collection directory!
            const copyToCollectionDir = config.sys.copy(assetsMeta.absolutePath, collectionDirDestination);
            dirCopyPromises.push(copyToCollectionDir);
        });
    }
    return Promise.all(dirCopyPromises).catch(err => {
        catchError(ctx.diagnostics, err);
    }).then(() => {
        timeSpan.finish('copy assets finished');
    });
}
function getCollectionDirDestination(config, assetsMeta) {
    // figure out what the path is to the component directory
    if (assetsMeta.originalCollectionPath) {
        // this is from another collection, so reuse the same path it had
        return normalizePath(config.sys.path.join(config.collectionDir, COLLECTION_DEPENDENCIES_DIR, assetsMeta.originalCollectionPath));
    }
    return normalizePath(config.sys.path.join(config.collectionDir, config.sys.path.relative(config.srcDir, assetsMeta.absolutePath)));
}
function skipAssetsCopy(config, ctx) {
    // always copy assets if it's not a rebuild
    if (!ctx.isRebuild)
        return false;
    // assume we want to skip copying assets again
    let shouldSkipAssetsCopy = true;
    // loop through each of the changed files
    ctx.changedFiles.forEach(changedFile => {
        // get the directory of where the changed file is in
        const changedFileDirPath = normalizePath(config.sys.path.dirname(changedFile));
        // loop through all the possible asset directories
        ctx.manifest.modulesFiles.forEach(moduleFile => {
            if (moduleFile.cmpMeta && moduleFile.cmpMeta.assetsDirsMeta) {
                // loop through each of the asset directories of each component
                moduleFile.cmpMeta.assetsDirsMeta.forEach(assetsDir => {
                    // get the absolute of the asset directory
                    const assetDirPath = normalizePath(assetsDir.absolutePath);
                    // if the changed file directory is this asset directory
                    // then we should recopy everything over again
                    if (changedFileDirPath === assetDirPath) {
                        shouldSkipAssetsCopy = false;
                        return;
                    }
                });
            }
        });
    });
    return shouldSkipAssetsCopy;
}

function normalizeStyles(config, userOpts, moduleFile, cmpMeta) {
    normalizeStyleStr(userOpts, cmpMeta);
    normalizeStylePath(config, userOpts, moduleFile, cmpMeta);
    normalizeStylePaths(config, userOpts, moduleFile, cmpMeta);
}
function normalizeStyleStr(userOpts, cmpMeta) {
    if (typeof userOpts.styles === 'string' && userOpts.styles.trim().length) {
        cmpMeta.stylesMeta = cmpMeta.stylesMeta || {};
        cmpMeta.stylesMeta[DEFAULT_STYLE_MODE] = cmpMeta.stylesMeta[DEFAULT_STYLE_MODE] || {};
        cmpMeta.stylesMeta[DEFAULT_STYLE_MODE].styleStr = userOpts.styles.trim();
    }
}
function normalizeStylePath(config, userOpts, moduleFile, cmpMeta) {
    if (typeof userOpts.styleUrl === 'string' && userOpts.styleUrl.trim()) {
        // as a string
        // styleUrl: 'my-styles.scss'
        cmpMeta.stylesMeta = cmpMeta.stylesMeta || {};
        cmpMeta.stylesMeta[DEFAULT_STYLE_MODE] = cmpMeta.stylesMeta[DEFAULT_STYLE_MODE] || {};
        normalizeModeStylePaths(config, moduleFile, cmpMeta.stylesMeta[DEFAULT_STYLE_MODE], userOpts.styleUrl);
    }
}
function normalizeStylePaths(congif, userOpts, moduleFile, cmpMeta) {
    if (!userOpts.styleUrls) {
        return;
    }
    // normalize the possible styleUrl structures
    if (Array.isArray(userOpts.styleUrls)) {
        // as an array of strings
        // styleUrls: ['my-styles.scss', 'my-other-styles']
        userOpts.styleUrls.forEach(styleUrl => {
            if (styleUrl && typeof styleUrl === 'string' && styleUrl.trim()) {
                cmpMeta.stylesMeta = cmpMeta.stylesMeta || {};
                cmpMeta.stylesMeta[DEFAULT_STYLE_MODE] = cmpMeta.stylesMeta[DEFAULT_STYLE_MODE] || {};
                normalizeModeStylePaths(congif, moduleFile, cmpMeta.stylesMeta[DEFAULT_STYLE_MODE], userOpts.styleUrl);
            }
        });
        return;
    }
    // as an object
    // styleUrls: {
    //   ios: 'badge.ios.scss',
    //   md: 'badge.md.scss',
    //   wp: 'badge.wp.scss'
    // }
    const styleModes = userOpts.styleUrls;
    Object.keys(styleModes).forEach(styleModeName => {
        const modeName = styleModeName.trim().toLowerCase();
        if (typeof styleModes[styleModeName] === 'string' && styleModes[styleModeName].trim()) {
            cmpMeta.stylesMeta = cmpMeta.stylesMeta || {};
            cmpMeta.stylesMeta[modeName] = cmpMeta.stylesMeta[modeName] || {};
            normalizeModeStylePaths(congif, moduleFile, cmpMeta.stylesMeta[styleModeName], styleModes[styleModeName]);
        }
        else if (Array.isArray(styleModes[styleModeName])) {
            const styleUrls = userOpts.styleUrls;
            styleUrls.forEach(styleUrl => {
                if (styleUrl && typeof styleUrl === 'string' && styleUrl.trim().length) {
                    cmpMeta.stylesMeta = cmpMeta.stylesMeta || {};
                    cmpMeta.stylesMeta[modeName] = cmpMeta.stylesMeta[modeName] || {};
                    normalizeModeStylePaths(congif, moduleFile, cmpMeta.stylesMeta[styleModeName], styleUrl);
                }
            });
        }
    });
}
function normalizeModeStylePaths(config, moduleFile, modeStyleMeta, stylePath) {
    modeStyleMeta.cmpRelativePaths = modeStyleMeta.cmpRelativePaths || [];
    modeStyleMeta.absolutePaths = modeStyleMeta.absolutePaths || [];
    // get the absolute path of the directory which the component is sitting in
    const componentDir = normalizePath(config.sys.path.dirname(moduleFile.tsFilePath));
    // get the relative path from the component file to the style
    let componentRelativeStylePath = normalizePath(stylePath.trim());
    if (config.sys.path.isAbsolute(componentRelativeStylePath)) {
        // this path is absolute already!
        // add to our list of style absolute paths
        modeStyleMeta.absolutePaths.push(componentRelativeStylePath);
        // if this is an absolute path already, let's convert it to be relative
        componentRelativeStylePath = config.sys.path.relative(componentDir, componentRelativeStylePath);
        // add to our list of style relative paths
        modeStyleMeta.cmpRelativePaths.push(componentRelativeStylePath);
    }
    else {
        // this path is relative to the component
        // add to our list of style relative paths
        modeStyleMeta.cmpRelativePaths.push(componentRelativeStylePath);
        // create the absolute path to the style file
        const absoluteStylePath = normalizePath(config.sys.path.join(componentDir, componentRelativeStylePath));
        // add to our list of style absolute paths
        modeStyleMeta.absolutePaths.push(absoluteStylePath);
    }
}

function validateBuildConfig(config, setEnvVariables) {
    if (!config) {
        throw new Error(`invalid build config`);
    }
    if (config._isValidated) {
        // don't bother if we've already validated this config
        return config;
    }
    if (!config.logger) {
        throw new Error(`config.logger required`);
    }
    if (!config.rootDir) {
        throw new Error('config.rootDir required');
    }
    if (!config.sys) {
        throw new Error('config.sys required');
    }
    if (typeof config.namespace !== 'string') {
        config.namespace = DEFAULT_NAMESPACE;
    }
    config.namespace = validateNamespace(config.namespace);
    const path = config.sys.path;
    if (typeof config.global === 'string' && !path.isAbsolute(config.global)) {
        config.global = normalizePath(path.join(config.rootDir, config.global));
    }
    if (typeof config.src === 'string') {
        // deprecated: 2017-08-14
        console.warn(`stencil config property "src" has been renamed to "srcDir"`);
        config.srcDir = config.src;
    }
    if (typeof config.srcDir !== 'string') {
        config.srcDir = DEFAULT_SRC_DIR;
    }
    if (!path.isAbsolute(config.srcDir)) {
        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));
    }
    if (typeof config.wwwDir !== 'string') {
        config.wwwDir = DEFAULT_WWW_DIR;
    }
    if (!path.isAbsolute(config.wwwDir)) {
        config.wwwDir = normalizePath(path.join(config.rootDir, config.wwwDir));
    }
    if (typeof config.buildDir !== 'string') {
        config.buildDir = DEFAULT_BUILD_DIR;
    }
    if (!path.isAbsolute(config.buildDir)) {
        config.buildDir = normalizePath(path.join(config.wwwDir, config.buildDir));
    }
    if (typeof config.distDir !== 'string') {
        config.distDir = DEFAULT_DIST_DIR;
    }
    if (!path.isAbsolute(config.distDir)) {
        config.distDir = normalizePath(path.join(config.rootDir, config.distDir));
    }
    if (typeof config.collectionDir !== 'string') {
        config.collectionDir = DEFAULT_COLLECTION_DIR;
    }
    if (!path.isAbsolute(config.collectionDir)) {
        config.collectionDir = normalizePath(path.join(config.distDir, config.collectionDir));
    }
    if (typeof config.srcIndexHtml !== 'string') {
        config.srcIndexHtml = normalizePath(path.join(config.srcDir, DEFAULT_INDEX_HTML));
    }
    if (!path.isAbsolute(config.srcIndexHtml)) {
        config.srcIndexHtml = normalizePath(path.join(config.rootDir, config.srcIndexHtml));
    }
    if (typeof config.wwwIndexHtml !== 'string') {
        config.wwwIndexHtml = normalizePath(path.join(config.wwwDir, DEFAULT_INDEX_HTML));
    }
    if (!path.isAbsolute(config.wwwIndexHtml)) {
        config.wwwIndexHtml = normalizePath(path.join(config.rootDir, config.wwwDir));
    }
    if (typeof config.publicPath !== 'string') {
        // CLIENT SIDE ONLY! Do not use this for server-side file read/writes
        // this is a reference to the public static directory from the index.html running from a browser
        // in most cases it's just "build", as in index page would request scripts from `/build/`
        config.publicPath = normalizePath(path.relative(config.wwwDir, config.buildDir));
        if (config.publicPath.charAt(0) !== '/') {
            // ensure prefix / by default
            config.publicPath = '/' + config.publicPath;
        }
    }
    if (config.publicPath.charAt(config.publicPath.length - 1) !== '/') {
        // ensure there's a trailing /
        config.publicPath += '/';
    }
    // default devMode false
    config.devMode = !!config.devMode;
    // default watch false
    config.watch = !!config.watch;
    if (typeof config.minifyCss !== 'boolean') {
        // if no config, minify css when it's the prod build
        config.minifyCss = (!config.devMode);
    }
    config.logger.debug(`minifyCss: ${config.minifyCss}`);
    if (typeof config.minifyJs !== 'boolean') {
        // if no config, minify js when it's the prod build
        config.minifyJs = (!config.devMode);
    }
    config.logger.debug(`minifyJs: ${config.minifyJs}`);
    if (typeof config.hashFileNames !== 'boolean' && typeof config.hashFilenames === 'boolean') {
        config.hashFileNames = config.hashFilenames;
        config.logger.warn(`"hashFilenames" was used in the config, did you mean "hashFileNames"? (Has a capital N)`);
    }
    if (typeof config.hashFileNames !== 'boolean') {
        // hashFileNames config was not provided, so let's create the default
        if (config.devMode || config.watch) {
            // dev mode should not hash filenames
            // during watch rebuilds it should not hash filenames
            config.hashFileNames = false;
        }
        else {
            // prod builds should hash filenames
            config.hashFileNames = true;
        }
    }
    config.logger.debug(`hashFileNames: ${config.hashFileNames}`);
    if (typeof config.hashedFileNameLength !== 'number') {
        config.hashedFileNameLength = DEFAULT_HASHED_FILENAME_LENTH;
    }
    if (config.hashFileNames) {
        if (config.hashedFileNameLength < 4) {
            throw new Error(`config.hashedFileNameLength must be at least 4 characters`);
        }
    }
    config.logger.debug(`hashedFileNameLength: ${config.hashedFileNameLength}`);
    config.generateDistribution = !!config.generateDistribution;
    if (typeof config.generateWWW !== 'boolean') {
        config.generateWWW = true;
    }
    if (config.copy) {
        // merge user copy tasks into the default
        config.copy = Object.assign({}, DEFAULT_COPY_TASKS, config.copy);
    }
    else if (config.copy === null || config.copy === false) {
        // manually forcing to skip the copy task
        config.copy = null;
    }
    else {
        // use the default copy tasks
        config.copy = Object.assign({}, DEFAULT_COPY_TASKS);
    }
    if (!config.watchIgnoredRegex) {
        config.watchIgnoredRegex = DEFAULT_WATCH_IGNORED_REGEX;
    }
    if (typeof config.hydratedCssClass !== 'string') {
        config.hydratedCssClass = DEFAULT_HYDRATED_CSS_CLASS;
    }
    if (typeof config.es5Fallback !== 'boolean') {
        if (config.devMode) {
            // default dev mode only builds es2015
            config.es5Fallback = false;
        }
        else {
            // default prod mode builds both es2015 and es5
            config.es5Fallback = true;
        }
    }
    config.emptyDist = !!config.emptyDist;
    config.emptyWWW = !!config.emptyWWW;
    config.collections = config.collections || [];
    config.collections = config.collections.map(validateDependentCollection);
    config.bundles = config.bundles || [];
    validateUserBundles(config.bundles);
    config.exclude = config.exclude || DEFAULT_EXCLUDES;
    // set to true so it doesn't bother going through all this again on rebuilds
    config._isValidated = true;
    config.logger.debug(`validated build config`);
    if (setEnvVariables !== false) {
        setProcessEnvironment(config);
    }
    return config;
}
function validateNamespace(namespace) {
    namespace = namespace.trim();
    const invalidNamespaceChars = namespace.replace(/(\w)|(\-)|(\$)/g, '');
    if (invalidNamespaceChars !== '') {
        throw new Error(`Namespace "${namespace}" contains invalid characters: ${invalidNamespaceChars}`);
    }
    if (namespace.length < 3) {
        throw new Error(`Namespace "${namespace}" must be at least 3 characters`);
    }
    if (/^\d+$/.test(namespace.charAt(0))) {
        throw new Error(`Namespace "${namespace}" cannot have a number for the first character`);
    }
    if (namespace.charAt(0) === '-') {
        throw new Error(`Namespace "${namespace}" cannot have a dash for the first character`);
    }
    if (namespace.charAt(namespace.length - 1) === '-') {
        throw new Error(`Namespace "${namespace}" cannot have a dash for the last character`);
    }
    return namespace;
}
function setProcessEnvironment(config) {
    process.env.NODE_ENV = config.devMode ? 'development' : 'production';
}
function validateDependentCollection(userInput) {
    if (!userInput || Array.isArray(userInput) || typeof userInput === 'number' || typeof userInput === 'boolean') {
        throw new Error(`invalid collection: ${userInput}`);
    }
    let collection;
    if (typeof userInput === 'string') {
        collection = {
            name: userInput
        };
    }
    else {
        collection = userInput;
    }
    if (!collection.name || typeof collection.name !== 'string' || collection.name.trim() === '') {
        throw new Error(`missing collection name`);
    }
    collection.name = collection.name.trim();
    collection.includeBundledOnly = !!collection.includeBundledOnly;
    return collection;
}
function validateUserBundles(bundles) {
    if (!bundles) {
        throw new Error(`Invalid bundles`);
    }
    // normalize bundle component tags
    // sort by tag name and ensure they're lower case
    bundles.forEach(b => {
        if (!Array.isArray(b.components)) {
            throw new Error(`manifest missing bundle components array, instead received: ${b.components}`);
        }
        b.components = b.components.filter(c => typeof c === 'string' && c.trim().length);
        if (!b.components.length) {
            throw new Error(`No valid bundle components found within stencil config`);
        }
        b.components = b.components.map(tag => validateComponentTag(tag)).sort();
    });
    bundles.sort((a, b) => {
        if (a.components && a.components.length && b.components && b.components.length) {
            if (a.components[0].toLowerCase() < b.components[0].toLowerCase())
                return -1;
            if (a.components[0].toLowerCase() > b.components[0].toLowerCase())
                return 1;
        }
        return 0;
    });
}
function validateComponentTag(tag) {
    if (typeof tag !== 'string') {
        throw new Error(`Tag "${tag}" must be a string type`);
    }
    tag = tag.trim().toLowerCase();
    if (tag.length === 0) {
        throw new Error(`Received empty tag value`);
    }
    if (tag.indexOf(' ') > -1) {
        throw new Error(`"${tag}" tag cannot contain a space`);
    }
    if (tag.indexOf(',') > -1) {
        throw new Error(`"${tag}" tag cannot be use for multiple tags`);
    }
    let invalidChars = tag.replace(/\w|-/g, '');
    if (invalidChars !== '') {
        throw new Error(`"${tag}" tag contains invalid characters: ${invalidChars}`);
    }
    if (tag.indexOf('-') === -1) {
        throw new Error(`"${tag}" tag must contain a dash (-) to work as a valid web component`);
    }
    if (tag.indexOf('--') > -1) {
        throw new Error(`"${tag}" tag cannot contain multiple dashes (--) next to each other`);
    }
    if (tag.indexOf('-') === 0) {
        throw new Error(`"${tag}" tag cannot start with a dash (-)`);
    }
    if (tag.lastIndexOf('-') === tag.length - 1) {
        throw new Error(`"${tag}" tag cannot end with a dash (-)`);
    }
    return tag;
}
const DEFAULT_SRC_DIR = 'src';
const DEFAULT_WWW_DIR = 'www';
const DEFAULT_BUILD_DIR = 'build';
const DEFAULT_INDEX_HTML = 'index.html';
const DEFAULT_DIST_DIR = 'dist';
const DEFAULT_COLLECTION_DIR = 'collection';
const DEFAULT_NAMESPACE = 'App';
const DEFAULT_HASHED_FILENAME_LENTH = 8;
const DEFAULT_EXCLUDES = ['node_modules', 'bower_components'];
const DEFAULT_WATCH_IGNORED_REGEX = /(\.(jpg|jpeg|png|gif|woff|woff2|ttf|eot)|(?:^|[\\\/])(\.(?!\.)[^\\\/]+)$)$/i;
const DEFAULT_HYDRATED_CSS_CLASS = 'hydrated';
const DEFAULT_COPY_TASKS = {
    assets: { src: 'assets', warn: false },
    manifestJson: { src: 'manifest.json', warn: false }
};

function getComponentDecoratorData(config, moduleFile, diagnostics, classNode) {
    let metaData = null;
    if (!classNode.decorators) {
        return metaData;
    }
    let isComponent = false;
    classNode.decorators.forEach(decorator => {
        decorator.forEachChild(decoratorChild => {
            decoratorChild.forEachChild(componentChild => {
                if (componentChild.getText().trim() === 'Component') {
                    isComponent = true;
                }
                else if (isComponent) {
                    metaData = parseComponentMetaData(config, moduleFile, diagnostics, componentChild.getText());
                }
            });
        });
    });
    return metaData;
}
function parseComponentMetaData(config, moduleFile, diagnostics, text) {
    let cmpMeta = null;
    try {
        const fnStr = `return ${text};`;
        // parse user component options
        const userOpts = new Function(fnStr)();
        if (!userOpts.tag || userOpts.tag.trim() === '') {
            throw new Error(`tag missing in component decorator: ${text}`);
        }
        // convert user component options from user into component meta
        cmpMeta = {};
        // normalize user data
        normalizeTag(config, moduleFile, diagnostics, userOpts, cmpMeta, text);
        normalizeStyles(config, userOpts, moduleFile, cmpMeta);
        normalizeAssetsDir(config, userOpts, moduleFile, cmpMeta);
        normalizeHost(userOpts, cmpMeta);
        normalizeEncapsulation(userOpts, cmpMeta);
    }
    catch (e) {
        // derp
        const d = catchError(diagnostics, e);
        d.absFilePath = moduleFile.tsFilePath;
        d.relFilePath = config.sys.path.relative(config.rootDir, moduleFile.tsFilePath);
        d.messageText = `${e}: ${text}`;
    }
    return cmpMeta;
}
function normalizeTag(config, moduleFile, diagnostics, userOpts, cmpMeta, orgText) {
    if (userOpts.selector) {
        const d = buildError(diagnostics);
        d.messageText = `Please use "tag" instead of "selector" in component decorator: ${userOpts.selector}`;
        d.absFilePath = moduleFile.tsFilePath;
        d.relFilePath = config.sys.path.relative(config.rootDir, moduleFile.tsFilePath);
        cmpMeta.tagNameMeta = userOpts.selector;
    }
    if (!userOpts.tag || userOpts.tag.trim() === '') {
        throw new Error(`tag missing in component decorator: ${orgText}`);
    }
    cmpMeta.tagNameMeta = validateComponentTag(userOpts.tag);
}
function normalizeEncapsulation(userOpts, cmpMeta) {
    // default to NOT use shadow dom or scoped css...to start, debatable later on
    if (userOpts.shadow === true) {
        cmpMeta.encapsulation = 1 /* ShadowDom */;
    }
    else if (userOpts.scoped === true) {
        cmpMeta.encapsulation = 2 /* ScopedCss */;
    }
    else {
        cmpMeta.encapsulation = 0 /* NoEncapsulation */;
    }
}
function normalizeHost(userOpts, cmpMeta) {
    cmpMeta.hostMeta = userOpts.host || {};
}

function getElementDecoratorMeta(classNode) {
    const membersMeta = {};
    const decoratedMembers = classNode.members.filter(n => n.decorators && n.decorators.length);
    decoratedMembers.forEach(memberNode => {
        let isElement = false;
        let hostElementMember = null;
        memberNode.forEachChild(n => {
            if (n.kind === ts.SyntaxKind.Decorator && n.getChildCount() > 1) {
                const child = n.getChildAt(1);
                const firstToken = child.getFirstToken();
                // If the first token is @Element()
                if (firstToken && firstToken.getText() === 'Element') {
                    isElement = true;
                }
                else if (!firstToken && child.getText() === 'Element') {
                    // If the first token is @Element
                    isElement = true;
                }
            }
            else if (isElement) {
                if (n.kind === ts.SyntaxKind.Identifier && !hostElementMember) {
                    hostElementMember = n.getText();
                }
            }
        });
        if (isElement && hostElementMember) {
            membersMeta[hostElementMember] = {
                memberType: 7 /* Element */
            };
            // Remove decorator
            memberNode.decorators = undefined;
        }
    });
    return membersMeta;
}

function getEventDecoratorMeta(tsFilePath, diagnostics, classNode) {
    let eventsMeta = [];
    const decoratedMembers = classNode.members.filter(n => n.decorators && n.decorators.length);
    decoratedMembers.forEach(memberNode => {
        let isEvent = false;
        let methodName = null;
        let rawEventMeta = {};
        memberNode.forEachChild(n => {
            if (n.kind === ts.SyntaxKind.Decorator &&
                n.getChildCount() > 1 &&
                n.getChildAt(1).getFirstToken() &&
                n.getChildAt(1).getFirstToken().getText() === 'Event') {
                isEvent = true;
                n.getChildAt(1).forEachChild(n => {
                    if (n.kind === ts.SyntaxKind.ObjectLiteralExpression) {
                        try {
                            const fnStr = `return ${n.getText()};`;
                            Object.assign(rawEventMeta, new Function(fnStr)());
                        }
                        catch (e) {
                            const d = catchError(diagnostics, e);
                            d.messageText = `parse event options: ${e}`;
                            d.absFilePath = tsFilePath;
                        }
                    }
                });
            }
            else if (isEvent) {
                if (n.kind === ts.SyntaxKind.Identifier && !methodName) {
                    methodName = n.getText().trim();
                }
            }
        });
        if (isEvent && methodName) {
            let eventMeta = validateEvent(rawEventMeta, methodName);
            if (eventsMeta) {
                memberNode.decorators = undefined;
                eventsMeta.push(eventMeta);
            }
        }
    });
    return eventsMeta;
}
function validateEvent(rawEventOpts, methodName) {
    methodName = methodName.trim();
    if (!methodName) {
        return null;
    }
    const eventMeta = {
        eventMethodName: methodName,
        eventName: methodName
    };
    if (typeof rawEventOpts.eventName === 'string') {
        eventMeta.eventName = rawEventOpts.eventName;
    }
    eventMeta.eventBubbles = typeof rawEventOpts.bubbles === 'boolean' ? rawEventOpts.bubbles : true;
    eventMeta.eventCancelable = typeof rawEventOpts.cancelable === 'boolean' ? rawEventOpts.cancelable : true;
    eventMeta.eventComposed = typeof rawEventOpts.composed === 'boolean' ? rawEventOpts.composed : true;
    return eventMeta;
}

function getListenDecoratorMeta(tsFilePath, diagnostics, classNode) {
    const listenersMeta = [];
    const decoratedMembers = classNode.members.filter(n => n.decorators && n.decorators.length);
    decoratedMembers.forEach(memberNode => {
        let isListen = false;
        let methodName = null;
        let eventName = null;
        let rawListenOpts = {};
        memberNode.forEachChild(n => {
            if (n.kind === ts.SyntaxKind.Decorator &&
                n.getChildCount() > 1 &&
                n.getChildAt(1).getFirstToken() &&
                n.getChildAt(1).getFirstToken().getText() === 'Listen') {
                isListen = true;
                n.getChildAt(1).forEachChild(n => {
                    if (n.kind === ts.SyntaxKind.StringLiteral && !eventName) {
                        eventName = n.getText().replace(/\s/g, '');
                        eventName = eventName.replace(/\'/g, '');
                        eventName = eventName.replace(/\"/g, '');
                        eventName = eventName.replace(/\`/g, '');
                    }
                    else if (n.kind === ts.SyntaxKind.ObjectLiteralExpression && eventName) {
                        try {
                            const fnStr = `return ${n.getText()};`;
                            Object.assign(rawListenOpts, new Function(fnStr)());
                        }
                        catch (e) {
                            const d = catchError(diagnostics, e);
                            d.messageText = `parse listener options: ${e}`;
                            d.absFilePath = tsFilePath;
                        }
                    }
                });
            }
            else if (isListen) {
                if (n.kind === ts.SyntaxKind.Identifier && !methodName) {
                    methodName = n.getText().trim();
                }
            }
        });
        if (isListen && eventName && methodName) {
            eventName.split(',').forEach(evName => {
                const listenMeta = validateListener(tsFilePath, evName, rawListenOpts, methodName);
                if (listenMeta) {
                    listenersMeta.push(listenMeta);
                    memberNode.decorators = undefined;
                }
            });
        }
    });
    return listenersMeta.sort((a, b) => {
        if (a.eventName.toLowerCase() < b.eventName.toLowerCase())
            return -1;
        if (a.eventName.toLowerCase() > b.eventName.toLowerCase())
            return 1;
        if (a.eventMethodName.toLowerCase() < b.eventMethodName.toLowerCase())
            return -1;
        if (a.eventMethodName.toLowerCase() > b.eventMethodName.toLowerCase())
            return 1;
        return 0;
    });
}
function validateListener(tsFilePath, eventName, rawListenOpts, methodName) {
    eventName = eventName && eventName.trim();
    if (!eventName)
        return null;
    let rawEventName = eventName;
    let splt = eventName.split(':');
    if (splt.length > 2) {
        throw `@Listen can only contain one colon: ${eventName} in ${tsFilePath}`;
    }
    if (splt.length > 1) {
        let prefix = splt[0].toLowerCase().trim();
        if (!isValidElementRefPrefix(prefix)) {
            throw `invalid @Listen prefix "${prefix}" for "${eventName}" in ${tsFilePath}`;
        }
        rawEventName = splt[1].toLowerCase().trim();
    }
    splt = rawEventName.split('.');
    if (splt.length > 2) {
        throw `@Listen can only contain one period: ${eventName} in ${tsFilePath}`;
    }
    if (splt.length > 1) {
        let suffix = splt[1].toLowerCase().trim();
        if (!isValidKeycodeSuffix(suffix)) {
            throw `invalid @Listen suffix "${suffix}" for "${eventName}" in ${tsFilePath}`;
        }
        rawEventName = splt[0].toLowerCase().trim();
    }
    const listenMeta = {
        eventName: eventName,
        eventMethodName: methodName
    };
    if (typeof rawListenOpts.capture === 'boolean') {
        listenMeta.eventCapture = rawListenOpts.capture;
    }
    else {
        // default to not use capture if it wasn't provided
        listenMeta.eventCapture = false;
    }
    if (typeof rawListenOpts.passive === 'boolean') {
        listenMeta.eventPassive = rawListenOpts.passive;
    }
    else {
        // they didn't set if it should be passive or not
        // so let's figure out some good defaults depending
        // on what type of event this is
        if (PASSIVE_TRUE_DEFAULTS.indexOf(rawEventName.toLowerCase()) > -1) {
            // good list of known events that we should default to passive
            listenMeta.eventPassive = true;
        }
        else {
            // play it safe and have all others default to NOT be passive
            listenMeta.eventPassive = false;
        }
    }
    // default to enabled=true if it wasn't provided
    listenMeta.eventDisabled = (rawListenOpts.enabled === false);
    return listenMeta;
}
function isValidElementRefPrefix(prefix) {
    return (VALID_ELEMENT_REF_PREFIXES.indexOf(prefix) > -1);
}
function isValidKeycodeSuffix(prefix) {
    return (VALID_KEYCODE_SUFFIX.indexOf(prefix) > -1);
}
const PASSIVE_TRUE_DEFAULTS = [
    'dragstart', 'drag', 'dragend', 'dragenter', 'dragover', 'dragleave', 'drop',
    'mouseenter', 'mouseover', 'mousemove', 'mousedown', 'mouseup', 'mouseleave', 'mouseout', 'mousewheel',
    'pointerover', 'pointerenter', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerout', 'pointerleave',
    'resize',
    'scroll',
    'touchstart', 'touchmove', 'touchend', 'touchenter', 'touchleave', 'touchcancel',
    'wheel',
];
const VALID_ELEMENT_REF_PREFIXES = [
    'child', 'parent', 'body', 'document', 'window'
];
const VALID_KEYCODE_SUFFIX = [
    'enter', 'escape', 'space', 'tab', 'up', 'right', 'down', 'left'
];

function getMethodDecoratorMeta(classNode) {
    const membersMeta = {};
    const decoratedMembers = classNode.members.filter(n => n.decorators && n.decorators.length);
    const methodMembers = decoratedMembers.filter(n => n.kind === ts.SyntaxKind.MethodDeclaration);
    methodMembers.forEach(methodNode => {
        let isMethod = false;
        let methodName = null;
        methodNode.forEachChild(n => {
            if (n.kind === ts.SyntaxKind.Decorator && n.getChildCount() > 1 && n.getChildAt(1).getFirstToken().getText() === 'Method') {
                isMethod = true;
            }
            else if (isMethod) {
                if (n.kind === ts.SyntaxKind.Identifier && !methodName) {
                    methodName = n.getText();
                }
            }
        });
        if (isMethod && methodName) {
            membersMeta[methodName] = {
                memberType: 6 /* Method */
            };
            // Remove decorator
            methodNode.decorators = undefined;
        }
    });
    return membersMeta;
}

function getPropDecoratorMeta(tsFilePath, diagnostics, classNode, sourceFile, transformContext) {
    const decoratedMembers = classNode.members.filter(n => n.decorators && n.decorators.length);
    return decoratedMembers
        .filter((prop) => (prop.decorators.some((decorator) => decorator.getFullText().indexOf('Prop(') !== -1)))
        .reduce((allMembers, prop) => {
        const memberData = {};
        const propDecorator = prop.decorators.find((decorator) => (decorator.getFullText().indexOf('Prop(') !== -1));
        const suppliedOptions = propDecorator.expression.arguments
            .map(arg => {
            try {
                const fnStr = `return ${arg.getText()};`;
                return new Function(fnStr)();
            }
            catch (e) {
                const d = catchError(diagnostics, e);
                d.messageText = `parse prop options: ${e}`;
                d.absFilePath = tsFilePath;
            }
        });
        const propOptions = suppliedOptions[0];
        const attribName = prop.name.text;
        if (propOptions && typeof propOptions.connect === 'string') {
            memberData.memberType = 4 /* PropConnect */;
            memberData.ctrlId = propOptions.connect;
        }
        else if (propOptions && typeof propOptions.context === 'string') {
            memberData.memberType = 3 /* PropContext */;
            memberData.ctrlId = propOptions.context;
        }
        else {
            let attribType;
            // If the @Prop() attribute does not have a defined type then infer it
            if (!prop.type) {
                let attribTypeText = inferPropType(prop.initializer);
                if (!attribTypeText) {
                    attribTypeText = 'any';
                    diagnostics.push({
                        level: 'warn',
                        type: 'build',
                        header: 'Prop type provided is not supported, defaulting to any',
                        messageText: `'${prop.getFullText()}' from ${tsFilePath}`,
                        absFilePath: tsFilePath
                    });
                }
                attribType = {
                    text: attribTypeText,
                };
            }
            else {
                attribType = getAttributeTypeInfo(prop.type, sourceFile, transformContext);
            }
            if (propOptions && typeof propOptions.state === 'boolean') {
                diagnostics.push({
                    level: 'warn',
                    type: 'build',
                    header: '@Prop({ state: true }) option has been deprecated',
                    messageText: `"state" has been renamed to @Prop({ mutable: true }) ${tsFilePath}`,
                    absFilePath: tsFilePath
                });
                propOptions.mutable = propOptions.state;
            }
            if (propOptions && typeof propOptions.mutable === 'boolean') {
                memberData.memberType = 2 /* PropMutable */;
            }
            else {
                memberData.memberType = 1 /* Prop */;
            }
            memberData.attribType = attribType;
            memberData.attribName = attribName;
            memberData.propType = propTypeFromTSType(attribType.text);
        }
        allMembers[attribName] = memberData;
        prop.decorators = undefined;
        return allMembers;
    }, {});
}
function getAttributeTypeInfo(type, sourceFile, transformContext) {
    const typeInfo = {
        text: type.getFullText().trim()
    };
    const typeReferences = getAllTypeReferences(type, transformContext)
        .reduce((allReferences, rt) => {
        allReferences[rt] = getTypeReferenceLocation(rt, sourceFile);
        return allReferences;
    }, {});
    if (Object.keys(typeReferences).length > 0) {
        typeInfo.typeReferences = typeReferences;
    }
    return typeInfo;
}
function getAllTypeReferences(node, transformContext) {
    const referencedTypes = [];
    function visit(node) {
        switch (node.kind) {
            case ts.SyntaxKind.TypeReference:
                referencedTypes.push(node.typeName.getText().trim());
                if (node.typeArguments) {
                    node.typeArguments
                        .filter(ta => ts.isTypeReferenceNode(ta))
                        .forEach(tr => referencedTypes.push(tr.typeName.getText().trim()));
                }
            default:
                return ts.visitEachChild(node, (node) => {
                    return visit(node);
                }, transformContext);
        }
    }
    visit(node);
    return referencedTypes;
}
function getTypeReferenceLocation(typeName, sourceFile) {
    // Loop through all top level imports to find any reference to the type for 'import' reference location
    const importTypeDeclaration = sourceFile.statements.find(st => {
        const statement = ts.isImportDeclaration(st) &&
            ts.isImportClause(st.importClause) &&
            st.importClause.namedBindings && ts.isNamedImports(st.importClause.namedBindings) &&
            Array.isArray(st.importClause.namedBindings.elements) &&
            st.importClause.namedBindings.elements.find(nbe => nbe.name.getText() === typeName);
        if (!statement) {
            return false;
        }
        return true;
    });
    if (importTypeDeclaration) {
        return {
            referenceLocation: 'import',
            importReferenceLocation: importTypeDeclaration.moduleSpecifier.text
        };
    }
    // Loop through all top level exports to find if any reference to the type for 'local' reference location
    const isExported = sourceFile.statements.some(st => {
        // Is the interface defined in the file and exported
        const isInterfaceDeclarationExported = ((ts.isInterfaceDeclaration(st) &&
            st.name.getText() === typeName) &&
            Array.isArray(st.modifiers) &&
            st.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword));
        // Is the interface exported through a named export
        const isTypeInExportDeclaration = ts.isExportDeclaration(st) &&
            ts.isNamedExports(st.exportClause) &&
            st.exportClause.elements.some(nee => nee.name.getText() === typeName);
        return isInterfaceDeclarationExported || isTypeInExportDeclaration;
    });
    if (isExported) {
        return {
            referenceLocation: 'local'
        };
    }
    // This is most likely a global type, if it is a local that is not exported then typescript will inform the dev
    return {
        referenceLocation: 'global',
    };
}
function inferPropType(expression) {
    if (expression == null) {
        return undefined;
    }
    if (ts.isStringLiteral(expression)) {
        return 'string';
    }
    if (ts.isNumericLiteral(expression)) {
        return 'number';
    }
    if ([ts.SyntaxKind.BooleanKeyword, ts.SyntaxKind.TrueKeyword, ts.SyntaxKind.FalseKeyword].indexOf(expression.kind) !== -1) {
        return 'boolean';
    }
    if ((ts.SyntaxKind.NullKeyword === expression.kind) ||
        (ts.SyntaxKind.UndefinedKeyword === expression.kind) ||
        (ts.isRegularExpressionLiteral(expression)) ||
        (ts.isArrayLiteralExpression(expression)) ||
        (ts.isObjectLiteralExpression(expression))) {
        return 'any';
    }
    return undefined;
}
function propTypeFromTSType(type) {
    switch (type) {
        case 'string':
            return 2 /* String */;
        case 'number':
            return 4 /* Number */;
        case 'boolean':
            return 3 /* Boolean */;
        case 'any':
        default:
            return 1 /* Any */;
    }
}

function getPropChangeDecoratorMeta(classNode) {
    return {
        propsWillChangeMeta: getPropChangeDecorator(classNode, 'PropWillChange'),
        propsDidChangeMeta: getPropChangeDecorator(classNode, 'PropDidChange')
    };
}
function getPropChangeDecorator(classNode, decoratorName) {
    const decoratedMembers = classNode.members.filter(n => n.decorators && n.decorators.length);
    const propChangeMeta = [];
    decoratedMembers.forEach(memberNode => {
        let isPropChange = false;
        let propName = null;
        let methodName = null;
        memberNode.forEachChild(n => {
            if (n.kind === ts.SyntaxKind.Decorator &&
                n.getChildCount() > 1 &&
                n.getChildAt(1).getFirstToken() &&
                n.getChildAt(1).getFirstToken().getText() === decoratorName) {
                isPropChange = true;
                n.getChildAt(1).forEachChild(n => {
                    if (n.kind === ts.SyntaxKind.StringLiteral && !propName) {
                        propName = n.getText();
                        propName = propName.replace(/\'/g, '');
                        propName = propName.replace(/\"/g, '');
                        propName = propName.replace(/\`/g, '');
                    }
                });
            }
            else if (isPropChange) {
                if (n.kind === ts.SyntaxKind.Identifier && !methodName) {
                    methodName = n.getText();
                }
            }
        });
        if (isPropChange && propName && methodName) {
            const propChange = [];
            propChange[0 /* PropName */] = propName;
            propChange[1 /* MethodName */] = methodName;
            propChangeMeta.push(propChange);
            memberNode.decorators = undefined;
        }
    });
    return propChangeMeta.sort((a, b) => {
        if (a[0 /* PropName */].toLowerCase() < b[0 /* PropName */].toLowerCase())
            return -1;
        if (a[0 /* PropName */].toLowerCase() > b[0 /* PropName */].toLowerCase())
            return 1;
        if (a[1 /* MethodName */] < b[1 /* MethodName */])
            return -1;
        if (a[1 /* MethodName */] > b[1 /* MethodName */])
            return 1;
        return 0;
    });
}

function getStateDecoratorMeta(classNode) {
    const membersMeta = {};
    const decoratedMembers = classNode.members.filter(n => n.decorators && n.decorators.length);
    decoratedMembers.forEach(memberNode => {
        let isState = false;
        let propName = null;
        memberNode.forEachChild(n => {
            if (n.kind === ts.SyntaxKind.Decorator && n.getChildCount() > 1) {
                const child = n.getChildAt(1);
                const firstToken = child.getFirstToken();
                // If the first token is @State()
                if (firstToken && firstToken.getText() === 'State') {
                    isState = true;
                }
                else if (!firstToken && child.getText() === 'State') {
                    // If the first token is @State
                    isState = true;
                }
            }
            else if (isState) {
                if (n.kind === ts.SyntaxKind.Identifier && !propName) {
                    propName = n.getText();
                }
            }
        });
        if (isState && propName) {
            membersMeta[propName] = {
                memberType: 5 /* State */
            };
            memberNode.decorators = undefined;
        }
    });
    return membersMeta;
}

function componentTsFileClass(config, moduleFiles, diagnostics) {
    return (transformContext) => {
        function visit(fileMeta, node, sourceFile) {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                    return visitClass(config, fileMeta, diagnostics, node, sourceFile, transformContext);
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(fileMeta, node, sourceFile);
                    }, transformContext);
            }
        }
        return (tsSourceFile) => {
            const moduleFile = moduleFiles[tsSourceFile.fileName];
            if (moduleFile) {
                moduleFile.cmpMeta = null;
                return visit(moduleFile, tsSourceFile, tsSourceFile);
            }
            return tsSourceFile;
        };
    };
}
function visitClass(config, moduleFile, diagnostics, classNode, sourceFile, transformContext) {
    const cmpMeta = getComponentDecoratorData(config, moduleFile, diagnostics, classNode);
    if (!cmpMeta) {
        return classNode;
    }
    if (moduleFile.cmpMeta && moduleFile.cmpMeta.tagNameMeta !== cmpMeta.tagNameMeta) {
        const relPath = config.sys.path.relative(config.rootDir, moduleFile.tsFilePath);
        const d = buildError(diagnostics);
        d.messageText = `Cannot have multiple @Components in the same source file: ${relPath}`;
        d.absFilePath = moduleFile.tsFilePath;
        return classNode;
    }
    moduleFile.cmpMeta = Object.assign({}, cmpMeta, { componentClass: classNode.name.getText().trim(), membersMeta: Object.assign({}, getElementDecoratorMeta(classNode), getMethodDecoratorMeta(classNode), getStateDecoratorMeta(classNode), getPropDecoratorMeta(moduleFile.tsFilePath, diagnostics, classNode, sourceFile, transformContext)), eventsMeta: getEventDecoratorMeta(moduleFile.tsFilePath, diagnostics, classNode), listenersMeta: getListenDecoratorMeta(moduleFile.tsFilePath, diagnostics, classNode) }, getPropChangeDecoratorMeta(classNode));
    // Return Class Declaration with Decorator removed and as default export
    return updateComponentClass(classNode);
}

const METADATA_MEMBERS_TYPED = [1 /* Prop */, 2 /* PropMutable */];
/**
 * Find all referenced types by a component and add them to the importDataObj and return the newly
 * updated importDataObj
 *
 * @param importDataObj key/value of type import file, each value is an array of imported types
 * @param cmpMeta the metadata for the component that is referencing the types
 * @param filePath the path of the component file
 * @param config general config that all of stencil uses
 */
function updateReferenceTypeImports(importDataObj, allTypes, cmpMeta, filePath, config) {
    function getIncrememntTypeName(name) {
        if (allTypes[name] == null) {
            allTypes[name] = 1;
            return name;
        }
        allTypes[name] += 1;
        return `${name}${allTypes[name]}`;
    }
    return Object.keys(cmpMeta.membersMeta)
        .filter((memberName) => {
        const member = cmpMeta.membersMeta[memberName];
        return METADATA_MEMBERS_TYPED.indexOf(member.memberType) !== -1 &&
            member.attribType.typeReferences;
    })
        .reduce((obj, memberName) => {
        const member = cmpMeta.membersMeta[memberName];
        Object.keys(member.attribType.typeReferences).forEach(typeName => {
            var type = member.attribType.typeReferences[typeName];
            let importFileLocation;
            // If global then there is no import statement needed
            if (type.referenceLocation === 'global') {
                return;
                // If local then import location is the current file
            }
            else if (type.referenceLocation === 'local') {
                importFileLocation = filePath;
            }
            else if (type.referenceLocation === 'import') {
                importFileLocation = type.importReferenceLocation;
            }
            // If this is a relative path make it absolute
            if (importFileLocation.startsWith('.')) {
                importFileLocation = normalizePath(config.sys.path.resolve(config.sys.path.dirname(filePath), importFileLocation));
            }
            obj[importFileLocation] = obj[importFileLocation] || [];
            // If this file already has a reference to this type move on
            if (obj[importFileLocation].find(df => df.localName === typeName)) {
                return;
            }
            const newTypeName = getIncrememntTypeName(typeName);
            obj[importFileLocation].push({
                localName: typeName,
                importName: newTypeName
            });
        });
        return obj;
    }, importDataObj);
}
/**
 * Generate a string based on the types that are defined within a component.
 *
 * @param cmpMeta the metadata for the component that a type definition string is generated for
 * @param importPath the path of the component file
 */
function createTypesAsString(cmpMeta, importPath) {
    const tagName = cmpMeta.tagNameMeta;
    const tagNameAsPascal = dashToPascalCase(cmpMeta.tagNameMeta);
    const interfaceName = `HTML${tagNameAsPascal}Element`;
    const jsxInterfaceName = `${tagNameAsPascal}Attributes`;
    const interfaceOptions = membersToInterfaceOptions(cmpMeta.membersMeta);
    cmpMeta.membersMeta;
    return `
import {
  ${cmpMeta.componentClass} as ${dashToPascalCase(cmpMeta.tagNameMeta)}
} from './${importPath}';

declare global {
  interface ${interfaceName} extends ${tagNameAsPascal}, HTMLElement {
  }
  var ${interfaceName}: {
    prototype: ${interfaceName};
    new (): ${interfaceName};
  };
  interface HTMLElementTagNameMap {
    "${tagName}": ${interfaceName};
  }
  interface ElementTagNameMap {
    "${tagName}": ${interfaceName};
  }
  namespace JSX {
    interface IntrinsicElements {
      "${tagName}": JSXElements.${jsxInterfaceName};
    }
  }
  namespace JSXElements {
    export interface ${jsxInterfaceName} extends HTMLAttributes {
      ${Object.keys(interfaceOptions).map((key) => `
        ${key}?: ${interfaceOptions[key]}`)}
    }
  }
}
`;
}
function membersToInterfaceOptions(membersMeta) {
    const interfaceData = Object.keys(membersMeta)
        .filter((memberName) => {
        return METADATA_MEMBERS_TYPED.indexOf(membersMeta[memberName].memberType) !== -1;
    })
        .reduce((obj, memberName) => {
        const member = membersMeta[memberName];
        obj[memberName] = member.attribType.text;
        return obj;
    }, {});
    return interfaceData;
}

function updateFileMetaFromSlot(moduleFiles) {
    return (transformContext) => {
        return (tsSourceFile) => {
            return visit(tsSourceFile.fileName, tsSourceFile);
        };
        function visit(fileName, node) {
            switch (node.kind) {
                case ts.SyntaxKind.CallExpression:
                    const fileMeta = updateFileMeta(node, moduleFiles[fileName]);
                    if (fileMeta) {
                        moduleFiles[fileName] = fileMeta;
                    }
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(fileName, node);
                    }, transformContext);
            }
        }
    };
}

function updateFileMeta(callNode, fileMeta) {
    if (fileMeta && callNode.expression.text === 'h') {
        const [tag, props] = callNode.arguments;
        if (tag && typeof tag.text === 'string') {
            const tagName = tag.text.trim().toLowerCase();
            if (tagName === 'slot') {
                return updateFileMetaWithSlots(fileMeta, props);
            }
        }
    }
    return null;
}
function updateFileMetaWithSlots(fileMeta, props) {
    // checking if there is a default slot and/or named slots in the compiler
    // so that during runtime there is less work to do
    if (!fileMeta || !fileMeta.cmpMeta) {
        return fileMeta;
    }
    if (fileMeta.cmpMeta.slotMeta === undefined) {
        fileMeta.cmpMeta.slotMeta = 1 /* HasSlots */;
    }
    if (props && props.kind === ts.SyntaxKind.ObjectLiteralExpression) {
        const jsxAttrs = objectLiteralToObjectMap(props);
        for (var attrName in jsxAttrs) {
            if (attrName.toLowerCase().trim() === 'name') {
                var attrValue = jsxAttrs[attrName].text.trim();
                if (attrValue.length > 0) {
                    fileMeta.cmpMeta.slotMeta = 2 /* HasNamedSlots */;
                    break;
                }
            }
        }
    }
    return fileMeta;
}

// same as the "declare" variables in the root index.ts file
const REMOVE_GLOBALS = [
    'Component',
    'Element',
    'Event',
    'h',
    'Listen',
    'Method',
    'Prop',
    'PropDidChange',
    'PropWillChange',
    'State'
];
function removeImports() {
    return (transformContext) => {
        function visitImport(importNode) {
            if (!importNode.importClause || typeof importNode.importClause.namedBindings === 'undefined') {
                return ts.visitEachChild(importNode, visit, transformContext);
            }
            const importSpecifiers = [];
            importNode.importClause.namedBindings.forEachChild(nb => {
                if (nb.kind === ts.SyntaxKind.ImportSpecifier) {
                    const importSpecifier = nb;
                    if (REMOVE_GLOBALS.indexOf(importSpecifier.name.text) === -1) {
                        importSpecifiers.push(importSpecifier);
                    }
                }
            });
            const namedImports = ts.createNamedImports(importSpecifiers);
            const newImportClause = ts.updateImportClause(importNode.importClause, importNode.importClause.name, namedImports);
            return ts.updateImportDeclaration(importNode, importNode.decorators, importNode.modifiers, newImportClause, importNode.moduleSpecifier);
        }
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.ImportDeclaration:
                    return visitImport(node);
                default:
                    return ts.visitEachChild(node, visit, transformContext);
            }
        }
        return (tsSourceFile) => {
            return visit(tsSourceFile);
        };
    };
}

const LIFECYCLE_MAP = {
    'ionViewWillLoad': 'componentWillLoad',
    'ionViewDidLoad': 'componentDidLoad',
    'ionViewDidUnload': 'componentDidUnload',
    'ionViewWillUpdate': 'componentWillUpdate',
    'ionViewDidUpdate': 'componentDidUpdate',
};
function renameLifecycleMethods() {
    return (transformContext) => {
        function visitMethod(methodNode) {
            let methodName = null;
            methodNode.forEachChild(n => {
                if (n.kind === ts.SyntaxKind.Identifier && !methodName) {
                    methodName = n.getText();
                    return;
                }
            });
            const newName = LIFECYCLE_MAP[methodName];
            if (newName) {
                return ts.updateMethod(methodNode, methodNode.decorators, methodNode.modifiers, methodNode.asteriskToken, ts.createLiteral(newName), methodNode.questionToken, methodNode.typeParameters, methodNode.parameters, methodNode.type, methodNode.body);
            }
            return methodNode;
        }
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.MethodDeclaration:
                    return visitMethod(node);
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(node);
                    }, transformContext);
            }
        }
        return (tsSourceFile) => {
            return visit(tsSourceFile);
        };
    };
}

function transpileFiles(config, ctx, moduleFiles) {
    const transpileResults = {
        moduleFiles: {}
    };
    return Promise.resolve().then(() => {
        // transpiling is synchronous
        transpileModules(config, ctx, moduleFiles, transpileResults);
        if (hasError(ctx.diagnostics)) {
            // looks like we've got some transpile errors
            // let's not continue with processing included styles
            return Promise.resolve([]);
        }
        // get a list of all the files names that were transpiled
        const transpiledFileNames = Object.keys(transpileResults.moduleFiles);
        return Promise.all(transpiledFileNames.map(transpiledFileName => {
            const moduleFile = transpileResults.moduleFiles[transpiledFileName];
            return processIncludedStyles(config, ctx, moduleFile);
        }));
    }).catch(err => {
        catchError(ctx.diagnostics, err);
    }).then(() => {
        return transpileResults;
    });
}

/**
 * Generate the component.d.ts file that contains types for all components and add to the ctx.filesToWrite array
 * @param config the project build configuration
 * @param ctx build context
 * @param options compiler options from tsconfig
 */
function generateComponentTypesFile(config, ctx) {
    let typeImportData = {};
    const allTypes = {};
    let componentsFileContent = `/**
 * This is an autogenerated file created by the Stencil build process.
 * It contains typing information for all components that exist in this project
 * and imports for stencil collections that might be configured in your stencil.config.js file
 */\n\n`;
    componentsFileContent = config.collections.reduce((finalString, compCollection) => {
        return finalString + `import '${compCollection.name}';\n\n`;
    }, componentsFileContent);
    const componentFileString = Object.keys(ctx.moduleFiles).sort().reduce((finalString, moduleFileName) => {
        const moduleFile = ctx.moduleFiles[moduleFileName];
        if (moduleFile.cmpMeta) {
            const importPath = normalizePath(config.sys.path
                .relative(config.collectionDir, moduleFile.jsFilePath)
                .replace(/\.js$/, ''));
            typeImportData = updateReferenceTypeImports(typeImportData, allTypes, moduleFile.cmpMeta, moduleFile.jsFilePath, config);
            finalString +=
                `${createTypesAsString(moduleFile.cmpMeta, importPath)}\n`;
        }
        return finalString;
    }, '');
    const typeImportString = Object.keys(typeImportData).reduce((finalString, filePath) => {
        const typeData = typeImportData[filePath];
        let importFilePath;
        if (filePath.startsWith('.') || filePath.startsWith('/')) {
            importFilePath = './' + normalizePath(config.sys.path.relative(config.collectionDir, filePath)).replace(/\.js$/, '');
        }
        else {
            importFilePath = filePath;
        }
        finalString +=
            `import {
${typeData.map(td => {
                if (td.localName === td.importName) {
                    return `  ${td.importName},`;
                }
                else {
                    return `  ${td.localName} as ${td.importName},`;
                }
            }).join('\n')}
} from '${importFilePath}';\n`;
        return finalString;
    }, '');
    componentsFileContent += typeImportString + componentFileString;
    if (ctx.appFiles.components_d_ts === componentsFileContent) {
        // the components.d.ts file is unchanged, no need to resave
        return;
    }
    // cache this for rebuilds to avoid unnecessary writes
    ctx.appFiles.components_d_ts = componentsFileContent;
    const rootFilePath = config.sys.path.join(config.srcDir, 'components.d.ts');
    ctx.filesToWrite[rootFilePath] = componentsFileContent;
}
function transpileModules(config, ctx, moduleFiles, transpileResults) {
    if (ctx.isChangeBuild) {
        // if this is a change build, then narrow down
        moduleFiles = getChangeBuildModules(ctx, moduleFiles);
    }
    const tsFileNames = Object.keys(moduleFiles);
    if (!tsFileNames.length) {
        // don't bother if there are no ts files to transpile
        return;
    }
    // fire up the typescript program
    let timespace = config.logger.createTimeSpan('transpile es2015 start', true);
    transpileProgram(config, ctx, tsFileNames, transpileResults);
    timespace.finish(`transpile es2015 finished`);
    // Generate d.ts files for component types
    generateComponentTypesFile(config, ctx);
}
function transpileProgram(config, ctx, tsFileNames, transpileResults) {
    // get the tsconfig compiler options we'll use
    const tsOptions = getUserTsConfig(config);
    if (config.suppressTypeScriptErrors) {
        // suppressTypeScriptErrors mainly for unit testing
        tsOptions.lib = [];
    }
    // get the ts compiler host we'll use, which patches file operations
    // with our in-memory file system
    const tsHost = getTsHost(config, ctx, tsOptions, transpileResults);
    // fire up the typescript program
    const program = ts.createProgram(tsFileNames, tsOptions, tsHost);
    // this is the big one, let's go ahead and kick off the transpiling
    program.emit(undefined, tsHost.writeFile, undefined, false, {
        before: [
            componentTsFileClass(config, ctx.moduleFiles, ctx.diagnostics),
            removeImports(),
            renameLifecycleMethods()
        ],
        after: [
            updateFileMetaFromSlot(ctx.moduleFiles)
        ]
    });
    // keep track of how many files we transpiled (great for debugging/testing)
    ctx.transpileBuildCount = Object.keys(transpileResults.moduleFiles).length;
    if (!config.suppressTypeScriptErrors) {
        // suppressTypeScriptErrors mainly for unit testing
        const tsDiagnostics = [];
        program.getSyntacticDiagnostics().forEach(d => tsDiagnostics.push(d));
        program.getSemanticDiagnostics().forEach(d => tsDiagnostics.push(d));
        program.getOptionsDiagnostics().forEach(d => tsDiagnostics.push(d));
        loadTypeScriptDiagnostics(config.rootDir, ctx.diagnostics, tsDiagnostics);
    }
}
function getChangeBuildModules(ctx, moduleFiles) {
    const changeModuleFiles = {};
    const tsFileNames = Object.keys(moduleFiles);
    tsFileNames.forEach(tsFileName => {
        const moduleFile = moduleFiles[tsFileName];
        if (moduleFile.tsFilePath.indexOf('.d.ts') > -1) {
            // don't bother for d.ts files
            return;
        }
        if (typeof ctx.jsFiles[moduleFile.jsFilePath] !== 'string') {
            // only add it to our collection when there is no jsText
            changeModuleFiles[tsFileName] = moduleFile;
        }
    });
    return changeModuleFiles;
}
function processIncludedStyles(config, ctx, moduleFile) {
    if (ctx.isChangeBuild && !ctx.changeHasSass && !ctx.changeHasCss) {
        // this is a change, but it's not for any styles so don't bother
        return Promise.resolve([]);
    }
    if (!moduleFile.cmpMeta || !moduleFile.cmpMeta.stylesMeta) {
        // module isn't a component or the component doesn't have styles, so don't bother
        return Promise.resolve([]);
    }
    const promises = [];
    // loop through each of the style paths and see if there are any sass files
    // for each sass file let's figure out which source sass files it uses
    const modeNames = Object.keys(moduleFile.cmpMeta.stylesMeta);
    modeNames.forEach(modeName => {
        const modeMeta = moduleFile.cmpMeta.stylesMeta[modeName];
        if (modeMeta.absolutePaths) {
            modeMeta.absolutePaths.forEach(absoluteStylePath => {
                if (isSassFile(absoluteStylePath)) {
                    // this componet mode has a sass file, let's see which
                    // sass files are included in it
                    promises.push(getIncludedSassFiles(config, ctx.diagnostics, moduleFile, absoluteStylePath));
                }
            });
        }
    });
    return Promise.all(promises);
}
function getIncludedSassFiles(config, diagnostics, moduleFile, scssFilePath) {
    return new Promise(resolve => {
        scssFilePath = normalizePath(scssFilePath);
        const sassConfig = Object.assign({}, config.sassConfig, { file: scssFilePath });
        moduleFile.includedSassFiles = moduleFile.includedSassFiles || [];
        if (moduleFile.includedSassFiles.indexOf(scssFilePath) === -1) {
            moduleFile.includedSassFiles.push(scssFilePath);
        }
        config.sys.sass.render(sassConfig, (err, result) => {
            if (err) {
                const d = buildError(diagnostics);
                d.messageText = err.message;
                d.absFilePath = err.file;
            }
            else if (result.stats && result.stats.includedFiles) {
                result.stats.includedFiles.forEach((includedFile) => {
                    includedFile = normalizePath(includedFile);
                    if (moduleFile.includedSassFiles.indexOf(includedFile) === -1) {
                        moduleFile.includedSassFiles.push(includedFile);
                    }
                });
            }
            resolve();
        });
    });
}

function compileSrcDir(config, ctx) {
    const logger = config.logger;
    const compileResults = {
        moduleFiles: {},
        includedSassFiles: []
    };
    if (hasError(ctx.diagnostics)) {
        return Promise.resolve(compileResults);
    }
    const timeSpan = config.logger.createTimeSpan(`compile started`);
    logger.debug(`compileDirectory, srcDir: ${config.srcDir}`);
    return scanDir(config, ctx, config.srcDir, compileResults).then(() => {
        return transpileFiles(config, ctx, compileResults.moduleFiles);
    }).then(transpileResults => {
        if (transpileResults.moduleFiles) {
            Object.keys(transpileResults.moduleFiles).forEach(tsFilePath => {
                const moduleFile = transpileResults.moduleFiles[tsFilePath];
                compileResults.moduleFiles[tsFilePath] = moduleFile;
                if (config.generateDistribution && typeof ctx.jsFiles[moduleFile.jsFilePath] === 'string') {
                    ctx.filesToWrite[moduleFile.jsFilePath] = ctx.jsFiles[moduleFile.jsFilePath];
                }
                if (moduleFile.includedSassFiles) {
                    moduleFile.includedSassFiles.forEach(includedSassFile => {
                        if (compileResults.includedSassFiles.indexOf(includedSassFile) === -1) {
                            compileResults.includedSassFiles.push(includedSassFile);
                        }
                    });
                }
            });
        }
    }).then(() => {
        return copySourceSassFilesToDest(config, ctx, compileResults);
    }).catch(err => {
        catchError(ctx.diagnostics, err);
    }).then(() => {
        timeSpan.finish(`compile finished`);
        return compileResults;
    });
}
function scanDir(config, ctx, dir, compileResults) {
    return new Promise(resolve => {
        // loop through this directory and sub directories looking for
        // files that need to be transpiled
        const sys = config.sys;
        dir = normalizePath(dir);
        sys.fs.readdir(dir, (err, files) => {
            if (err) {
                resolve();
                return;
            }
            const promises = [];
            files.forEach(dirItem => {
                // let's loop through each of the files we've found so far
                const readPath = sys.path.join(dir, dirItem);
                if (!isValidDirectory(config.exclude, readPath)) {
                    // don't bother continuing for invalid directories
                    return;
                }
                promises.push(new Promise(resolve => {
                    sys.fs.stat(readPath, (err, stats) => {
                        if (err) {
                            // derp, not sure what's up here, let's just print out the error
                            catchError(ctx.diagnostics, err);
                            resolve();
                        }
                        else if (stats.isDirectory()) {
                            // looks like it's yet another directory
                            // let's keep drilling down
                            scanDir(config, ctx, readPath, compileResults).then(() => {
                                resolve();
                            });
                        }
                        else if (isTsFile(readPath)) {
                            // woot! we found a typescript file that needs to be transpiled
                            // let's send this over to our worker manager who can
                            // then assign a worker to this exact file
                            getModuleFile(config, ctx, readPath).then(moduleFile => {
                                compileResults.moduleFiles[moduleFile.tsFilePath] = moduleFile;
                                resolve();
                            });
                        }
                        else {
                            // idk, don't care, just resolve
                            resolve();
                        }
                    });
                }));
            });
            Promise.all(promises).then(() => {
                // cool, all the recursive scan directories have finished
                // let this resolve and start bubbling up the resolves
                resolve();
            });
        });
    });
}
function copySourceSassFilesToDest(config, ctx, compileResults) {
    if (!config.generateDistribution) {
        return Promise.resolve();
    }
    const sys = config.sys;
    return Promise.all(compileResults.includedSassFiles.map(sassSrcPath => {
        sassSrcPath = normalizePath(sassSrcPath);
        return readFile(sys, sassSrcPath).then(sassSrcText => {
            const includeDir = sassSrcPath.indexOf(config.srcDir) === 0;
            let sassDestPath;
            if (includeDir) {
                sassDestPath = normalizePath(sys.path.join(config.collectionDir, sys.path.relative(config.srcDir, sassSrcPath)));
            }
            else {
                sassDestPath = normalizePath(sys.path.join(config.rootDir, sys.path.relative(config.rootDir, sassSrcPath)));
            }
            ctx.filesToWrite[sassDestPath] = sassSrcText;
        });
    }));
}
function isValidDirectory(exclude, filePath) {
    for (var i = 0; i < exclude.length; i++) {
        if (filePath.indexOf(exclude[i]) > -1) {
            return false;
        }
    }
    return true;
}

function copyTasks(config, ctx) {
    if (!config.copy) {
        config.logger.debug(`copy tasks disabled`);
        return Promise.resolve();
    }
    if (!config.generateWWW) {
        return Promise.resolve();
    }
    if (ctx.isRebuild) {
        return Promise.resolve();
    }
    const timeSpan = config.logger.createTimeSpan(`copyTasks started`, true);
    const allCopyTasks = [];
    const copyTasks = Object.keys(config.copy).map(copyTaskName => config.copy[copyTaskName]);
    return Promise.all(copyTasks.map(copyTask => {
        return processCopyTasks(config, allCopyTasks, copyTask);
    })).then(() => {
        const ensureDirectories = [];
        allCopyTasks.forEach(ct => {
            const dest = ct.isDirectory ? ct.dest : config.sys.path.dirname(ct.dest);
            if (ensureDirectories.indexOf(dest) === -1) {
                ensureDirectories.push(dest);
            }
        });
        return ensureDirectoriesExist(config.sys, ensureDirectories, [config.rootDir]);
    }).then(() => {
        return Promise.all(allCopyTasks.map(copyTask => {
            return config.sys.copy(copyTask.src, copyTask.dest, { filter: copyTask.filter });
        }));
    }).catch(err => {
        catchError(ctx.diagnostics, err);
    }).then(() => {
        timeSpan.finish(`copyTasks finished`);
    });
}
function processCopyTasks(config, allCopyTasks, copyTask) {
    if (!copyTask) {
        // possible null was set, which is fine, just skip over this one
        return Promise.resolve(null);
    }
    if (!copyTask.src) {
        throw new Error(`copy missing "src" property`);
    }
    if (copyTask.dest && config.sys.isGlob(copyTask.dest)) {
        throw new Error(`copy "dest" property cannot be a glob: ${copyTask.dest}`);
    }
    if (config.sys.isGlob(copyTask.src)) {
        return processGlob(config, copyTask).then(copyTasks => {
            allCopyTasks.push(...copyTasks);
        });
    }
    const processedCopyTask = processCopyTask(config, copyTask);
    return new Promise(resolve => {
        config.sys.fs.stat(processedCopyTask.src, (err, stats) => {
            if (err) {
                if (copyTask.warn !== false) {
                    config.logger.warn(`copy, ${processedCopyTask.src}: ${err}`);
                }
                resolve();
            }
            else {
                processedCopyTask.isDirectory = stats.isDirectory();
                config.logger.debug(`copy, ${processedCopyTask.src} to ${processedCopyTask.dest}, isDirectory: ${processedCopyTask.isDirectory}`);
                allCopyTasks.push(processedCopyTask);
                resolve();
            }
        });
    });
}
function processGlob(config, copyTask) {
    const globOpts = {
        cwd: config.srcDir,
        nodir: true
    };
    return config.sys.glob(copyTask.src, globOpts).then(files => {
        return files.map(globRelPath => {
            return getGlobCopyTask(config, copyTask, globRelPath);
        });
    });
}
function getGlobCopyTask(config, copyTask, globRelPath) {
    let dest;
    if (copyTask.dest) {
        if (config.sys.path.isAbsolute(copyTask.dest)) {
            dest = config.sys.path.join(copyTask.dest, config.sys.path.basename(globRelPath));
        }
        else {
            dest = config.sys.path.join(config.wwwDir, copyTask.dest, config.sys.path.basename(globRelPath));
        }
    }
    else {
        dest = config.sys.path.join(config.wwwDir, globRelPath);
    }
    const processedCopyTask = {
        src: config.sys.path.join(config.srcDir, globRelPath),
        dest: dest,
        filter: copyTask.filter
    };
    return processedCopyTask;
}
function processCopyTask(config, copyTask) {
    const processedCopyTask = {
        src: getSrcAbsPath(config, copyTask.src),
        dest: getDestAbsPath(config, copyTask.src, copyTask.dest),
        filter: copyTask.filter
    };
    return processedCopyTask;
}
function getSrcAbsPath(config, src) {
    if (config.sys.path.isAbsolute(src)) {
        return src;
    }
    return config.sys.path.join(config.srcDir, src);
}
function getDestAbsPath(config, src, dest) {
    if (dest) {
        if (config.sys.path.isAbsolute(dest)) {
            return dest;
        }
        else {
            return config.sys.path.join(config.wwwDir, dest);
        }
    }
    if (config.sys.path.isAbsolute(src)) {
        throw new Error(`copy task, "to" property must exist if "from" property is an absolute path: ${src}`);
    }
    return config.sys.path.join(config.wwwDir, src);
}

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function writeBuildFiles(config, ctx, buildResults) {
    // serialize and write the manifest file if need be
    writeAppManifest(config, ctx, buildResults);
    buildResults.files = Object.keys(ctx.filesToWrite).sort();
    const totalFilesToWrite = buildResults.files.length;
    const timeSpan = config.logger.createTimeSpan(`writePhase started, fileUpdates: ${totalFilesToWrite}`, true);
    // create a copy of all the files to write
    const filesToWrite = Object.assign({}, ctx.filesToWrite);
    // clear out the files to write object for the next build
    ctx.filesToWrite = {};
    // 1) destination directory has already been emptied earlier in the build
    // 2) write all of the files
    // 3) copy all of the assets
    // not doing write and copy at the same time incase they
    // both try to create the same directory at the same time
    return writeFiles(config.sys, config.rootDir, filesToWrite).catch(err => {
        catchError(ctx.diagnostics, err);
    }).then(() => {
        // kick off copying component assets
        // and copy www/build to dist/ if generateDistribution is enabled
        return Promise.all([
            copyComponentAssets(config, ctx),
            generateDistribution(config, ctx)
        ]);
    }).then(() => {
        timeSpan.finish(`writePhase finished`);
    });
}
function generateDistribution(config, ctx) {
    if (!config.generateDistribution) {
        // don't bother
        return Promise.resolve();
    }
    return Promise.all([
        readPackageJson(config, ctx.diagnostics),
        copySourceCollectionComponentsToDistribution(config, ctx),
        generatePackageModuleResolve(config)
    ]);
}
function readPackageJson(config, diagnostics) {
    const packageJsonPath = config.sys.path.join(config.rootDir, 'package.json');
    return new Promise((resolve, reject) => {
        config.sys.fs.readFile(packageJsonPath, 'utf-8', (err, packageJsonText) => {
            if (err) {
                reject(`Missing "package.json" file for distribution: ${packageJsonPath}`);
                return;
            }
            try {
                const packageJsonData = JSON.parse(packageJsonText);
                validatePackageJson(config, diagnostics, packageJsonData);
                resolve();
            }
            catch (e) {
                reject(e);
            }
        });
    });
}
function validatePackageJson(config, diagnostics, data) {
    validatePackageFiles(config, diagnostics, data);
    const main = normalizePath(config.sys.path.join(config.sys.path.relative(config.rootDir, config.collectionDir), 'index.js'));
    if (!data.main || normalizePath(data.main) !== main) {
        const err = buildError(diagnostics);
        err.header = `package.json error`;
        err.messageText = `package.json "main" property is required when generating a distribution and must be set to: ${main}`;
    }
    const types = normalizePath(config.sys.path.join(config.sys.path.relative(config.rootDir, config.collectionDir), 'index.d.ts'));
    if (!data.types || normalizePath(data.types) !== types) {
        const err = buildError(diagnostics);
        err.header = `package.json error`;
        err.messageText = `package.json "types" property is required when generating a distribution and must be set to: ${types}`;
    }
    const browser = normalizePath(config.sys.path.join(config.sys.path.relative(config.rootDir, config.distDir), getAppFileName(config) + '.js'));
    if (!data.browser || normalizePath(data.browser) !== browser) {
        const err = buildError(diagnostics);
        err.header = `package.json error`;
        err.messageText = `package.json "browser" property is required when generating a distribution and must be set to: ${browser}`;
    }
    const collection = normalizePath(config.sys.path.join(config.sys.path.relative(config.rootDir, config.collectionDir), COLLECTION_MANIFEST_FILE_NAME));
    if (!data.collection || normalizePath(data.collection) !== collection) {
        const err = buildError(diagnostics);
        err.header = `package.json error`;
        err.messageText = `package.json "collection" property is required when generating a distribution and must be set to: ${collection}`;
    }
    if (typeof config.namespace !== 'string' || config.namespace.toLowerCase().trim() === 'app') {
        const err = buildWarn(diagnostics);
        err.header = `config warning`;
        err.messageText = `When generating a distribution it is recommended to choose a unique namespace, which can be updated in the stencil.config.js file.`;
    }
}
function validatePackageFiles(config, diagnostics, packageJsonData) {
    if (packageJsonData.files) {
        const actualDistDir = normalizePath(config.sys.path.relative(config.rootDir, config.distDir));
        const validPaths = [
            `${actualDistDir}`,
            `${actualDistDir}/`,
            `./${actualDistDir}`,
            `./${actualDistDir}/`
        ];
        const containsDistDir = packageJsonData.files
            .some(userPath => validPaths.some(validPath => normalizePath(userPath) === validPath));
        if (!containsDistDir) {
            const err = buildError(diagnostics);
            err.header = `package.json error`;
            err.messageText = `package.json "files" array must contain the distribution directory "${actualDistDir}/" when generating a distribution.`;
        }
    }
}
function generatePackageModuleResolve(config) {
    return __awaiter$1(this, void 0, void 0, function* () {
        const PromiseList = [];
        const packageResolver = config.sys.path.join(config.collectionDir, 'index.js');
        // If index.d.ts file exists at the root then copy it.
        try {
            let indexDtsContent = yield readFile(config.sys, config.sys.path.join(config.srcDir, 'index.d.ts'));
            if (typeof indexDtsContent === 'string') {
                indexDtsContent = indexDtsContent.trim();
                if (indexDtsContent.length) {
                    // don't bother copying this file if there is no content
                    PromiseList.push(config.sys.copy(config.sys.path.join(config.srcDir, 'index.d.ts'), config.sys.path.join(config.collectionDir, 'index.d.ts')));
                }
            }
        }
        catch (e) { }
        PromiseList.push(config.sys.copy(config.sys.path.join(config.srcDir, 'components.d.ts'), config.sys.path.join(config.collectionDir, 'components.d.ts')));
        PromiseList.push(new Promise((resolve, reject) => {
            config.sys.fs.writeFile(packageResolver, '', err => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        }));
        return Promise.all(PromiseList);
    });
}
function copySourceCollectionComponentsToDistribution(config, ctx) {
    // for any components that are dependencies, such as ionicons is a dependency of ionic
    // then we need to copy the dependency to the dist so it just works downstream
    const promises = [];
    ctx.manifest.modulesFiles.forEach(moduleFile => {
        if (!moduleFile.isCollectionDependency || !moduleFile.originalCollectionComponentPath)
            return;
        const src = moduleFile.jsFilePath;
        const dest = config.sys.path.join(config.collectionDir, COLLECTION_DEPENDENCIES_DIR, moduleFile.originalCollectionComponentPath);
        const copyPromise = config.sys.copy(src, dest);
        promises.push(copyPromise);
    });
    return Promise.all(promises);
}
function emptyDestDir(config, ctx) {
    // empty promises :(
    const emptyPromises = [];
    if (!ctx.isRebuild) {
        // don't bother emptying the directories when it's a rebuild
        if (config.generateWWW && !config.emptyWWW) {
            config.logger.debug(`empty buildDir: ${config.buildDir}`);
            emptyPromises.push(config.sys.emptyDir(config.buildDir));
        }
        if (config.generateDistribution && !config.emptyDist) {
            config.logger.debug(`empty distDir: ${config.distDir}`);
            emptyPromises.push(config.sys.emptyDir(config.distDir));
        }
    }
    // let's empty out the build dest directory
    return Promise.all(emptyPromises);
}

function buildCoreContent(config, ctx, coreBuild, coreContent) {
    const transpileResults = transpileCoreBuild(coreBuild, coreContent);
    if (transpileResults.diagnostics && transpileResults.diagnostics.length) {
        ctx.diagnostics.push(...transpileResults.diagnostics);
        return coreContent;
    }
    coreContent = transpileResults.code;
    const sourceTarget = coreBuild.es5 ? 'es5' : 'es2015';
    const minifyResults = minifyCore(config, sourceTarget, coreContent);
    if (minifyResults.diagnostics && minifyResults.diagnostics.length) {
        ctx.diagnostics.push(...minifyResults.diagnostics);
        return coreContent;
    }
    return minifyResults.output;
}
function minifyCore(config, sourceTarget, input) {
    const opts = Object.assign({}, config.minifyJs ? PROD_MINIFY_OPTS : DEV_MINIFY_OPTS);
    if (sourceTarget === 'es5') {
        opts.ecma = 5;
        opts.output.ecma = 5;
        opts.compress.ecma = 5;
        opts.compress.arrows = false;
    }
    opts.compress.toplevel = true;
    if (config.minifyJs) {
        if (sourceTarget !== 'es5') {
            opts.compress.arrows = true;
        }
        opts.mangle.properties.reserved = RESERVED_PROPERTIES.slice();
        if (config.logLevel === 'debug') {
            // if in debug mode, still mangle the property names
            // but at least make them readable of what the
            // properties originally were named
            opts.mangle.properties.debug = true;
            opts.mangle.keep_fnames = true;
            opts.compress.drop_console = false;
            opts.compress.drop_debugger = false;
            opts.output.beautify = true;
            opts.output.bracketize = true;
            opts.output.indent_level = 2;
            opts.output.comments = 'all';
            opts.output.preserve_line = true;
        }
    }
    return config.sys.minifyJs(input, opts);
}
// Documentation of uglify options: https://github.com/mishoo/UglifyJS2
const DEV_MINIFY_OPTS = {
    compress: {
        arrows: false,
        booleans: false,
        cascade: false,
        collapse_vars: false,
        comparisons: false,
        conditionals: true,
        dead_code: true,
        drop_console: false,
        drop_debugger: false,
        evaluate: true,
        expression: false,
        hoist_funs: false,
        hoist_vars: false,
        ie8: false,
        if_return: false,
        inline: false,
        join_vars: false,
        keep_fargs: true,
        keep_fnames: true,
        keep_infinity: true,
        loops: false,
        negate_iife: false,
        passes: 1,
        properties: true,
        pure_funcs: null,
        pure_getters: false,
        reduce_vars: false,
        sequences: false,
        side_effects: false,
        switches: false,
        typeofs: false,
        top_retain: false,
        unsafe: false,
        unsafe_arrows: false,
        unsafe_comps: false,
        unsafe_Func: false,
        unsafe_math: false,
        unsafe_proto: false,
        unsafe_regexp: false,
        unused: true,
        warnings: false
    },
    mangle: false,
    output: {
        ascii_only: false,
        beautify: true,
        bracketize: true,
        comments: 'all',
        ie8: false,
        indent_level: 2,
        indent_start: 0,
        inline_script: true,
        keep_quoted_props: true,
        max_line_len: false,
        preamble: null,
        preserve_line: true,
        quote_keys: false,
        quote_style: 1,
        semicolons: true,
        shebang: true,
        source_map: null,
        webkit: false,
        width: 80,
        wrap_iife: false
    }
};
const PROD_MINIFY_OPTS = {
    compress: {
        arrows: false,
        booleans: true,
        cascade: true,
        collapse_vars: true,
        comparisons: true,
        conditionals: true,
        dead_code: true,
        drop_console: true,
        drop_debugger: true,
        evaluate: true,
        expression: true,
        hoist_funs: true,
        hoist_vars: false,
        ie8: false,
        if_return: true,
        inline: true,
        join_vars: true,
        keep_fargs: true,
        keep_fnames: true,
        keep_infinity: true,
        loops: true,
        negate_iife: false,
        passes: 2,
        properties: true,
        pure_funcs: null,
        pure_getters: false,
        reduce_vars: true,
        sequences: true,
        side_effects: true,
        switches: true,
        typeofs: true,
        unsafe: false,
        unsafe_arrows: false,
        unsafe_comps: false,
        unsafe_Func: false,
        unsafe_math: false,
        unsafe_proto: false,
        unsafe_regexp: false,
        unused: true,
        warnings: false
    },
    mangle: {
        properties: {
            builtins: false,
            debug: false,
            keep_quoted: true
        }
    },
    output: {
        ascii_only: false,
        beautify: false,
        bracketize: false,
        comments: false,
        ie8: false,
        indent_level: 0,
        indent_start: 0,
        inline_script: false,
        keep_quoted_props: false,
        max_line_len: false,
        preamble: null,
        preserve_line: false,
        quote_keys: false,
        quote_style: 0,
        semicolons: true,
        shebang: true,
        source_map: null,
        webkit: false,
        width: 80,
        wrap_iife: false
    }
};
var RESERVED_PROPERTIES = [
    'addListener',
    'attr',
    'dom',
    'emit',
    'enableListener',
    'eventNameFn',
    'isClient',
    'isPrerender',
    'isServer',
    'mode',
    'raf',
    'read',
    'ref',
    'write',
    '$definedComponents',
    /**
     * App Global - window.App
     * Properties which get added to the app's global
     */
    'components',
    'loadComponents',
    'loadStyles',
    /**
     * Host Element
     * Properties set on the host element
     */
    '$activeLoading',
    '$connected',
    '$defaultHolder',
    '$initLoad',
    '$rendered',
    '$onRender',
    '$',
    'componentOnReady',
    /**
     * Component Instance
     * Methods set on the user's component
     */
    'componentWillLoad',
    'componentDidLoad',
    'componentWillUpdate',
    'componentDidUpdate',
    'componentDidUnload',
    'hostData',
    'render',
    /**
     * Web Standards / DOM
     */
    'add',
    'addEventListener',
    'appendChild',
    'async',
    'attachShadow',
    'attributeChangedCallback',
    'body',
    'bubbles',
    'cancelable',
    'capture',
    'charset',
    'childNodes',
    'class',
    'classList',
    'className',
    'cloneNode',
    'composed',
    'connectedCallback',
    'content',
    'createComment',
    'createElement',
    'createElementNS',
    'createEvent',
    'createTextNode',
    'customElements',
    'CustomEvent',
    'defaultView',
    'define',
    'detail',
    'didTimeout',
    'disconnect',
    'disconnectedCallback',
    'dispatchEvent',
    'document',
    'documentElement',
    'error',
    'Event',
    'fetch',
    'firstElementChild',
    'getAttribute',
    'getAttributeNS',
    'getRootNode',
    'head',
    'host',
    'href',
    'id',
    'initCustomEvent',
    'innerHTML',
    'insertBefore',
    'location',
    'log',
    'keyCode',
    'navigator',
    'nextSibling',
    'nodeType',
    'now',
    'observe',
    'observedAttributes',
    'onerror',
    'onload',
    'ownerDocument',
    'parentElement',
    'parentNode',
    'passive',
    'pathname',
    'performance',
    'previousSibling',
    'querySelector',
    'querySelectorAll',
    'remove',
    'removeAttribute',
    'removeAttributeNS',
    'removeChild',
    'removeEventListener',
    'requestAnimationFrame',
    'requestIdleCallback',
    'search',
    'setAttribute',
    'setAttributeNS',
    'shadowRoot',
    'src',
    'style',
    'tagName',
    'textContent',
    'timeRemaining',
    'warn',
    'window'
];

var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateCore(config, ctx, sourceTarget, globalJsContent, buildConditionals) {
    return __awaiter$3(this, void 0, void 0, function* () {
        // mega-minify the core w/ property renaming, but not the user's globals
        // hardcode which features should and should not go in the core builds
        // process the transpiled code by removing unused code and minify when configured to do so
        let jsContent = yield config.sys.getClientCoreFile({ staticName: 'core.build.js' });
        jsContent = buildCoreContent(config, ctx, buildConditionals, jsContent);
        if (globalJsContent) {
            // we've got global js to put in the core build too
            // concat the global js and transpiled code together
            jsContent = `${globalJsContent}\n${jsContent}`;
        }
        // wrap the core js code together
        jsContent = wrapCoreJs(config, sourceTarget, jsContent);
        if (buildConditionals.polyfills) {
            // this build wants polyfills so let's
            // add the polyfills to the top of the core content
            // the polyfilled code is already es5/minified ready to go
            const polyfillsContent = yield getCorePolyfills(config);
            jsContent = polyfillsContent + '\n' + jsContent;
        }
        const coreFilename = getCoreFilename(config, buildConditionals.coreId, jsContent);
        if (ctx.appFiles[buildConditionals.coreId] === jsContent) {
            // build is identical from last, no need to resave
            return coreFilename;
        }
        ctx.appFiles[buildConditionals.coreId] = jsContent;
        // update the app core filename within the content
        jsContent = jsContent.replace(APP_NAMESPACE_PLACEHOLDER, getAppFileName(config));
        if (config.generateWWW) {
            // write the www/build/ app core file
            const appCoreWWW = pathJoin(config, getAppWWWBuildDir(config), coreFilename);
            ctx.filesToWrite[appCoreWWW] = jsContent;
        }
        if (config.generateDistribution) {
            // write the dist/ app core file
            const appCoreDist = pathJoin(config, getAppDistDir(config), coreFilename);
            ctx.filesToWrite[appCoreDist] = jsContent;
        }
        return coreFilename;
    });
}
function wrapCoreJs(config, sourceTarget, jsContent) {
    const publicPath = getAppPublicPath(config);
    const output = [
        generatePreamble(config, sourceTarget),
        `(function(Context,appNamespace,hydratedCssClass,publicPath){`,
        `"use strict";\n`,
        `var s=document.querySelector("script[data-namespace='${APP_NAMESPACE_PLACEHOLDER}']");`,
        `if(s){publicPath=s.getAttribute('data-path');}\n`,
        jsContent.trim(),
        `\n})({},"${config.namespace}","${config.hydratedCssClass}","${publicPath}");`
    ].join('');
    return output;
}
function getCorePolyfills(config) {
    // first load up all of the polyfill content
    const readFilePromises = [
        'document-register-element.js',
        'template.js',
        'array-find.js',
        'object-assign.js',
        'promise.js',
        'fetch.js',
        'request-animation-frame.js',
        'closest.js',
        'performance-now.js'
    ].map(polyfillFile => {
        const staticName = config.sys.path.join('polyfills', polyfillFile);
        return config.sys.getClientCoreFile({ staticName: staticName });
    });
    return Promise.all(readFilePromises).then(results => {
        // concat the polyfills
        return generatePreamble(config, 'es5') + results.join('\n').trim();
    });
}
const APP_NAMESPACE_PLACEHOLDER = '__APPNAMESPACE__';

var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateAppGlobal(config, ctx, sourceTarget, appRegistry) {
    return __awaiter$4(this, void 0, void 0, function* () {
        const globalJsContents = yield generateAppGlobalContents(config, ctx, sourceTarget);
        if (globalJsContents.length) {
            appRegistry.global = getGlobalFileName(config);
            const globalJsContent = generateGlobalJs(config, globalJsContents);
            ctx.appFiles.global = globalJsContent;
            if (config.generateWWW) {
                const appGlobalWWWFilePath = getGlobalWWW(config);
                config.logger.debug(`build, app global www: ${appGlobalWWWFilePath}`);
                ctx.filesToWrite[appGlobalWWWFilePath] = globalJsContent;
            }
            if (config.generateDistribution) {
                const appGlobalDistFilePath = getGlobalDist(config);
                config.logger.debug(`build, app global dist: ${appGlobalDistFilePath}`);
                ctx.filesToWrite[appGlobalDistFilePath] = globalJsContent;
            }
        }
        return globalJsContents.join('\n').trim();
    });
}
function generateAppGlobalContents(config, ctx, sourceTarget) {
    let globalJsContents = [];
    return Promise.all([
        loadDependentGlobalJsContents(config, ctx, sourceTarget),
        bundleProjectGlobal(config, ctx, sourceTarget, config.namespace, config.global)
    ]).then(results => {
        const dependentGlobalJsContents = results[0];
        const projectGlobalJsContent = results[1];
        globalJsContents = globalJsContents.concat(dependentGlobalJsContents);
        if (projectGlobalJsContent) {
            globalJsContents.push(projectGlobalJsContent);
        }
    }).then(() => {
        return globalJsContents;
    });
}
function loadDependentGlobalJsContents(config, ctx, sourceTarget) {
    if (!ctx.manifest.dependentManifests) {
        return Promise.resolve([]);
    }
    const dependentManifests = ctx.manifest.dependentManifests
        .filter(m => m.global && m.global.jsFilePath);
    return Promise.all(dependentManifests.map(dependentManifest => {
        return bundleProjectGlobal(config, ctx, sourceTarget, dependentManifest.manifestName, dependentManifest.global.jsFilePath);
    }));
}
function bundleProjectGlobal(config, ctx, sourceTarget, namespace, entry) {
    // stencil by itself does not have a global file
    // however, other collections can provide a global js
    // which will bundle whatever is in the global, and then
    // prepend the output content on top of the core js
    // this way external collections can provide a shared global at runtime
    if (!entry) {
        // looks like they never provided an entry file, which is fine, so let's skip this
        return Promise.resolve(null);
    }
    // ok, so the project also provided an entry file, so let's bundle it up and
    // the output from this can be tacked onto the top of the project's core file
    // start the bundler on our temporary file
    return config.sys.rollup.rollup({
        input: entry,
        plugins: [
            config.sys.rollup.plugins.nodeResolve({
                jsnext: true,
                main: true
            }),
            config.sys.rollup.plugins.commonjs({
                include: 'node_modules/**',
                sourceMap: false
            }),
            transpiledInMemoryPlugin(config, ctx)
        ],
        onwarn: createOnWarnFn(ctx.diagnostics)
    }).catch(err => {
        loadRollupDiagnostics(config, ctx.diagnostics, err);
    })
        .then(rollupBundle => {
        // generate the bundler results
        if (hasError(ctx.diagnostics) || !rollupBundle) {
            return '';
        }
        return rollupBundle.generate({
            format: 'es'
        }).then(results => {
            // cool, so we balled up all of the globals into one string
            // replace build time expressions, like process.env.NODE_ENV === 'production'
            // with a hard coded boolean
            results.code = buildExpressionReplacer(config, results.code);
            // wrap our globals code with our own iife
            return wrapGlobalJs(config, ctx, sourceTarget, namespace, results.code);
        });
    }).then(output => {
        ctx.manifest.global = ctx.moduleFiles[config.global];
        return output;
    });
}
function wrapGlobalJs(config, ctx, sourceTarget, globalJsName, jsContent) {
    jsContent = (jsContent || '').trim();
    // just format it a touch better in dev mode
    jsContent = `\n/** ${globalJsName || ''} global **/\n\n${jsContent}`;
    const lines = jsContent.split(/\r?\n/);
    jsContent = lines.map(line => {
        if (line.length) {
            return '    ' + line;
        }
        return line;
    }).join('\n');
    if (sourceTarget === 'es5') {
        // global could already be in es2015
        // transpile it down to es5
        config.logger.debug(`transpile global to es5: ${globalJsName}`);
        const transpileResults = transpileToEs5(jsContent);
        if (transpileResults.diagnostics && transpileResults.diagnostics.length) {
            ctx.diagnostics.push(...transpileResults.diagnostics);
        }
        else {
            jsContent = transpileResults.code;
        }
    }
    if (config.minifyJs) {
        const opts = { output: {}, compress: {}, mangle: {} };
        if (sourceTarget === 'es5') {
            // minify in a cool es5 way
            opts.ecma = 5;
            opts.output.ecma = 5;
            opts.compress.ecma = 5;
            opts.compress.arrows = false;
        }
        if (config.logLevel === 'debug') {
            opts.mangle.keep_fnames = true;
            opts.compress.drop_console = false;
            opts.compress.drop_debugger = false;
            opts.output.beautify = true;
            opts.output.bracketize = true;
            opts.output.indent_level = 2;
            opts.output.comments = 'all';
            opts.output.preserve_line = true;
        }
        const minifyResults = config.sys.minifyJs(jsContent, opts);
        if (minifyResults.diagnostics && minifyResults.diagnostics.length) {
            ctx.diagnostics.push(...minifyResults.diagnostics);
        }
        else {
            jsContent = minifyResults.output;
        }
    }
    return `\n(function(publicPath){${jsContent}\n})(publicPath);\n`;
}
function generateGlobalJs(config, globalJsContents) {
    const publicPath = getAppPublicPath(config);
    const output = [
        generatePreamble(config, 'es2015'),
        `(function(appNamespace,publicPath){`,
        `"use strict";\n`,
        globalJsContents.join('\n').trim(),
        `\n})("${config.namespace}","${publicPath}");`
    ].join('');
    return output;
}

var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateAppRegistry(config, ctx, appRegistry) {
    return __awaiter$5(this, void 0, void 0, function* () {
        const registryJson = JSON.stringify(appRegistry, null, 2);
        if (ctx.appFiles.registryJson !== registryJson) {
            // app registry json file is actually different from our last saved version
            ctx.appFiles.registryJson = registryJson;
            if (config.generateWWW) {
                const appRegistryWWW = getRegistryJsonWWW(config);
                config.logger.debug(`build, app www registry: ${appRegistryWWW}`);
                ctx.filesToWrite[appRegistryWWW] = registryJson;
            }
            if (config.generateDistribution) {
                const appRegistryDist = getRegistryJsonDist(config);
                config.logger.debug(`build, app dist registry: ${appRegistryDist}`);
                ctx.filesToWrite[appRegistryDist] = registryJson;
            }
            ctx.appFileBuildCount++;
        }
    });
}

function generateEs5DisabledMessage(config, ctx) {
    // not doing an es5 right now
    // but it's possible during development the user
    // tests on a browser that doesn't support es2015
    const fileName = 'es5-build-disabled.js';
    if (!ctx.isRebuild) {
        // only write this once
        const filePath = pathJoin(config, getAppWWWBuildDir(config), fileName);
        ctx.filesToWrite[filePath] = getDisabledMessageScript();
    }
    return fileName;
}
function getDisabledMessageScript() {
    const html = `
  <style>
  body {
    font-family: sans-serif;
    padding: 20px;
    line-height:22px;
  }
  h1 {
    font-size: 18px;
  }
  h2 {
    font-size: 14px;
    margin-top: 40px;
  }
  </style>

  <h1>This app is disabled for this browser.</h1>

  <h2>Developers:</h2>
  <ul>
    <li>ES5 builds are disabled <strong>during development</strong> to take advantage of 2x faster build times.</li>
    <li>Please see the example below or our <a href="https://stenciljs.com/docs/stencil-config" target="_blank">config docs</a> if you would like to develop on a browser that does not fully support ES2015 and custom elements.</li>
    <li>Note that by default, ES5 builds and polyfills are enabled during production builds.</li>
    <li>When testing browsers it is recommended to always test in production mode, and ES5 builds should always be enabled during production builds.</li>
    <li><em>This is only an experiement and if it slows down app development then we will revert this and enable ES5 builds during dev.</em></li>
  </ul>


  <h2>Enabling ES5 builds during development:</h2>
  <pre>
    <code>npm run dev --es5</code>
  </pre>


  <h2>Enabling full production builds during development:</h2>
  <pre>
    <code>npm run dev --prod</code>
  </pre>


  <h2>Current Browser's Support:</h2>
  <ul>
    <li>ES Module Imports: <span id="esModules"></span></li>
    <li>Custom Elements: <span id="customElements"></span></li>
    <li>fetch(): <span id="fetch"></span></li>
  </ul>
  `;
    const script = `
    document.body.innerHTML = '${html.replace(/\r\n|\r|\n/g, '').replace(/\'/g, `\\'`).trim()}';

    document.getElementById('esModules').textContent = !!('noModule' in document.createElement('script'));
    document.getElementById('customElements').textContent = !!(window.customElements);
    document.getElementById('fetch').textContent = !!(window.fetch);
  `;
    // timeout just to ensure <body> is ready
    return `setTimeout(function(){ ${script} }, 10)`;
}

var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateLoader(config, ctx, appRegistry) {
    return __awaiter$6(this, void 0, void 0, function* () {
        const appLoaderFileName = getLoaderFileName(config);
        appRegistry.loader = `../${appLoaderFileName}`;
        const clientLoaderSource = `${LOADER_NAME}.js`;
        let loaderContent = yield config.sys.getClientCoreFile({ staticName: clientLoaderSource });
        loaderContent = injectAppIntoLoader(config, appRegistry.core, appRegistry.coreSsr, appRegistry.corePolyfilled, appRegistry.components, loaderContent);
        // concat the app's loader code
        loaderContent = [
            generatePreamble(config),
            loaderContent
        ].join('').trim();
        // write the app loader file
        if (ctx.appFiles.loader !== loaderContent) {
            // app loader file is actually different from our last saved version
            config.logger.debug(`build, app loader: ${appLoaderFileName}`);
            ctx.appFiles.loader = loaderContent;
            if (config.minifyJs) {
                // minify the loader
                const opts = { output: {}, compress: {}, mangle: {} };
                opts.ecma = 5;
                opts.output.ecma = 5;
                opts.compress.ecma = 5;
                opts.compress.arrows = false;
                if (config.logLevel === 'debug') {
                    opts.mangle.keep_fnames = true;
                    opts.compress.drop_console = false;
                    opts.compress.drop_debugger = false;
                    opts.output.beautify = true;
                    opts.output.bracketize = true;
                    opts.output.indent_level = 2;
                    opts.output.comments = 'all';
                    opts.output.preserve_line = true;
                }
                const minifyJsResults = config.sys.minifyJs(loaderContent, opts);
                minifyJsResults.diagnostics.forEach(d => {
                    config.logger[d.level](d.messageText);
                });
                if (!minifyJsResults.diagnostics.length) {
                    ctx.appFiles.loader = loaderContent = minifyJsResults.output;
                }
            }
            if (config.generateWWW) {
                const appLoaderWWW = pathJoin(config, config.buildDir, appLoaderFileName);
                ctx.filesToWrite[appLoaderWWW] = loaderContent;
            }
            if (config.generateDistribution) {
                const appLoaderDist = pathJoin(config, config.distDir, appLoaderFileName);
                ctx.filesToWrite[appLoaderDist] = loaderContent;
            }
            ctx.appFileBuildCount++;
        }
        return loaderContent;
    });
}
function injectAppIntoLoader(config, appCoreFileName, appCoreSsrFileName, appCorePolyfilledFileName, componentRegistry, loaderContent) {
    const componentRegistryStr = JSON.stringify(componentRegistry);
    const publicPath = getAppPublicPath(config);
    loaderContent = loaderContent.replace(APP_NAMESPACE_REGEX, `"${config.namespace}","${publicPath}","${appCoreFileName}","${appCoreSsrFileName}","${appCorePolyfilledFileName}",${componentRegistryStr}`);
    return loaderContent;
}

function setBuildConditionals(ctx, manifestBundles) {
    // figure out which sections of the core code this build doesn't even need
    const coreBuild = {};
    manifestBundles.forEach(manifestBundle => {
        manifestBundle.moduleFiles.forEach(moduleFile => {
            if (moduleFile.cmpMeta) {
                setBuildFromComponentMeta(coreBuild, moduleFile.cmpMeta);
                setBuildFromComponentContent(coreBuild, ctx.jsFiles[moduleFile.jsFilePath]);
            }
        });
    });
    return coreBuild;
}
function setBuildFromComponentMeta(coreBuild, cmpMeta) {
    if (!cmpMeta)
        return;
    if (cmpMeta.encapsulation === 1 /* ShadowDom */) {
        coreBuild.shadowDom = true;
    }
    if (cmpMeta.slotMeta) {
        coreBuild.slot = true;
    }
    if (cmpMeta.membersMeta) {
        const memberNames = Object.keys(cmpMeta.membersMeta);
        memberNames.forEach(memberName => {
            const memberType = cmpMeta.membersMeta[memberName].memberType;
            const propType = cmpMeta.membersMeta[memberName].propType;
            if (memberType === 1 /* Prop */ || memberType === 2 /* PropMutable */) {
                if (propType === 2 /* String */ || propType === 4 /* Number */ || propType === 3 /* Boolean */ || propType === 1 /* Any */) {
                    coreBuild.observeAttr = true;
                }
            }
            else if (memberType === 4 /* PropConnect */) {
                coreBuild.propConnect = true;
            }
            else if (memberType === 3 /* PropContext */) {
                coreBuild.propContext = true;
            }
            else if (memberType === 6 /* Method */) {
                coreBuild.method = true;
            }
            else if (memberType === 7 /* Element */) {
                coreBuild.element = true;
            }
        });
    }
    if (cmpMeta.propsDidChangeMeta && cmpMeta.propsDidChangeMeta.length > 0) {
        coreBuild.propDidChange = true;
    }
    if (cmpMeta.propsWillChangeMeta && cmpMeta.propsWillChangeMeta.length > 0) {
        coreBuild.propWillChange = true;
    }
    if (cmpMeta.eventsMeta && cmpMeta.eventsMeta.length) {
        coreBuild.event = true;
    }
    if (cmpMeta.listenersMeta && cmpMeta.listenersMeta.length) {
        coreBuild.listener = true;
    }
    if (cmpMeta.stylesMeta) {
        coreBuild.styles = true;
    }
    if (cmpMeta.hostMeta && cmpMeta.hostMeta.theme) {
        coreBuild.hostTheme = true;
    }
}
function setBuildFromComponentContent(coreBuild, jsText) {
    if (typeof jsText !== 'string')
        return;
    // hacky to do it this way...yeah
    // but with collections the components may have been
    // built many moons ago, so we don't want to lock ourselves
    // into a very certain way that components can be parsed
    // so here we're just doing raw string checks, and there
    // wouldn't be any harm if a build section was included when it
    // wasn't needed, but these keywords are all pretty unique already
    if (!coreBuild.cmpWillLoad) {
        coreBuild.cmpWillLoad = (jsText.indexOf('componentWillLoad') > -1);
    }
    if (!coreBuild.cmpDidLoad) {
        coreBuild.cmpDidLoad = (jsText.indexOf('componentDidLoad') > -1);
    }
    if (!coreBuild.cmpWillUpdate) {
        coreBuild.cmpWillUpdate = (jsText.indexOf('componentWillUpdate') > -1);
    }
    if (!coreBuild.cmpDidUpdate) {
        coreBuild.cmpDidUpdate = (jsText.indexOf('componentDidUpdate') > -1);
    }
    if (!coreBuild.cmpDidUnload) {
        coreBuild.cmpDidUnload = (jsText.indexOf('componentDidUnload') > -1);
    }
    if (!coreBuild.hostData) {
        coreBuild.hostData = (jsText.indexOf('hostData') > -1);
    }
    if (!coreBuild.svg) {
        jsText = jsText.toLowerCase();
        coreBuild.svg = (jsText.indexOf('svg') > -1);
    }
}

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function generateAppFiles(config, ctx) {
    return __awaiter$2(this, void 0, void 0, function* () {
        if (hasError(ctx.diagnostics)) {
            return Promise.resolve();
        }
        const timespan = config.logger.createTimeSpan(`generateAppFiles: ${config.namespace} start`, true);
        // generate the shared app registry object
        const appRegistry = {
            namespace: config.namespace,
            components: formatComponentRegistry(ctx.registry)
        };
        // normal es2015 build
        const globalJsContentsEs2015 = yield generateAppGlobal(config, ctx, 'es2015', appRegistry);
        // figure out which sections should be included in the core build
        const buildConditionals = setBuildConditionals(ctx, ctx.manifestBundles);
        buildConditionals.coreId = 'core';
        buildConditionals.ssrClientSide = false;
        const coreFilename = yield generateCore(config, ctx, 'es2015', globalJsContentsEs2015, buildConditionals);
        appRegistry.core = coreFilename;
        const buildConditionalsSsr = setBuildConditionals(ctx, ctx.manifestBundles);
        buildConditionalsSsr.coreId = 'core.ssr';
        buildConditionalsSsr.ssrClientSide = true;
        const coreSsrFilename = yield generateCore(config, ctx, 'es2015', globalJsContentsEs2015, buildConditionalsSsr);
        appRegistry.coreSsr = coreSsrFilename;
        if (config.es5Fallback) {
            // es5 build (if needed)
            const globalJsContentsEs5 = yield generateAppGlobal(config, ctx, 'es5', appRegistry);
            const buildConditionalsEs5 = setBuildConditionals(ctx, ctx.manifestBundles);
            buildConditionalsEs5.coreId = 'core.pf';
            buildConditionalsEs5.es5 = true;
            buildConditionalsEs5.polyfills = true;
            buildConditionalsEs5.ssrClientSide = true;
            const coreFilenameEs5 = yield generateCore(config, ctx, 'es5', globalJsContentsEs5, buildConditionalsEs5);
            appRegistry.corePolyfilled = coreFilenameEs5;
        }
        else if (config.generateWWW) {
            // not doing an es5, probably in dev mode
            // and don't bother if we're not generating a www build
            appRegistry.corePolyfilled = generateEs5DisabledMessage(config, ctx);
        }
        // create a json file for the app registry
        yield generateAppRegistry(config, ctx, appRegistry);
        // create the loader after creating the loader file name
        yield generateLoader(config, ctx, appRegistry);
        timespan.finish(`generateAppFiles: ${config.namespace} finished`);
    });
}

function injectRegisterServiceWorker(config, swConfig, indexHtml) {
    const match = indexHtml.match(BODY_CLOSE_REG);
    let swUrl = config.sys.path.relative(config.wwwDir, swConfig.swDest);
    if (swUrl.charAt(0) !== '/') {
        swUrl = '/' + swUrl;
    }
    if (match) {
        indexHtml = indexHtml.replace(match[0], `${getRegisterSwScript(swUrl)}\n${match[0]}`);
    }
    return indexHtml;
}
function injectUnregisterServiceWorker(indexHtml) {
    const match = indexHtml.match(BODY_CLOSE_REG);
    if (match) {
        indexHtml = indexHtml.replace(match[0], `${UNREGSITER_SW}\n${match[0]}`);
    }
    return indexHtml;
}
function getRegisterSwScript(swUrl) {
    return `
  <script>
    if ('serviceWorker' in navigator && location.protocol !== 'file:') {
      window.addEventListener('load', function(){
        navigator.serviceWorker.register('${swUrl}')
          .then(function(reg) { console.log('service worker registered', reg) })
          .catch(function(err) { console.log('service worker error', err) });
      });
    }
  </script>
`;
}
const UNREGSITER_SW = `
  <script>
    if ('serviceWorker' in navigator && location.protocol !== 'file:') {
      // auto-unregister service worker during dev mode
      navigator.serviceWorker.ready.then(function(registration) {
        registration.unregister().then(function() { location.reload(true) });
      });
    }
  </script>
`;
const BODY_CLOSE_REG = /<\/body>/i;

function generateIndexHtml(config, ctx) {
    if ((ctx.isRebuild && ctx.appFileBuildCount === 0) || hasError(ctx.diagnostics) || !config.generateWWW) {
        // no need to rebuild index.html if there were no app file changes
        return Promise.resolve();
    }
    // get the source index html content
    return readFile(config.sys, config.srcIndexHtml).then(indexSrcHtml => {
        // set the index content to be written
        try {
            return setIndexHtmlContent(config, ctx, indexSrcHtml);
        }
        catch (e) {
            catchError(ctx.diagnostics, e);
        }
    }).catch(err => {
        // it's ok if there's no index file
        config.logger.debug(`no index html: ${config.srcIndexHtml}: ${err}`);
    });
}
function setIndexHtmlContent(config, ctx, indexHtml) {
    const swConfig = config.serviceWorker;
    if (!swConfig && config.devMode) {
        // if we're not generating a sw, and this is a dev build
        // then let's inject a script that always unregisters any service workers
        indexHtml = injectUnregisterServiceWorker(indexHtml);
    }
    else if (swConfig) {
        // we have a valid sw config, so we'll need to inject the register sw script
        indexHtml = injectRegisterServiceWorker(config, swConfig, indexHtml);
    }
    if (ctx.appFiles.indexHtml === indexHtml) {
        // only write to disk if the html content is different than last time
        return;
    }
    // add the prerendered html to our list of files to write
    // and cache the html to check against for next time
    ctx.filesToWrite[config.wwwIndexHtml] = ctx.appFiles.indexHtml = indexHtml;
    // keep track of how many times we built the index file
    // useful for debugging/testing
    ctx.indexBuildCount++;
    config.logger.debug(`optimizeHtml, write: ${config.wwwIndexHtml}`);
}

function generateServiceWorker(config, ctx) {
    if (!ctx.hasIndexHtml || !config.generateWWW) {
        config.logger.debug(`generateServiceWorker, no index.html, so skipping sw build`);
        return Promise.resolve();
    }
    if (!config.serviceWorker) {
        // no sw config, let's not continue
        return Promise.resolve();
    }
    if (hasSrcConfig(config)) {
        return injectManifest(config, ctx);
    }
    else {
        return generate(config, ctx);
    }
}
function generate(config, ctx) {
    const timeSpan = config.logger.createTimeSpan(`generate service worker started`);
    return config.sys.workbox.generateSW(config.serviceWorker)
        .catch(err => catchError(ctx.diagnostics, err))
        .then(() => timeSpan.finish(`generate service worker finished`));
}
function injectManifest(config, ctx) {
    const timeSpan = config.logger.createTimeSpan(`inject manifest into service worker started`);
    return config.sys.workbox.injectManifest(config.serviceWorker)
        .catch(err => catchError(ctx.diagnostics, err))
        .then(() => timeSpan.finish('inject manifest into service worker finished'));
}
function hasSrcConfig(config) {
    const serviceWorkerConfig = config.serviceWorker;
    return !!serviceWorkerConfig.swSrc;
}

function loadDependentManifests(config, ctx) {
    // load up all of the collections which this app is dependent on
    return Promise.all(config.collections.map(configCollection => {
        return loadDependentManifest(config, ctx, configCollection);
    }));
}
function loadDependentManifest(config, ctx, dependentCollection) {
    if (ctx.dependentManifests[dependentCollection.name]) {
        // we've already cached the manifest, no need for another resolve/readFile/parse
        return Promise.resolve(ctx.dependentManifests[dependentCollection.name]);
    }
    // figure out the path to the dependent collection's package.json
    const dependentPackageJsonFilePath = config.sys.resolveModule(config.rootDir, dependentCollection.name);
    // parse the dependent collection's package.json
    const packageData = JSON.parse(config.sys.fs.readFileSync(dependentPackageJsonFilePath, 'utf-8'));
    // verify this package has a "collection" property in its package.json
    if (!packageData.collection) {
        throw new Error(`stencil collection "${dependentCollection.name}" is missing the "collection" key from its package.json: ${dependentPackageJsonFilePath}`);
    }
    // get the root directory of the dependency
    const dependentPackageRootDir = config.sys.path.dirname(dependentPackageJsonFilePath);
    // figure out the full path to the collection manifest file
    const dependentManifestFilePath = normalizePath(config.sys.path.join(dependentPackageRootDir, packageData.collection));
    // we haven't cached the dependent manifest yet, let's read this file
    return readFile(config.sys, dependentManifestFilePath).then(dependentManifestJson => {
        // get the directory where the collection manifest file is sitting
        const dependentManifestDir = normalizePath(config.sys.path.dirname(dependentManifestFilePath));
        // parse the json string into our Manifest data
        const dependentManifest = parseDependentManifest(config, dependentCollection.name, dependentManifestDir, dependentManifestJson);
        // go through and filter out components if need be
        filterDependentComponents(config.bundles, dependentCollection, dependentManifest);
        // cache it for later yo
        ctx.dependentManifests[dependentCollection.name] = dependentManifest;
        // so let's recap: we've read the file, parsed it apart, and cached it, congrats
        return dependentManifest;
    });
}
function filterDependentComponents(bundles, dependentCollection, dependentManifest) {
    if (dependentCollection.includeBundledOnly) {
        // what was imported included every component this collection has
        // however, the user only want to include specific components
        // which are seen within the user's own bundles
        // loop through this manifest an take out components which are not
        // seen in the user's list of bundled components
        dependentManifest.modulesFiles = dependentManifest.modulesFiles.filter(modulesFile => {
            return bundles.some(b => b.components.indexOf(modulesFile.cmpMeta.tagNameMeta) > -1);
        });
    }
}

function mergeDependentManifests(appManifest, dependentManifests) {
    // the appManifest is the single source of manifest data
    // we need to merge what we've learned about the
    // dependent manifests into the one app manifest object
    dependentManifests.forEach(dependentManifest => {
        // concat the module files together
        concatModuleFiles(appManifest, dependentManifest);
        // update which components go in which bundles
        updateBundles(appManifest, dependentManifest);
        // add the dependent manfiest to the app manifests
        appManifest.dependentManifests.push(dependentManifest);
    });
    return appManifest;
}
function concatModuleFiles(appManifest, dependentManifest) {
    if (!Array.isArray(dependentManifest.modulesFiles))
        return;
    // append any dependent manifest data onto the appManifest
    appManifest.modulesFiles = appManifest.modulesFiles.concat(dependentManifest.modulesFiles);
}
function updateBundles(appManifest, dependentManifest) {
    if (!Array.isArray(dependentManifest.modulesFiles) || !Array.isArray(dependentManifest.bundles))
        return;
    // if any component is in the app's bundle config
    // then the user's bundle config takes priority over whatever
    // bundle the dependent manifest has the component in
    dependentManifest.bundles.forEach(dependentBundle => {
        // make a fresh copy
        const cleanedBundled = {
            components: [],
            priority: dependentBundle.priority
        };
        dependentBundle.components.forEach(dependentBundleComponentTag => {
            // check if this dependent component tag is already in the app config's bundle
            const componentInAppBundle = appManifest.bundles.some(b => {
                return b.components.indexOf(dependentBundleComponentTag) > -1;
            });
            if (!componentInAppBundle) {
                // so this component is NOT in the app's bundle already
                // so it's safe to keep it in the dependent bundle's component config
                cleanedBundled.components.push(dependentBundleComponentTag);
            }
        });
        if (dependentBundle.components.length) {
            // ok, so let's add the cleaned dependent bundle to the app manifest
            appManifest.bundles.push(cleanedBundled);
        }
    });
}

function generateAppManifest(config, ctx, moduleFiles) {
    // create the app manifest we're going to fill up with data
    // the data will be both the app's data, and the collections it depends on
    ctx.manifest = {
        modulesFiles: [],
        bundles: [],
        global: null,
        dependentManifests: [],
        compiler: {
            name: config.sys.compiler.name,
            version: config.sys.compiler.version,
            typescriptVersion: config.sys.compiler.typescriptVersion
        }
    };
    if (hasError(ctx.diagnostics)) {
        return Promise.resolve();
    }
    return Promise.resolve().then(() => {
        // add the app's compiled components to the manifest
        addAppBundles(config, ctx.manifest);
        return addAppComponents(config, ctx.manifest, moduleFiles);
    }).then(() => {
        // load each of the manifests for each dependent collection
        return loadDependentManifests(config, ctx);
    }).then(dependentManifests => {
        // merge the loaded dependent manifests
        // into the app's manifest
        return mergeDependentManifests(ctx.manifest, dependentManifests);
    }).catch(err => {
        // ¯\_(ツ)_/¯
        catchError(ctx.diagnostics, err);
    });
}
function addAppComponents(config, manifest, moduleFiles) {
    // get all of the filenames of the compiled files
    const filePaths = Object.keys(moduleFiles);
    // loop through the compiled files and fill up the manifest w/ component data
    filePaths.forEach(filePath => {
        const moduleFile = moduleFiles[filePath];
        if (!moduleFile.cmpMeta || !moduleFile.cmpMeta.tagNameMeta) {
            // this isn't a component, let's not add it to the manifest
            return;
        }
        // see if this component tag shows up in any config's bundles
        const includedComponent = config.bundles.some(bundle => {
            return bundle.components.some(c => c === moduleFile.cmpMeta.tagNameMeta);
        });
        if (!includedComponent) {
            // didn't find this component in the config bundles
            // so let's go ahead and just add it for them
            manifest.bundles.push({
                components: [moduleFile.cmpMeta.tagNameMeta]
            });
        }
        // awesome, good to go, let's add it to the manifest's components
        manifest.modulesFiles.push(moduleFile);
    });
}
function addAppBundles(config, manifest) {
    config.bundles.forEach(configBundle => {
        manifest.bundles.push({
            components: configBundle.components.slice(),
            priority: configBundle.priority
        });
    });
}

function initIndexHtml(config, ctx, diagnostics) {
    // if there isn't an index.html yet
    // let's generate a slim one quick so that
    // on the first build the user sees a loading indicator
    // this is synchronous on purpose so that it's saved
    // before the dev server fires up and loads the index.html page
    if (ctx.isRebuild) {
        // if this is a rebuild then don't bother
        // we've already done this
        return true;
    }
    try {
        // check if there's even a src index.html file
        config.sys.fs.accessSync(config.srcIndexHtml);
        ctx.hasIndexHtml = true;
    }
    catch (e) {
        // there is no src index.html file in the config, which is fine
        // since there is no src index file at all, don't bother
        // this isn't actually an error, don't worry about it
        ctx.hasIndexHtml = false;
        return true;
    }
    try {
        // ok, so we haven't written an index.html build file yet
        // and we do know they have a src one, so let's write a
        // filler index.html file that shows while the first build is happening
        config.sys.ensureDirSync(config.wwwDir);
        config.sys.fs.writeFileSync(config.wwwIndexHtml, FILLER_INDEX_BUILD);
    }
    catch (e) {
        catchError(diagnostics, e);
        // darn, actual error here, idk
        return false;
    }
    // successful, let's continue with the build
    return true;
}
const FILLER_INDEX_BUILD = `
<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.ready.then(function(registration) {
        registration.unregister();
      });
    }
  </script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Initializing First Build...</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      position: absolute;
      padding: 0;
      margin: 0;
      width: 100%;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    .toast {
      position: absolute;
      top: 10px;
      right: 10px;
      left: 10px;
      margin: auto;
      max-width: 700px;
      border-radius: 3px;
      background: rgba(0,0,0,.9);
      -webkit-transform: translate3d(0px, -60px, 0px);
      transform: translate3d(0px, -60px, 0px);
      -webkit-transition: -webkit-transform 75ms ease-out;
      transition: transform 75ms ease-out;
      pointer-events: none;
    }

    .active {
      -webkit-transform: translate3d(0px, 0px, 0px);
      transform: translate3d(0px, 0px, 0px);
    }

    .content {
      display: flex;
      -webkit-align-items: center;
      -ms-flex-align: center;
      align-items: center;
      pointer-events: auto;
    }

    .message {
      -webkit-flex: 1;
      -ms-flex: 1;
      flex: 1;
      padding: 15px;
      font-size: 14px;
      color: #fff;
    }

    .spinner {
      position: relative;
      display: inline-block;
      width: 56px;
      height: 28px;
    }

    svg:not(:root) {
      overflow: hidden;
    }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-animation: rotate 600ms linear infinite;
      animation: rotate 600ms linear infinite;
    }

    @-webkit-keyframes rotate {
      0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
      }
      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }

    @keyframes rotate {
      0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
      }
      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }

    svg circle {
      fill: transparent;
      stroke: white;
      stroke-width: 4px;
      stroke-dasharray: 128px;
      stroke-dashoffset: 82px;
    }
  </style>
</head>
<body>

  <div class="toast">
    <div class="content">
      <div class="message">Initializing First Build...</div>
      <div class="spinner">
        <svg viewBox="0 0 64 64"><circle transform="translate(32,32)" r="26"></circle></svg>
      </div>
    </div>
  </div>

  <script>
    setTimeout(function() {
      document.querySelector('.toast').classList.add('active');
    }, 100);
  </script>

</body>
</html>
`;

var PrerenderStatus;
(function (PrerenderStatus) {
    PrerenderStatus[PrerenderStatus["pending"] = 1] = "pending";
    PrerenderStatus[PrerenderStatus["processing"] = 2] = "processing";
    PrerenderStatus[PrerenderStatus["complete"] = 3] = "complete";
})(PrerenderStatus || (PrerenderStatus = {}));

function validatePrerenderConfig(config) {
    if (config.prerender && config.generateWWW) {
        if (typeof config.prerender !== 'object' || Array.isArray(config.prerender)) {
            config.prerender = {};
        }
        config.prerender = Object.assign({}, DEFAULT_PRERENDER_CONFIG, config.prerender);
        if (!config.prerender.prerenderDir) {
            config.prerender.prerenderDir = config.wwwDir;
        }
        if (!config.sys.path.isAbsolute(config.prerender.prerenderDir)) {
            config.prerender.prerenderDir = normalizePath(config.sys.path.join(config.rootDir, config.prerender.prerenderDir));
        }
    }
    else {
        config.prerender = null;
    }
}
const DEFAULT_PRERENDER_CONFIG = {
    crawl: true,
    include: [
        { url: '/' }
    ],
    inlineLoaderScript: true,
    inlineStyles: true,
    removeUnusedStyles: true,
    collapseWhitespace: true,
    maxConcurrent: 4,
    host: 'dev.prerender.stenciljs.com'
};

const Build = {
    verboseError: true,
    shadowDom: true,
    slot: true,
    ssrClientSide: true,
    ssrServerSide: true,
    styles: true,
    hostData: true,
    hostTheme: true,
    svg: true,
    observeAttr: true,
    // decorators
    element: true,
    event: true,
    listener: true,
    method: true,
    propConnect: true,
    propContext: true,
    propDidChange: true,
    propWillChange: true,
    // lifecycle events
    cmpDidLoad: true,
    cmpWillLoad: true,
    cmpDidUpdate: true,
    cmpWillUpdate: true,
    cmpDidUnload: true,
};

function initElementListeners(plt, elm) {
    // so the element was just connected, which means it's in the DOM
    // however, the component instance hasn't been created yet
    // but what if an event it should be listening to get emitted right now??
    // let's add our listeners right now to our element, and if it happens
    // to receive events between now and the instance being created let's
    // queue up all of the event data and fire it off on the instance when it's ready
    const cmpMeta = plt.getComponentMeta(elm);
    if (cmpMeta.listenersMeta) {
        cmpMeta.listenersMeta.forEach(listener => {
            if (!listener.eventDisabled) {
                (elm._listeners = elm._listeners || {})[listener.eventName] = addListener(plt, elm, listener.eventName, createListenerCallback(elm, listener.eventMethodName), listener.eventCapture, listener.eventPassive);
            }
        });
    }
}
function createListenerCallback(elm, eventMethodName) {
    // create the function that gets called when the element receives
    // an event which it should be listening for
    return (ev) => {
        if (elm._instance) {
            // instance is ready, let's call it's member method for this event
            elm._instance[eventMethodName](ev);
        }
        else {
            // instance is not ready!!
            // let's queue up this event data and replay it later
            // when the instance is ready
            (elm._queuedEvents = elm._queuedEvents || []).push(eventMethodName, ev);
        }
    };
}
function replayQueuedEventsOnInstance(elm, i) {
    // the element has an instance now and
    // we already added the event listeners to the element
    const queuedEvents = elm._queuedEvents;
    if (queuedEvents) {
        // events may have already fired before the instance was even ready
        // now that the instance is ready, let's replay all of the events that
        // we queued up earlier that were originally meant for the instance
        for (i = 0; i < queuedEvents.length; i += 2) {
            // data was added in sets of two
            // first item the eventMethodName
            // second item is the event data
            // take a look at initElementListener()
            elm._instance[queuedEvents[i]](queuedEvents[i + 1]);
        }
        // no longer need this data, be gone with you
        elm._queuedEvents = null;
    }
}

function addListener(plt, elm, eventName, listenerCallback, useCapture, usePassive, splt, eventListener) {
    // depending on the event name, we could actually be attaching
    // this element to something like the document or window
    splt = eventName.split(':');
    if (elm && splt.length > 1) {
        // document:mousemove
        // parent:touchend
        // body:keyup.enter
        elm = plt.domApi.$elementRef(elm, splt[0]);
        eventName = splt[1];
    }
    if (!elm) {
        // something's up, let's not continue and just return a noop()
        return noop;
    }
    eventListener = listenerCallback;
    // test to see if we're looking for an exact keycode
    splt = eventName.split('.');
    if (splt.length > 1) {
        // looks like this listener is also looking for a keycode
        // keyup.enter
        eventName = splt[0];
        eventListener = (ev) => {
            // wrap the user's event listener with our own check to test
            // if this keyboard event has the keycode they're looking for
            if (ev.keyCode === KEY_CODE_MAP[splt[1]]) {
                listenerCallback(ev);
            }
        };
    }
    // good to go now, add the event listener
    // and the returned value is a function to remove the same event listener
    return plt.domApi.$addEventListener(elm, eventName, eventListener, useCapture, usePassive);
}

function updateElement(plt, oldVnode, newVnode, isSvgMode, name) {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    const elm = (newVnode.elm.nodeType === 11 /* DocumentFragment */ && newVnode.elm.host) ? newVnode.elm.host : newVnode.elm;
    const oldVnodeAttrs = (oldVnode && oldVnode.vattrs) || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.vattrs || EMPTY_OBJ;
    // remove attributes no longer present on the vnode by setting them to undefined
    for (name in oldVnodeAttrs) {
        if (!(newVnodeAttrs && newVnodeAttrs[name] != null) && oldVnodeAttrs[name] != null) {
            setAccessor(plt, elm, name, oldVnodeAttrs[name], undefined, isSvgMode);
        }
    }
    // add new & update changed attributes
    for (name in newVnodeAttrs) {
        if (!(name in oldVnodeAttrs) || newVnodeAttrs[name] !== (name === 'value' || name === 'checked' ? elm[name] : oldVnodeAttrs[name])) {
            setAccessor(plt, elm, name, oldVnodeAttrs[name], newVnodeAttrs[name], isSvgMode);
        }
    }
}
function setAccessor(plt, elm, name, oldValue, newValue, isSvg, i, ilen) {
    if (name === 'class' && !isSvg) {
        // Class
        if (oldValue !== newValue) {
            const oldList = (oldValue == null || oldValue === '') ? EMPTY_ARR : oldValue.trim().split(/\s+/);
            const newList = (newValue == null || newValue === '') ? EMPTY_ARR : newValue.trim().split(/\s+/);
            let classList = (elm.className == null || elm.className === '') ? EMPTY_ARR : elm.className.trim().split(/\s+/);
            for (i = 0, ilen = oldList.length; i < ilen; i++) {
                if (newList.indexOf(oldList[i]) === -1) {
                    classList = classList.filter((c) => c !== oldList[i]);
                }
            }
            for (i = 0, ilen = newList.length; i < ilen; i++) {
                if (oldList.indexOf(newList[i]) === -1) {
                    classList = [...classList, newList[i]];
                }
            }
            elm.className = classList.join(' ');
        }
    }
    else if (name === 'style') {
        // Style
        oldValue = oldValue || EMPTY_OBJ;
        newValue = newValue || EMPTY_OBJ;
        for (i in oldValue) {
            if (!newValue[i]) {
                elm.style[i] = '';
            }
        }
        for (i in newValue) {
            if (newValue[i] !== oldValue[i]) {
                elm.style[i] = newValue[i];
            }
        }
    }
    else if (name[0] === 'o' && name[1] === 'n' && (!(name in elm))) {
        // Event Handlers
        // adding an standard event listener, like <button onClick=...> or something
        name = toLowerCase(name).substring(2);
        const listeners = (elm._listeners = elm._listeners || {});
        if (newValue) {
            if (!oldValue) {
                // add listener
                listeners[name] = addListener(plt, elm, name, newValue);
            }
        }
        else if (listeners[name]) {
            // remove listener
            listeners[name]();
        }
    }
    else if (name !== 'list' && name !== 'type' && !isSvg &&
        (name in elm || (['object', 'function'].indexOf(typeof newValue) !== -1) && newValue !== null)) {
        // Properties
        // - list and type are attributes that get applied as values on the element
        // - all svgs get values as attributes not props
        // - check if elm contains name or if the value is array, object, or function
        const cmpMeta = plt.getComponentMeta(elm);
        if (cmpMeta && cmpMeta.membersMeta && name in cmpMeta.membersMeta) {
            // setting a known @Prop on this element
            setProperty(elm, name, newValue);
        }
        else if (name !== 'ref') {
            // property setting a prop on a native property, like "value" or something
            setProperty(elm, name, newValue == null ? '' : newValue);
            if (newValue == null || newValue === false) {
                elm.removeAttribute(name);
            }
        }
    }
    else if (newValue != null) {
        // Element Attributes
        i = (name !== (name = name.replace(/^xlink\:?/, '')));
        if (BOOLEAN_ATTRS[name] === 1 && (!newValue || newValue === 'false')) {
            if (i) {
                elm.removeAttributeNS(XLINK_NS$1, toLowerCase(name));
            }
            else {
                elm.removeAttribute(name);
            }
        }
        else if (typeof newValue !== 'function') {
            if (i) {
                elm.setAttributeNS(XLINK_NS$1, toLowerCase(name), newValue);
            }
            else {
                elm.setAttribute(name, newValue);
            }
        }
    }
}
/**
 * Attempt to set a DOM property to the given value.
 * IE & FF throw for certain property-value combinations.
 */
function setProperty(elm, name, value) {
    try {
        elm[name] = value;
    }
    catch (e) { }
}
const BOOLEAN_ATTRS = {
    'allowfullscreen': 1,
    'async': 1,
    'autofocus': 1,
    'autoplay': 1,
    'checked': 1,
    'controls': 1,
    'disabled': 1,
    'enabled': 1,
    'formnovalidate': 1,
    'hidden': 1,
    'multiple': 1,
    'noresize': 1,
    'readonly': 1,
    'required': 1,
    'selected': 1,
    'spellcheck': 1,
};
const XLINK_NS$1 = 'http://www.w3.org/1999/xlink';

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
 *
 * Modified for Stencil's renderer and slot projection
 */
let isSvgMode = false;
function createRendererPatch(plt, domApi) {
    // createRenderer() is only created once per app
    // the patch() function which createRenderer() returned is the function
    // which gets called numerous times by each component
    function createElm(vnode, parentElm, childIndex) {
        let i = 0;
        if (typeof vnode.vtag === 'function') {
            vnode = vnode.vtag(Object.assign({}, vnode.vattrs, { children: vnode.vchildren }));
        }
        if (Build.slot && vnode.vtag === 'slot' && !useNativeShadowDom) {
            if (hostContentNodes) {
                if (scopeId) {
                    domApi.$setAttribute(parentElm, scopeId + '-slot', '');
                }
                // special case for manually relocating host content nodes
                // to their new home in either a named slot or the default slot
                let namedSlot = (vnode.vattrs && vnode.vattrs.name);
                let slotNodes;
                if (isDef(namedSlot)) {
                    // this vnode is a named slot
                    slotNodes = hostContentNodes.namedSlots && hostContentNodes.namedSlots[namedSlot];
                }
                else {
                    // this vnode is the default slot
                    slotNodes = hostContentNodes.defaultSlot;
                }
                if (isDef(slotNodes)) {
                    // the host element has some nodes that need to be moved around
                    // we have a slot for the user's vnode to go into
                    // while we're moving nodes around, temporarily disable
                    // the disconnectCallback from working
                    plt.tmpDisconnected = true;
                    for (; i < slotNodes.length; i++) {
                        // remove the host content node from it's original parent node
                        // then relocate the host content node to its new slotted home
                        domApi.$appendChild(parentElm, domApi.$removeChild(domApi.$parentNode(slotNodes[i]), slotNodes[i]));
                    }
                    // done moving nodes around
                    // allow the disconnect callback to work again
                    plt.tmpDisconnected = false;
                }
            }
            // this was a slot node, we do not create slot elements, our work here is done
            // no need to return any element to be added to the dom
            return null;
        }
        if (isDef(vnode.vtext)) {
            // create text node
            vnode.elm = domApi.$createTextNode(vnode.vtext);
        }
        else {
            // create element
            const elm = vnode.elm = ((Build.svg && (isSvgMode || vnode.vtag === 'svg')) ? domApi.$createElementNS('http://www.w3.org/2000/svg', vnode.vtag) : domApi.$createElement(vnode.vtag));
            if (Build.svg) {
                isSvgMode = vnode.vtag === 'svg' ? true : (vnode.vtag === 'foreignObject' ? false : isSvgMode);
            }
            // add css classes, attrs, props, listeners, etc.
            updateElement(plt, null, vnode, isSvgMode);
            if (scopeId !== null && elm._scopeId !== scopeId) {
                // if there is a scopeId and this is the initial render
                // then let's add the scopeId as an attribute
                domApi.$setAttribute(elm, (elm._scopeId = scopeId), '');
            }
            const children = vnode.vchildren;
            if (Build.ssrServerSide && isDef(ssrId)) {
                // SSR ONLY: this is an SSR render and this
                // logic does not run on the client
                // give this element the SSR child id that can be read by the client
                domApi.$setAttribute(elm, SSR_CHILD_ID, ssrId + '.' + childIndex + (hasChildNodes(children) ? '' : '.'));
            }
            if (children) {
                let childNode;
                for (; i < children.length; ++i) {
                    // create the node
                    childNode = createElm(children[i], elm, i);
                    // return node could have been null
                    if (childNode) {
                        if (Build.ssrServerSide && isDef(ssrId) && childNode.nodeType === 3 /* TextNode */) {
                            // SSR ONLY: add the text node's start comment
                            domApi.$appendChild(elm, domApi.$createComment('s.' + ssrId + '.' + i));
                        }
                        // append our new node
                        domApi.$appendChild(elm, childNode);
                        if (Build.ssrServerSide && isDef(ssrId) && childNode.nodeType === 3) {
                            // SSR ONLY: add the text node's end comment
                            domApi.$appendChild(elm, domApi.$createComment('/'));
                            domApi.$appendChild(elm, domApi.$createTextNode(' '));
                        }
                    }
                }
            }
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
        const containerElm = (parentElm.$defaultHolder && domApi.$parentNode(parentElm.$defaultHolder)) || parentElm;
        let childNode;
        for (; startIdx <= endIdx; ++startIdx) {
            var vnodeChild = vnodes[startIdx];
            if (isDef(vnodeChild)) {
                if (isDef(vnodeChild.vtext)) {
                    childNode = domApi.$createTextNode(vnodeChild.vtext);
                }
                else {
                    childNode = createElm(vnodeChild, parentElm, startIdx);
                }
                if (isDef(childNode)) {
                    vnodeChild.elm = childNode;
                    domApi.$insertBefore(containerElm, childNode, before);
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            if (isDef(vnodes[startIdx])) {
                domApi.$removeChild(parentElm, vnodes[startIdx].elm);
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh) {
        let oldStartIdx = 0, newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx;
        let idxInOld;
        let elmToMove;
        let node;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldStartVnode, newStartVnode)) {
                patchVNode(oldStartVnode, newStartVnode);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (isSameVnode(oldEndVnode, newEndVnode)) {
                patchVNode(oldEndVnode, newEndVnode);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldStartVnode, newEndVnode)) {
                patchVNode(oldStartVnode, newEndVnode);
                domApi.$insertBefore(parentElm, oldStartVnode.elm, domApi.$nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldEndVnode, newStartVnode)) {
                patchVNode(oldEndVnode, newStartVnode);
                domApi.$insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (isUndef(oldKeyToIdx)) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.vkey];
                if (isUndef(idxInOld)) {
                    // new element
                    node = createElm(newStartVnode, parentElm, newStartIdx);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.vtag !== newStartVnode.vtag) {
                        node = createElm(newStartVnode, parentElm, idxInOld);
                    }
                    else {
                        patchVNode(elmToMove, newStartVnode);
                        oldCh[idxInOld] = undefined;
                        node = elmToMove.elm;
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
                if (node) {
                    domApi.$insertBefore(parentElm, node, oldStartVnode.elm);
                }
            }
        }
        if (oldStartIdx > oldEndIdx) {
            addVnodes(parentElm, (newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm), newCh, newStartIdx, newEndIdx);
        }
        else if (newStartIdx > newEndIdx) {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function isSameVnode(vnode1, vnode2) {
        // compare if two vnode to see if they're "technically" the same
        // need to have the same element tag, and same key to be the same
        return vnode1.vtag === vnode2.vtag && vnode1.vkey === vnode2.vkey;
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
        let i, map = {}, key, ch;
        for (i = beginIdx; i <= endIdx; ++i) {
            ch = children[i];
            if (ch != null) {
                key = ch.vkey;
                if (key !== undefined) {
                    map.k = i;
                }
            }
        }
        return map;
    }
    function patchVNode(oldVNode, newVNode) {
        const elm = newVNode.elm = oldVNode.elm;
        const oldChildren = oldVNode.vchildren;
        const newChildren = newVNode.vchildren;
        if (Build.svg) {
            isSvgMode = newVNode.elm && newVNode.elm.parentElement != null && newVNode.elm.ownerSVGElement !== undefined;
            isSvgMode = newVNode.vtag === 'svg' ? true : (newVNode.vtag === 'foreignObject' ? false : isSvgMode);
        }
        if (isUndef(newVNode.vtext)) {
            // element node
            if (newVNode.vtag !== 'slot') {
                // either this is the first render of an element OR it's an update
                // AND we already know it's possible it could have changed
                // this updates the element's css classes, attrs, props, listeners, etc.
                updateElement(plt, oldVNode, newVNode, isSvgMode);
            }
            if (isDef(oldChildren) && isDef(newChildren)) {
                // looks like there's child vnodes for both the old and new vnodes
                updateChildren(elm, oldChildren, newChildren);
            }
            else if (isDef(newChildren)) {
                // no old child vnodes, but there are new child vnodes to add
                if (isDef(oldVNode.vtext)) {
                    // the old vnode was text, so be sure to clear it out
                    domApi.$setTextContent(elm, '');
                }
                // add the new vnode children
                addVnodes(elm, null, newChildren, 0, newChildren.length - 1);
            }
            else if (isDef(oldChildren)) {
                // no new child vnodes, but there are old child vnodes to remove
                removeVnodes(elm, oldChildren, 0, oldChildren.length - 1);
            }
        }
        else if (elm._hostContentNodes && elm._hostContentNodes.defaultSlot) {
            // this element has slotted content
            let parentElement = elm._hostContentNodes.defaultSlot[0].parentElement;
            domApi.$setTextContent(parentElement, newVNode.vtext);
            elm._hostContentNodes.defaultSlot = [parentElement.childNodes[0]];
        }
        else if (oldVNode.vtext !== newVNode.vtext) {
            // update the text content for the text only vnode
            // and also only if the text is different than before
            domApi.$setTextContent(elm, newVNode.vtext);
        }
    }
    // internal variables to be reused per patch() call
    let isUpdate, hostContentNodes, useNativeShadowDom, ssrId, scopeId;
    return function patch(oldVNode, newVNode, isUpdatePatch, hostElementContentNodes, encapsulation, ssrPatchId) {
        // patchVNode() is synchronous
        // so it is safe to set these variables and internally
        // the same patch() call will reference the same data
        isUpdate = isUpdatePatch;
        hostContentNodes = hostElementContentNodes;
        if (Build.ssrServerSide) {
            ssrId = ssrPatchId;
        }
        scopeId = (encapsulation === 2 /* ScopedCss */ || (encapsulation === 1 /* ShadowDom */ && !domApi.$supportsShadowDom)) ? 'data-' + domApi.$tagName(oldVNode.elm) : null;
        if (Build.shadowDom) {
            // use native shadow dom only if the component wants to use it
            // and if this browser supports native shadow dom
            useNativeShadowDom = (encapsulation === 1 /* ShadowDom */ && domApi.$supportsShadowDom);
        }
        if (!isUpdate) {
            if (Build.shadowDom && useNativeShadowDom) {
                // this component SHOULD use native slot/shadow dom
                // this browser DOES support native shadow dom
                // and this is the first render
                // let's create that shadow root
                oldVNode.elm = domApi.$attachShadow(oldVNode.elm, { mode: 'open' });
            }
            else if (scopeId) {
                // this host element should use scoped css
                // add the scope attribute to the host
                domApi.$setAttribute(oldVNode.elm, scopeId + '-host', '');
            }
        }
        // synchronous patch
        patchVNode(oldVNode, newVNode);
        if (Build.ssrServerSide && isDef(ssrId)) {
            // SSR ONLY: we've been given an SSR id, so the host element
            // should be given the ssr id attribute
            domApi.$setAttribute(oldVNode.elm, SSR_VNODE_ID, ssrId);
        }
        // return our new vnode
        return newVNode;
    };
}
function callNodeRefs(vNode, isDestroy) {
    if (vNode) {
        vNode.vref && vNode.vref(isDestroy ? null : vNode.elm);
        vNode.vchildren && vNode.vchildren.forEach(vChild => {
            callNodeRefs(vChild, isDestroy);
        });
    }
}
function hasChildNodes(children) {
    // SSR ONLY: check if there are any more nested child elements
    // if there aren't, this info is useful so the client runtime
    // doesn't have to climb down and check so many elements
    if (children) {
        for (var i = 0; i < children.length; i++) {
            if (children[i].vtag !== 'slot' || hasChildNodes(children[i].vchildren)) {
                return true;
            }
        }
    }
    return false;
}

function initEventEmitters(plt, componentEvents, instance) {
    if (componentEvents) {
        componentEvents.forEach(eventMeta => {
            instance[eventMeta.eventMethodName] = {
                emit: (data) => {
                    const eventData = {
                        bubbles: eventMeta.eventBubbles,
                        composed: eventMeta.eventComposed,
                        cancelable: eventMeta.eventCancelable,
                        detail: data
                    };
                    plt.emitEvent(instance.__el, eventMeta.eventName, eventData);
                }
            };
        });
    }
}

function parseComponentLoaders(cmpRegistryData, registry, attr) {
    // tag name will always be lower case
    const cmpMeta = {
        tagNameMeta: cmpRegistryData[0],
        membersMeta: {
            // every component defaults to always have
            // the mode and color properties
            // but only color should observe any attribute changes
            'mode': { memberType: 1 /* Prop */ },
            'color': { memberType: 1 /* Prop */, attribName: 'color' }
        }
    };
    // map of the modes w/ bundle id and style data
    cmpMeta.bundleIds = cmpRegistryData[1];
    // parse member meta
    // this data only includes props that are attributes that need to be observed
    // it does not include all of the props yet
    parseMembersData(cmpMeta, cmpRegistryData[3], attr);
    // encapsulation
    cmpMeta.encapsulation = cmpRegistryData[4];
    // slot
    cmpMeta.slotMeta = cmpRegistryData[5];
    if (cmpRegistryData[6]) {
        // parse listener meta
        cmpMeta.listenersMeta = cmpRegistryData[6].map(parseListenerData);
    }
    // bundle load priority
    cmpMeta.loadPriority = cmpRegistryData[7];
    return registry[cmpMeta.tagNameMeta] = cmpMeta;
}
function parseListenerData(listenerData) {
    return {
        eventName: listenerData[0],
        eventMethodName: listenerData[1],
        eventDisabled: !!listenerData[2],
        eventPassive: !!listenerData[3],
        eventCapture: !!listenerData[4]
    };
}
function parseMembersData(cmpMeta, memberData, attr) {
    if (memberData) {
        cmpMeta.membersMeta = cmpMeta.membersMeta || {};
        for (var i = 0; i < memberData.length; i++) {
            var d = memberData[i];
            cmpMeta.membersMeta[d[0]] = {
                memberType: d[1],
                attribName: d[2] ? attr === 1 /* LowerCase */ ? toLowerCase(d[0]) : toDashCase(d[0]) : 0,
                propType: d[3],
                ctrlId: d[4]
            };
        }
    }
}
function parseComponentMeta(registry, moduleImports, cmpMetaData, attr) {
    // tag name will always be lowser case
    const cmpMeta = registry[cmpMetaData[0]];
    // get the component class which was added to moduleImports
    // using the tag as the key on the export object
    cmpMeta.componentModule = moduleImports[cmpMetaData[0]];
    // component members
    parseMembersData(cmpMeta, cmpMetaData[1], attr);
    // host element meta
    cmpMeta.hostMeta = cmpMetaData[2];
    // component instance events
    if (cmpMetaData[3]) {
        cmpMeta.eventsMeta = cmpMetaData[3].map(parseEventData);
    }
    // component instance prop WILL change methods
    cmpMeta.propsWillChangeMeta = cmpMetaData[4];
    // component instance prop DID change methods
    cmpMeta.propsDidChangeMeta = cmpMetaData[5];
}
function parseEventData(d) {
    return {
        eventName: d[0],
        eventMethodName: d[1] || d[0],
        eventBubbles: !d[2],
        eventCancelable: !d[3],
        eventComposed: !d[4]
    };
}
function parsePropertyValue(propType, propValue) {
    // ensure this value is of the correct prop type
    if (isDef(propValue)) {
        if (propType === 3 /* Boolean */) {
            // per the HTML spec, any string value means it is a boolean true value
            // but we'll cheat here and say that the string "false" is the boolean false
            return (propValue === 'false' ? false : propValue === '' || !!propValue);
        }
        if (propType === 4 /* Number */) {
            // force it to be a number
            return parseFloat(propValue);
        }
    }
    // not sure exactly what type we want
    // so no need to change to a different type
    return propValue;
}

function proxyHostElementPrototype(plt, membersMeta, hostPrototype) {
    // create getters/setters on the host element prototype to represent the public API
    // the setters allows us to know when data has changed so we can re-render
    membersMeta && Object.keys(membersMeta).forEach(memberName => {
        // add getters/setters
        const memberType = membersMeta[memberName].memberType;
        if (memberType === 1 /* Prop */ || memberType === 2 /* PropMutable */) {
            // @Prop() or @Prop({ mutable: true })
            definePropertyGetterSetter(hostPrototype, memberName, function getHostElementProp() {
                // host element getter (cannot be arrow fn)
                // yup, ugly, srynotsry
                // but its creating _values if it doesn't already exist
                return (this._values = this._values || {})[memberName];
            }, function setHostElementProp(newValue) {
                // host element setter (cannot be arrow fn)
                setValue(plt, this, memberName, newValue);
            });
        }
        else if (memberType === 6 /* Method */) {
            // @Method()
            // add a placeholder noop value on the host element's prototype
            // incase this method gets called before setup
            definePropertyValue(hostPrototype, memberName, noop);
        }
    });
}
function proxyComponentInstance(plt, cmpMeta, elm, instance) {
    // at this point we've got a specific node of a host element, and created a component class instance
    // and we've already created getters/setters on both the host element and component class prototypes
    // let's upgrade any data that might have been set on the host element already
    // and let's have the getters/setters kick in and do their jobs
    // let's automatically add a reference to the host element on the instance
    instance.__el = elm;
    // create the _values object if it doesn't already exist
    // this will hold all of the internal getter/setter values
    elm._values = elm._values || {};
    cmpMeta.membersMeta && Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        defineMember(plt, cmpMeta, elm, instance, memberName);
    });
}
function defineMember(plt, cmpMeta, elm, instance, memberName) {
    const memberMeta = cmpMeta.membersMeta[memberName];
    const memberType = memberMeta.memberType;
    function getComponentProp() {
        // component instance prop/state getter
        // get the property value directly from our internal values
        const elm = this.__el;
        return elm && elm._values && elm._values[memberName];
    }
    function setComponentProp(newValue) {
        // component instance prop/state setter (cannot be arrow fn)
        const elm = this.__el;
        if (elm) {
            if (memberType !== 1 /* Prop */) {
                setValue(plt, elm, memberName, newValue);
            }
            else if (Build.verboseError) {
                console.warn(`@Prop() "${memberName}" on "${elm.tagName}" cannot be modified.`);
            }
        }
    }
    if (memberType === 1 /* Prop */ || memberType === 5 /* State */ || memberType === 2 /* PropMutable */) {
        if (memberType !== 5 /* State */) {
            if (memberMeta.attribName && (elm._values[memberName] === undefined || elm._values[memberName] === '')) {
                // check the prop value from the host element attribute
                const hostAttrValue = elm.getAttribute(memberMeta.attribName);
                if (hostAttrValue != null) {
                    // looks like we've got an attribute value
                    // let's set it to our internal values
                    elm._values[memberName] = parsePropertyValue(memberMeta.propType, hostAttrValue);
                }
            }
            if (elm.hasOwnProperty(memberName)) {
                // @Prop or @Prop({mutable:true})
                // property values on the host element should override
                // any default values on the component instance
                if (elm._values[memberName] === undefined) {
                    elm._values[memberName] = elm[memberName];
                }
                if (plt.isClient) {
                    // within the browser, the element's prototype
                    // already has its getter/setter set, but on the
                    // server the prototype is shared causing issues
                    // so instead the server's elm has the getter/setter
                    // on the actual element instance, not its prototype
                    // for the client, let's delete its "own" property
                    delete elm[memberName];
                }
            }
        }
        if (instance.hasOwnProperty(memberName) && elm._values[memberName] === undefined) {
            // @Prop() or @Prop({mutable:true}) or @State()
            // we haven't yet got a value from the above checks so let's
            // read any "own" property instance values already set
            // to our internal value as the source of getter data
            // we're about to define a property and it'll overwrite this "own" property
            elm._values[memberName] = instance[memberName];
        }
        // add getter/setter to the component instance
        // these will be pointed to the internal data set from the above checks
        definePropertyGetterSetter(instance, memberName, getComponentProp, setComponentProp);
        // add watchers to props if they exist
        if (Build.propDidChange) {
            proxyPropChangeMethods(cmpMeta.propsWillChangeMeta, PROP_WILL_CHG, elm, instance, memberName);
        }
        if (Build.propWillChange) {
            proxyPropChangeMethods(cmpMeta.propsDidChangeMeta, PROP_DID_CHG, elm, instance, memberName);
        }
    }
    else if (Build.element && memberType === 7 /* Element */) {
        // @Element()
        // add a getter to the element reference using
        // the member name the component meta provided
        definePropertyValue(instance, memberName, elm);
    }
    else if (Build.method && memberType === 6 /* Method */) {
        // @Method()
        // add a property "value" on the host element
        // which we'll bind to the instance's method
        definePropertyValue(elm, memberName, instance[memberName].bind(instance));
    }
    else if (Build.propContext && memberType === 3 /* PropContext */) {
        // @Prop({ context: 'config' })
        var contextObj = plt.getContextItem(memberMeta.ctrlId);
        if (contextObj) {
            definePropertyValue(instance, memberName, (contextObj.getContext && contextObj.getContext(elm)) || contextObj);
        }
    }
    else if (Build.propConnect && memberType === 4 /* PropConnect */) {
        // @Prop({ connect: 'ion-loading-ctrl' })
        definePropertyValue(instance, memberName, plt.propConnect(memberMeta.ctrlId));
    }
}
function proxyPropChangeMethods(propChangeMeta, prefix, elm, instance, memberName) {
    // there are prop WILL change methods for this component
    const propChangeMthd = propChangeMeta && propChangeMeta.find(m => m[0 /* PropName */] === memberName);
    if (propChangeMthd) {
        // cool, we should watch for changes to this property
        // let's bind their watcher function and add it to our list
        // of watchers, so any time this property changes we should
        // also fire off their method
        elm._values[prefix + memberName] = instance[propChangeMthd[1 /* MethodName */]].bind(instance);
    }
}
function setValue(plt, elm, memberName, newVal) {
    // get the internal values object, which should always come from the host element instance
    // create the _values object if it doesn't already exist
    const internalValues = (elm._values = elm._values || {});
    // check our new property value against our internal value
    const oldVal = internalValues[memberName];
    if (newVal !== oldVal) {
        // gadzooks! the property's value has changed!!
        if (Build.propWillChange && internalValues[PROP_WILL_CHG + memberName]) {
            // this instance is watching for when this property WILL change
            internalValues[PROP_WILL_CHG + memberName](newVal, oldVal);
        }
        // set our new value!
        // https://youtu.be/dFtLONl4cNc?t=22
        internalValues[memberName] = newVal;
        if (Build.propDidChange && internalValues[PROP_DID_CHG + memberName]) {
            // this instance is watching for when this property DID change
            internalValues[PROP_DID_CHG + memberName](newVal, oldVal);
        }
        if (elm._instance && !plt.activeRender) {
            // looks like this value actually changed, so we've got work to do!
            // but only if we've already created an instance, otherwise just chill out
            // queue that we need to do an update, but don't worry about queuing
            // up millions cuz this function ensures it only runs once
            queueUpdate(plt, elm);
        }
    }
}
function definePropertyValue(obj, propertyKey, value) {
    // minification shortcut
    Object.defineProperty(obj, propertyKey, {
        'configurable': true,
        'value': value
    });
}
function definePropertyGetterSetter(obj, propertyKey, get, set) {
    // minification shortcut
    Object.defineProperty(obj, propertyKey, {
        'configurable': true,
        'get': get,
        'set': set
    });
}
function proxyController(domApi, controllerComponents, ctrlTag) {
    return {
        'create': proxyProp(domApi, controllerComponents, ctrlTag, 'create'),
        'componentOnReady': proxyProp(domApi, controllerComponents, ctrlTag, 'componentOnReady')
    };
}
function loadComponent(domApi, controllerComponents, ctrlTag) {
    return new Promise(resolve => {
        let ctrlElm = controllerComponents[ctrlTag];
        if (!ctrlElm) {
            ctrlElm = domApi.$body.querySelector(ctrlTag);
        }
        if (!ctrlElm) {
            ctrlElm = controllerComponents[ctrlTag] = domApi.$createElement(ctrlTag);
            domApi.$appendChild(domApi.$body, ctrlElm);
        }
        ctrlElm.componentOnReady(resolve);
    });
}
function proxyProp(domApi, controllerComponents, ctrlTag, proxyMethodName) {
    return function () {
        const args = arguments;
        return loadComponent(domApi, controllerComponents, ctrlTag)
            .then(ctrlElm => ctrlElm[proxyMethodName].apply(ctrlElm, args));
    };
}
const PROP_WILL_CHG = '$$wc';
const PROP_DID_CHG = '$$dc';

function initComponentInstance(plt, elm, cmpMeta) {
    try {
        // using the user's component class, let's create a new instance
        cmpMeta = plt.getComponentMeta(elm);
        elm._instance = new cmpMeta.componentModule();
        // ok cool, we've got an host element now, and a actual instance
        // and there were no errors creating the instance
        // let's upgrade the data on the host element
        // and let the getters/setters do their jobs
        proxyComponentInstance(plt, cmpMeta, elm, elm._instance);
        if (Build.event) {
            // add each of the event emitters which wire up instance methods
            // to fire off dom events from the host element
            initEventEmitters(plt, cmpMeta.eventsMeta, elm._instance);
        }
        if (Build.listener) {
            try {
                // replay any event listeners on the instance that
                // were queued up between the time the element was
                // connected and before the instance was ready
                replayQueuedEventsOnInstance(elm);
            }
            catch (e) {
                plt.onError(e, 2 /* QueueEventsError */, elm);
            }
        }
    }
    catch (e) {
        // something done went wrong trying to create a component instance
        // create a dumby instance so other stuff can load
        // but chances are the app isn't fully working cuz this component has issues
        elm._instance = {};
        plt.onError(e, 7 /* InitInstanceError */, elm, true);
    }
}
function initLoad(plt, elm, hydratedCssClass) {
    // all is good, this component has been told it's time to finish loading
    // it's possible that we've already decided to destroy this element
    // check if this element has any actively loading child elements
    if (elm._instance && !elm._hasDestroyed && (!elm.$activeLoading || !elm.$activeLoading.length)) {
        // cool, so at this point this element isn't already being destroyed
        // and it does not have any child elements that are still loading
        // ensure we remove any child references cuz it doesn't matter at this point
        elm.$activeLoading = null;
        // sweet, this particular element is good to go
        // all of this element's children have loaded (if any)
        elm._hasLoaded = true;
        try {
            // fire off the ref if it exists
            callNodeRefs(elm._vnode);
            // fire off the user's elm.componentOnReady() callbacks that were
            // put directly on the element (well before anything was ready)
            if (elm._onReadyCallbacks) {
                elm._onReadyCallbacks.forEach(cb => cb(elm));
                elm._onReadyCallbacks = null;
            }
            if (Build.cmpDidLoad) {
                // fire off the user's componentDidLoad method (if one was provided)
                // componentDidLoad only runs ONCE, after the instance's element has been
                // assigned as the host element, and AFTER render() has been called
                // we'll also fire this method off on the element, just to
                elm._instance.componentDidLoad && elm._instance.componentDidLoad();
            }
        }
        catch (e) {
            plt.onError(e, 4 /* DidLoadError */, elm);
        }
        // add the css class that this element has officially hydrated
        elm.classList.add(hydratedCssClass);
        // ( •_•)
        // ( •_•)>⌐■-■
        // (⌐■_■)
        // load events fire from bottom to top
        // the deepest elements load first then bubbles up
        propagateElementLoaded(elm);
    }
}
function propagateElementLoaded(elm, index, ancestorsActivelyLoadingChildren) {
    // load events fire from bottom to top
    // the deepest elements load first then bubbles up
    if (elm._ancestorHostElement) {
        // ok so this element already has a known ancestor host element
        // let's make sure we remove this element from its ancestor's
        // known list of child elements which are actively loading
        ancestorsActivelyLoadingChildren = elm._ancestorHostElement.$activeLoading;
        if (ancestorsActivelyLoadingChildren) {
            index = ancestorsActivelyLoadingChildren.indexOf(elm);
            if (index > -1) {
                // yup, this element is in the list of child elements to wait on
                // remove it so we can work to get the length down to 0
                ancestorsActivelyLoadingChildren.splice(index, 1);
            }
            // the ancestor's initLoad method will do the actual checks
            // to see if the ancestor is actually loaded or not
            // then let's call the ancestor's initLoad method if there's no length
            // (which actually ends up as this method again but for the ancestor)
            !ancestorsActivelyLoadingChildren.length && elm._ancestorHostElement.$initLoad();
        }
        // fuhgeddaboudit, no need to keep a reference after this element loaded
        elm._ancestorHostElement = null;
    }
}

function createThemedClasses(mode, color, classList) {
    const allClasses = {};
    return classList.split(' ')
        .reduce((classObj, classString) => {
        classObj[classString] = true;
        if (mode) {
            classObj[`${classString}-${mode}`] = true;
            if (color) {
                classObj[`${classString}-${color}`] = true;
                classObj[`${classString}-${mode}-${color}`] = true;
            }
        }
        return classObj;
    }, allClasses);
}

class VNode {
}

/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
const stack = [];
function h(nodeName, vnodeData, child) {
    var children;
    var lastSimple = false;
    var simple = false;
    for (var i = arguments.length; i-- > 2;) {
        stack.push(arguments[i]);
    }
    while (stack.length) {
        if ((child = stack.pop()) && child.pop !== undefined) {
            for (i = child.length; i--;) {
                stack.push(child[i]);
            }
        }
        else {
            if (typeof child === 'boolean')
                child = null;
            if ((simple = typeof nodeName !== 'function')) {
                if (child == null)
                    child = '';
                else if (typeof child === 'number')
                    child = String(child);
                else if (typeof child !== 'string')
                    simple = false;
            }
            if (simple && lastSimple) {
                children[children.length - 1].vtext += child;
            }
            else if (children === undefined) {
                children = [simple ? t(child) : child];
            }
            else {
                children.push(simple ? t(child) : child);
            }
            lastSimple = simple;
        }
    }
    const vnode = new VNode();
    vnode.vtag = nodeName;
    vnode.vchildren = children;
    if (vnodeData) {
        vnode.vattrs = vnodeData;
        vnode.vkey = vnodeData.key;
        vnode.vref = vnodeData.ref;
        // normalize class / classname attributes
        if (vnodeData['className']) {
            vnodeData['class'] = vnodeData['className'];
        }
        if (typeof vnodeData['class'] === 'object') {
            for (i in vnodeData['class']) {
                if (vnodeData['class'][i]) {
                    stack.push(i);
                }
            }
            vnodeData['class'] = stack.join(' ');
            stack.length = 0;
        }
    }
    return vnode;
}
function t(textValue) {
    const vnode = new VNode();
    vnode.vtext = textValue;
    return vnode;
}

function render(plt, elm, cmpMeta, isUpdateRender) {
    const instance = elm._instance;
    // if this component has a render function, let's fire
    // it off and generate the child vnodes for this host element
    // note that we do not create the host element cuz it already exists
    const hostMeta = cmpMeta.hostMeta;
    if (instance.render || instance.hostData || hostMeta) {
        // tell the platform we're actively rendering
        // if a value is changed within a render() then
        // this tells the platform not to queue the change
        plt.activeRender = true;
        const vnodeChildren = instance.render && instance.render();
        let vnodeHostData;
        if (Build.hostData) {
            // user component provided a "hostData()" method
            // the returned data/attributes are used on the host element
            vnodeHostData = instance.hostData && instance.hostData();
        }
        // tell the platform we're done rendering
        // now any changes will again queue
        plt.activeRender = false;
        if (Build.hostTheme && hostMeta) {
            // component meta data has a "theme"
            // use this to automatically generate a good css class
            // from the mode and color to add to the host element
            vnodeHostData = Object.keys(hostMeta).reduce((hostData, key) => {
                switch (key) {
                    case 'theme':
                        hostData['class'] = hostData['class'] || {};
                        hostData['class'] = Object.assign(hostData['class'], createThemedClasses(instance.mode, instance.color, hostMeta['theme']));
                }
                return hostData;
            }, vnodeHostData || {});
        }
        // looks like we've got child nodes to render into this host element
        // or we need to update the css class/attrs on the host element
        // if we haven't already created a vnode, then we give the renderer the actual element
        // if this is a re-render, then give the renderer the last vnode we already created
        const oldVNode = elm._vnode || new VNode();
        oldVNode.elm = elm;
        // each patch always gets a new vnode
        // the host element itself isn't patched because it already exists
        // kick off the actual render and any DOM updates
        elm._vnode = plt.render(oldVNode, h(null, vnodeHostData, vnodeChildren), isUpdateRender, elm._hostContentNodes, cmpMeta.encapsulation);
    }
    if (Build.styles) {
        // attach the styles this component needs, if any
        // this fn figures out if the styles should go in a
        // shadow root or if they should be global
        plt.attachStyles(cmpMeta, instance.mode, elm);
    }
    // it's official, this element has rendered
    elm.$rendered = true;
    if (elm.$onRender) {
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        elm.$onRender.forEach(cb => cb());
        elm.$onRender = null;
    }
}

function queueUpdate(plt, elm) {
    // only run patch if it isn't queued already
    if (!elm._isQueuedForUpdate) {
        elm._isQueuedForUpdate = true;
        // run the patch in the next tick
        plt.queue.add(() => {
            // no longer queued
            elm._isQueuedForUpdate = false;
            // vdom diff and patch the host element for differences
            update(plt, elm);
        });
    }
}
function update(plt, elm) {
    // everything is async, so somehow we could have already disconnected
    // this node, so be sure to do nothing if we've already disconnected
    if (!elm._hasDestroyed) {
        const isInitialLoad = !elm._instance;
        let userPromise;
        if (isInitialLoad) {
            const ancestorHostElement = elm._ancestorHostElement;
            if (ancestorHostElement && !ancestorHostElement.$rendered) {
                // this is the intial load
                // this element has an ancestor host element
                // but the ancestor host element has NOT rendered yet
                // so let's just cool our jets and wait for the ancestor to render
                (ancestorHostElement.$onRender = ancestorHostElement.$onRender || []).push(() => {
                    // this will get fired off when the ancestor host element
                    // finally gets around to rendering its lazy self
                    update(plt, elm);
                });
                return;
            }
            // haven't created a component instance for this host element yet!
            // create the instance from the user's component class
            // https://www.youtube.com/watch?v=olLxrojmvMg
            initComponentInstance(plt, elm);
            if (Build.cmpWillLoad) {
                // fire off the user's componentWillLoad method (if one was provided)
                // componentWillLoad only runs ONCE, after instance's element has been
                // assigned as the host element, but BEFORE render() has been called
                try {
                    if (elm._instance.componentWillLoad) {
                        userPromise = elm._instance.componentWillLoad();
                    }
                }
                catch (e) {
                    plt.onError(e, 3 /* WillLoadError */, elm);
                }
            }
        }
        else if (Build.cmpWillUpdate) {
            // already created an instance and this is an update
            // fire off the user's componentWillUpdate method (if one was provided)
            // componentWillUpdate runs BEFORE render() has been called
            // but only BEFORE an UPDATE and not before the intial render
            // get the returned promise (if one was provided)
            try {
                if (elm._instance.componentWillUpdate) {
                    userPromise = elm._instance.componentWillUpdate();
                }
            }
            catch (e) {
                plt.onError(e, 5 /* WillUpdateError */, elm);
            }
        }
        if (userPromise && userPromise.then) {
            // looks like the user return a promise!
            // let's not actually kick off the render
            // until the user has resolved their promise
            userPromise.then(() => renderUpdate(plt, elm, isInitialLoad));
        }
        else {
            // user never returned a promise so there's
            // no need to wait on anything, let's do the render now my friend
            renderUpdate(plt, elm, isInitialLoad);
        }
    }
}
function renderUpdate(plt, elm, isInitialLoad) {
    // if this component has a render function, let's fire
    // it off and generate a vnode for this
    try {
        render(plt, elm, plt.getComponentMeta(elm), !isInitialLoad);
        // _hasRendered was just set
        // _onRenderCallbacks were all just fired off
    }
    catch (e) {
        plt.onError(e, 8 /* RenderError */, elm, true);
    }
    try {
        if (isInitialLoad) {
            // so this was the initial load i guess
            elm.$initLoad();
            // componentDidLoad just fired off
        }
        else {
            if (Build.cmpDidUpdate) {
                // fire off the user's componentDidUpdate method (if one was provided)
                // componentDidUpdate runs AFTER render() has been called
                // but only AFTER an UPDATE and not after the intial render
                elm._instance.componentDidUpdate && elm._instance.componentDidUpdate();
            }
        }
    }
    catch (e) {
        // derp
        plt.onError(e, 6 /* DidUpdateError */, elm, true);
    }
}

function connectedCallback(plt, cmpMeta, elm) {
    // do not reconnect if we've already created an instance for this element
    if (!elm.$connected) {
        // first time we've connected
        elm.$connected = true;
        // if somehow this node was reused, ensure we've removed this property
        elm._hasDestroyed = null;
        if (Build.listener) {
            // initialize our event listeners on the host element
            // we do this now so that we can listening to events that may
            // have fired even before the instance is ready
            initElementListeners(plt, elm);
        }
        // register this component as an actively
        // loading child to its parent component
        registerWithParentComponent(plt, elm);
        // add to the queue to load the bundle
        // it's important to have an async tick in here so we can
        // ensure the "mode" attribute has been added to the element
        // place in high priority since it's not much work and we need
        // to know as fast as possible, but still an async tick in between
        plt.queue.add(() => {
            // only collects slot references if this component even has slots
            plt.connectHostElement(cmpMeta, elm);
            // start loading this component mode's bundle
            // if it's already loaded then the callback will be synchronous
            plt.loadBundle(cmpMeta, elm, () => 
            // we've fully loaded the component mode data
            // let's queue it up to be rendered next
            queueUpdate(plt, elm));
        }, 3 /* High */);
    }
}
function registerWithParentComponent(plt, elm, ancestorHostElement) {
    // find the first ancestor host element (if there is one) and register
    // this element as one of the actively loading child elements for its ancestor
    ancestorHostElement = elm;
    while (ancestorHostElement = plt.domApi.$parentElement(ancestorHostElement)) {
        // climb up the ancestors looking for the first registered component
        if (plt.isDefinedComponent(ancestorHostElement)) {
            // we found this elements the first ancestor host element
            // if the ancestor already loaded then do nothing, it's too late
            if (!ancestorHostElement._hasLoaded) {
                // keep a reference to this element's ancestor host element
                elm._ancestorHostElement = ancestorHostElement;
                // ensure there is an array to contain a reference to each of the child elements
                // and set this element as one of the ancestor's child elements it should wait on
                (ancestorHostElement.$activeLoading = ancestorHostElement.$activeLoading || []).push(elm);
            }
            break;
        }
    }
}

function createDomApi(win, doc, WindowCustomEvent) {
    // using the $ prefix so that closure is
    // cool with property renaming each of these
    const domApi = {
        $documentElement: doc.documentElement,
        $head: doc.head,
        $body: doc.body,
        $nodeType: (node) => node.nodeType,
        $createElement: (tagName) => doc.createElement(tagName),
        $createElementNS: (namespace, tagName) => doc.createElementNS(namespace, tagName),
        $createTextNode: (text) => doc.createTextNode(text),
        $createComment: (data) => doc.createComment(data),
        $insertBefore: (parentNode, childNode, referenceNode) => parentNode.insertBefore(childNode, referenceNode),
        $removeChild: (parentNode, childNode) => parentNode.removeChild(childNode),
        $appendChild: (parentNode, childNode) => parentNode.appendChild(childNode),
        $childNodes: (node) => node.childNodes,
        $parentNode: (node) => node.parentNode,
        $nextSibling: (node) => node.nextSibling,
        $tagName: (elm) => toLowerCase(elm.tagName),
        $getTextContent: (node) => node.textContent,
        $setTextContent: (node, text) => node.textContent = text,
        $getAttribute: (elm, key) => elm.getAttribute(key),
        $setAttribute: (elm, key, val) => elm.setAttribute(key, val),
        $setAttributeNS: (elm, namespaceURI, qualifiedName, val) => elm.setAttributeNS(namespaceURI, qualifiedName, val),
        $removeAttribute: (elm, key) => elm.removeAttribute(key),
        $addEventListener: (elm, eventName, eventListener, useCapture, usePassive, eventListenerOpts) => {
            eventListenerOpts = domApi.$supportsEventOptions ? {
                capture: !!useCapture,
                passive: !!usePassive
            } : !!useCapture;
            // ok, good to go, let's add the actual listener to the dom element
            elm.addEventListener(eventName, eventListener, eventListenerOpts);
            // return a function which is used to remove this very same listener
            return () => elm && elm.removeEventListener(eventName, eventListener, eventListenerOpts);
        },
        $elementRef: (elm, referenceName) => {
            if (referenceName === 'child') {
                return elm.firstElementChild;
            }
            if (referenceName === 'parent') {
                return domApi.$parentElement(elm);
            }
            if (referenceName === 'body') {
                return domApi.$body;
            }
            if (referenceName === 'document') {
                return doc;
            }
            if (referenceName === 'window') {
                return win;
            }
            return elm;
        }
    };
    if (Build.shadowDom) {
        domApi.$attachShadow = (elm, shadowRootInit) => elm.attachShadow(shadowRootInit);
        domApi.$supportsShadowDom = !!domApi.$documentElement.attachShadow;
    }
    if (Build.event) {
        WindowCustomEvent = win.CustomEvent;
        if (typeof WindowCustomEvent !== 'function') {
            // CustomEvent polyfill
            WindowCustomEvent = (event, data, evt) => {
                evt = doc.createEvent('CustomEvent');
                evt.initCustomEvent(event, data.bubbles, data.cancelable, data.detail);
                return evt;
            };
            WindowCustomEvent.prototype = win.Event.prototype;
        }
        // test if this browser supports event options or not
        try {
            win.addEventListener('e', null, Object.defineProperty({}, 'passive', {
                get: () => domApi.$supportsEventOptions = true
            }));
        }
        catch (e) { }
        domApi.$dispatchEvent = (elm, eventName, data) => elm && elm.dispatchEvent(new WindowCustomEvent(eventName, data));
    }
    domApi.$parentElement = (elm, parentNode) => {
        // if the parent node is a document fragment (shadow root)
        // then use the "host" property on it
        // otherwise use the parent node
        parentNode = domApi.$parentNode(elm);
        return (parentNode && domApi.$nodeType(parentNode) === 11 /* DocumentFragment */) ? parentNode.host : parentNode;
    };
    return domApi;
}

function assignHostContentSlots(domApi, cmpMeta, elm, childNodes) {
    // compiler has already figured out if this component has slots or not
    // if the component doesn't even have slots then we'll skip over all of this code
    if (cmpMeta.slotMeta) {
        // looks like this component has slots
        // so let's loop through each of the childNodes to the host element
        // and pick out the ones that have a slot attribute
        // if it doesn't have a slot attribute, than it's a default slot
        if (!elm.$defaultHolder) {
            // create a comment to represent where the original
            // content was first placed, which is useful later on
            domApi.$insertBefore(elm, (elm.$defaultHolder = domApi.$createComment('')), childNodes[0]);
        }
        let slotName;
        let defaultSlot;
        let namedSlots;
        let i = 0;
        for (; i < childNodes.length; i++) {
            var childNode = childNodes[i];
            if (domApi.$nodeType(childNode) === 1 /* ElementNode */ && ((slotName = domApi.$getAttribute(childNode, 'slot')) != null)) {
                // is element node
                // this element has a slot name attribute
                // so this element will end up getting relocated into
                // the component's named slot once it renders
                namedSlots = namedSlots || {};
                if (namedSlots[slotName]) {
                    namedSlots[slotName].push(childNode);
                }
                else {
                    namedSlots[slotName] = [childNode];
                }
            }
            else {
                // this is a text node
                // or it's an element node that doesn't have a slot attribute
                // let's add this node to our collection for the default slot
                if (defaultSlot) {
                    defaultSlot.push(childNode);
                }
                else {
                    defaultSlot = [childNode];
                }
            }
        }
        // keep a reference to all of the initial nodes
        // found as immediate childNodes to the host element
        elm._hostContentNodes = {
            defaultSlot: defaultSlot,
            namedSlots: namedSlots
        };
    }
}

function createQueueServer() {
    const highCallbacks = [];
    const mediumCallbacks = [];
    const lowCallbacks = [];
    let queued = false;
    function flush(cb) {
        while (highCallbacks.length > 0) {
            highCallbacks.shift()();
        }
        while (mediumCallbacks.length > 0) {
            mediumCallbacks.shift()();
        }
        while (lowCallbacks.length > 0) {
            lowCallbacks.shift()();
        }
        queued = (highCallbacks.length > 0) || (mediumCallbacks.length > 0) || (lowCallbacks.length > 0);
        if (queued) {
            process.nextTick(flush);
        }
        cb && cb();
    }
    function add(cb, priority) {
        if (priority === 3 /* High */) {
            highCallbacks.push(cb);
        }
        else if (priority === 1 /* Low */) {
            lowCallbacks.push(cb);
        }
        else {
            mediumCallbacks.push(cb);
        }
        if (!queued) {
            queued = true;
            process.nextTick(flush);
        }
    }
    return {
        add: add,
        flush: flush
    };
}

function createPlatformServer(config, win, doc, domApi, diagnostics, isPrerender, ctx) {
    const registry = { 'html': {} };
    const moduleImports = {};
    const bundleCallbacks = {};
    const loadedBundles = {};
    const pendingBundleFileReads = {};
    const stylesMap = {};
    const controllerComponents = {};
    // init build context
    ctx = ctx || {};
    // initialize Core global object
    const Context = {};
    Context.addListener = noop;
    Context.enableListener = noop;
    Context.emit = noop;
    Context.isClient = false;
    Context.isServer = true;
    Context.isPrerender = isPrerender;
    Context.window = win;
    Context.location = win.location;
    Context.document = doc;
    // add the Core global to the window context
    // Note: "Core" is not on the window context on the client-side
    win.Context = Context;
    // create the app global
    const App = {};
    // add the app's global to the window context
    win[config.namespace] = App;
    // keep a global set of tags we've already defined
    const globalDefined = win.$definedComponents = win.$definedComponents || {};
    const appWwwDir = config.wwwDir;
    const appBuildDir = config.sys.path.join(config.buildDir, getAppFileName(config));
    // create the sandboxed context with a new instance of a V8 Context
    // V8 Context provides an isolated global environment
    config.sys.vm.createContext(ctx, appWwwDir, win);
    // execute the global scripts (if there are any)
    runGlobalScripts();
    // create the platform api which is used throughout common core code
    const plt = {
        attachStyles: noop,
        connectHostElement,
        defineComponent,
        domApi,
        emitEvent: noop,
        getComponentMeta,
        getContextItem,
        isDefinedComponent,
        loadBundle,
        onError,
        propConnect,
        queue: createQueueServer(),
        tmpDisconnected: false,
    };
    // create the renderer which will be used to patch the vdom
    plt.render = createRendererPatch(plt, domApi);
    // setup the root node of all things
    // which is the mighty <html> tag
    const rootElm = domApi.$documentElement;
    rootElm.$rendered = true;
    rootElm.$activeLoading = [];
    rootElm.$initLoad = function appLoadedCallback() {
        rootElm._hasLoaded = true;
        appLoaded();
    };
    function appLoaded(failureDiagnostic) {
        if (rootElm._hasLoaded || failureDiagnostic) {
            // the root node has loaded
            // and there are no css files still loading
            plt.onAppLoad && plt.onAppLoad(rootElm, stylesMap, failureDiagnostic);
        }
    }
    function connectHostElement(cmpMeta, elm) {
        // set the "mode" property
        if (!elm.mode) {
            // looks like mode wasn't set as a property directly yet
            // first check if there's an attribute
            // next check the app's global
            elm.mode = domApi.$getAttribute(elm, 'mode') || Context.mode;
        }
        // pick out all of the light dom nodes from the host element
        assignHostContentSlots(domApi, cmpMeta, elm, elm.childNodes);
    }
    function getComponentMeta(elm) {
        // registry tags are always lower-case
        return registry[elm.tagName.toLowerCase()];
    }
    function defineComponent(cmpMeta) {
        // default mode and color props
        cmpMeta.membersMeta = cmpMeta.membersMeta || {};
        cmpMeta.membersMeta.mode = { memberType: 1 /* Prop */ };
        cmpMeta.membersMeta.color = { memberType: 1 /* Prop */, attribName: 'color' };
        // registry tags are always lower-case
        const registryTag = cmpMeta.tagNameMeta.toLowerCase();
        if (!globalDefined[registryTag]) {
            globalDefined[registryTag] = true;
            registry[registryTag] = cmpMeta;
            if (cmpMeta.componentModule) {
                // for unit testing
                moduleImports[registryTag] = cmpMeta.componentModule;
            }
        }
    }
    function isDefinedComponent(elm) {
        return !!(globalDefined[elm.tagName.toLowerCase()] || registry[elm.tagName.toLowerCase()]);
    }
    App.loadComponents = function loadComponents(bundleId, importFn) {
        const args = arguments;
        // import component function
        // inject globals
        importFn(moduleImports, h, Context, appBuildDir);
        for (var i = 2; i < args.length; i++) {
            parseComponentMeta(registry, moduleImports, args[i], Context.attr);
        }
        // fire off all the callbacks waiting on this bundle to load
        var callbacks = bundleCallbacks[bundleId];
        if (callbacks) {
            for (i = 0; i < callbacks.length; i++) {
                callbacks[i]();
            }
            delete bundleCallbacks[bundleId];
        }
        // remember that we've already loaded this bundle
        loadedBundles[bundleId] = true;
    };
    App.loadStyles = function loadStyles() {
        // jsonp callback from requested bundles
        const args = arguments;
        for (var i = 0; i < args.length; i += 2) {
            stylesMap[args[i]] = args[i + 1];
        }
    };
    function loadBundle(cmpMeta, elm, cb) {
        if (cmpMeta.componentModule) {
            // we already have the module loaded
            // (this is probably a unit test)
            cb();
            return;
        }
        const bundleId = (cmpMeta.bundleIds[elm.mode] || cmpMeta.bundleIds[DEFAULT_STYLE_MODE] || cmpMeta.bundleIds).es2015;
        if (loadedBundles[bundleId]) {
            // sweet, we've already loaded this bundle
            cb();
        }
        else {
            // never seen this bundle before, let's start loading the file
            // and add it to the bundle callbacks to fire when it's loaded
            (bundleCallbacks[bundleId] = bundleCallbacks[bundleId] || []).push(cb);
            let requestBundleId = bundleId;
            if (cmpMeta.encapsulation === 2 /* ScopedCss */ || cmpMeta.encapsulation === 1 /* ShadowDom */) {
                requestBundleId += '.sc';
            }
            requestBundleId += '.js';
            // create the bundle filePath we'll be reading
            const jsFilePath = normalizePath(config.sys.path.join(appBuildDir, requestBundleId));
            if (!pendingBundleFileReads[jsFilePath]) {
                // not already actively reading this file
                // remember that we're now actively requesting this url
                pendingBundleFileReads[jsFilePath] = true;
                // let's kick off reading the bundle
                // this could come from the cache or a new readFile
                getJsFile(config.sys, ctx, jsFilePath).then(jsContent => {
                    // remove it from the list of file reads we're waiting on
                    delete pendingBundleFileReads[jsFilePath];
                    // run the code in this sandboxed context
                    config.sys.vm.runInContext(jsContent, win, { timeout: 10000 });
                }).catch(err => {
                    onError(err, 1 /* LoadBundleError */, elm, true);
                });
            }
        }
    }
    function runGlobalScripts() {
        if (!ctx || !ctx.appFiles || !ctx.appFiles.global) {
            return;
        }
        config.sys.vm.runInContext(ctx.appFiles.global, win);
    }
    function onError(err, type, elm, appFailure) {
        const d = {
            type: 'runtime',
            header: 'Runtime error detected',
            level: 'error',
            messageText: err ? err.message ? err.message : err.toString() : null
        };
        switch (type) {
            case 1 /* LoadBundleError */:
                d.header += ' while loading bundle';
                break;
            case 2 /* QueueEventsError */:
                d.header += ' while running initial events';
                break;
            case 3 /* WillLoadError */:
                d.header += ' during componentWillLoad()';
                break;
            case 4 /* DidLoadError */:
                d.header += ' during componentDidLoad()';
                break;
            case 7 /* InitInstanceError */:
                d.header += ' while initializing instance';
                break;
            case 8 /* RenderError */:
                d.header += ' while rendering';
                break;
            case 6 /* DidUpdateError */:
                d.header += ' while updating';
                break;
        }
        if (elm && elm.tagName) {
            d.header += ': ' + elm.tagName.toLowerCase();
        }
        diagnostics.push(d);
        if (appFailure) {
            appLoaded(d);
        }
    }
    function propConnect(ctrlTag) {
        return proxyController(domApi, controllerComponents, ctrlTag);
    }
    function getContextItem(contextKey) {
        return Context[contextKey];
    }
    return plt;
}

function collapseHtmlWhitepace(node) {
    // this isn't about reducing HTML filesize (cuz it doesn't really matter after gzip)
    // this is more about having many less nodes for the client side to
    // have to climb through while it's creating vnodes from this HTML
    if (WHITESPACE_SENSITIVE_TAGS.indexOf(node.tagName) > -1) {
        return;
    }
    var lastWhitespaceTextNode = null;
    for (var i = node.childNodes.length - 1; i >= 0; i--) {
        var childNode = node.childNodes[i];
        if (childNode.nodeType === 3 /* TextNode */ || childNode.nodeType === 8 /* CommentNode */) {
            childNode.nodeValue = childNode.nodeValue.replace(REDUCE_WHITESPACE_REGEX, ' ');
            if (childNode.nodeValue === ' ') {
                if (lastWhitespaceTextNode === null) {
                    childNode.nodeValue = ' ';
                    lastWhitespaceTextNode = childNode;
                }
                else {
                    childNode.parentNode.removeChild(childNode);
                }
                continue;
            }
        }
        else if (childNode.childNodes) {
            collapseHtmlWhitepace(childNode);
        }
        lastWhitespaceTextNode = null;
    }
}
const REDUCE_WHITESPACE_REGEX = /\s\s+/g;
const WHITESPACE_SENSITIVE_TAGS = ['PRE', 'SCRIPT', 'STYLE', 'TEXTAREA'];

function inlineLoaderScript(config, ctx, doc) {
    if (!ctx.appFiles || !ctx.appFiles.loader) {
        // don't bother if we don't have good loader content for whatever reason
        return;
    }
    // create the script url we'll be looking for
    let loaderExternalSrcUrl = config.publicPath;
    if (loaderExternalSrcUrl.charAt(loaderExternalSrcUrl.length - 1) !== '/') {
        loaderExternalSrcUrl += '/';
    }
    loaderExternalSrcUrl += getAppFileName(config) + '.js';
    // remove the app loader script url request
    const removedLoader = removeExternalLoaderScript(doc, loaderExternalSrcUrl);
    if (removedLoader) {
        // append the loader script content to the bottom of the document
        appendInlineLoaderScript(ctx, doc);
    }
}
function removeExternalLoaderScript(doc, loaderExternalSrcUrl) {
    let removedLoader = false;
    const scriptElements = doc.getElementsByTagName('script');
    for (var i = 0; i < scriptElements.length; i++) {
        if (scriptElements[i].src.indexOf(loaderExternalSrcUrl) > -1) {
            // this is a script element with a src attribute which is
            // pointing to the app's external loader script
            // remove the script from the document, be gone with you
            scriptElements[i].parentNode.removeChild(scriptElements[i]);
            removedLoader = true;
        }
    }
    return removedLoader;
}
function appendInlineLoaderScript(ctx, doc) {
    // now that we've removed the external script
    // let's add the loader script back in, except let's
    // inline the js directly into the document
    // and append it as the last child in the body
    const scriptElm = doc.createElement('script');
    scriptElm.innerHTML = ctx.appFiles.loader;
    doc.body.appendChild(scriptElm);
}

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
function parseCss(config, css, filePath) {
    /**
     * Positional.
     */
    var lineno = 1;
    var column = 1;
    var srcLines;
    /**
     * Update lineno and column based on `str`.
     */
    function updatePosition(str) {
        var lines = str.match(/\n/g);
        if (lines)
            lineno += lines.length;
        var i = str.lastIndexOf('\n');
        column = ~i ? str.length - i : column + str.length;
    }
    /**
     * Mark position and patch `node.position`.
     */
    function position() {
        var start = { line: lineno, column: column };
        return function (node) {
            node.position = new ParsePosition(start);
            whitespace();
            return node;
        };
    }
    /**
     * Store position information for a node
     */
    class ParsePosition {
        constructor(start) {
            this.start = start;
            this.end = { line: lineno, column: column };
            this.source = filePath;
        }
    }
    /**
     * Non-enumerable source string
     */
    ParsePosition.prototype.content = css;
    /**
     * Error `msg`.
     */
    var diagnostics = [];
    function error(msg) {
        if (!srcLines) {
            srcLines = css.split('\n');
        }
        const d = {
            level: 'error',
            type: 'css',
            language: 'css',
            header: 'CSS Parse',
            messageText: msg,
            absFilePath: filePath,
            lines: [{
                    lineIndex: lineno - 1,
                    lineNumber: lineno,
                    errorCharStart: column,
                    text: css[lineno - 1],
                }]
        };
        d.header = formatHeader('CSS', filePath, config.rootDir, lineno);
        if (lineno > 1) {
            const previousLine = {
                lineIndex: lineno - 1,
                lineNumber: lineno - 1,
                text: css[lineno - 2],
                errorCharStart: -1,
                errorLength: -1
            };
            d.lines.unshift(previousLine);
        }
        if (lineno + 2 < srcLines.length) {
            const nextLine = {
                lineIndex: lineno,
                lineNumber: lineno + 1,
                text: srcLines[lineno],
                errorCharStart: -1,
                errorLength: -1
            };
            d.lines.push(nextLine);
        }
        diagnostics.push(d);
    }
    /**
     * Parse stylesheet.
     */
    function stylesheet() {
        var rulesList = rules();
        return {
            type: 'stylesheet',
            stylesheet: {
                source: filePath,
                rules: rulesList,
                diagnostics: diagnostics
            }
        };
    }
    /**
     * Opening brace.
     */
    function open() {
        return match(/^{\s*/);
    }
    /**
     * Closing brace.
     */
    function close() {
        return match(/^}/);
    }
    /**
     * Parse ruleset.
     */
    function rules() {
        var node;
        var rules = [];
        whitespace();
        comments(rules);
        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
            if (node !== false) {
                rules.push(node);
                comments(rules);
            }
        }
        return rules;
    }
    /**
     * Match `re` and return captures.
     */
    function match(re) {
        var m = re.exec(css);
        if (!m)
            return;
        var str = m[0];
        updatePosition(str);
        css = css.slice(str.length);
        return m;
    }
    /**
     * Parse whitespace.
     */
    function whitespace() {
        match(/^\s*/);
    }
    /**
     * Parse comments;
     */
    function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment()) {
            if (c !== false) {
                rules.push(c);
            }
        }
        return rules;
    }
    /**
     * Parse comment.
     */
    function comment() {
        var pos = position();
        if ('/' !== css.charAt(0) || '*' !== css.charAt(1))
            return;
        var i = 2;
        while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1)))
            ++i;
        i += 2;
        if ('' === css.charAt(i - 1)) {
            return error('End of comment missing');
        }
        var str = css.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        css = css.slice(i);
        column += 2;
        return pos({
            type: 'comment',
            comment: str
        });
    }
    /**
     * Parse selector.
     */
    function selector() {
        var m = match(/^([^{]+)/);
        if (!m)
            return;
        /* @fix Remove all comments from selectors
         * http://ostermiller.org/findcomment.html */
        return trim(m[0])
            .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
            .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (m) {
            return m.replace(/,/g, '\u200C');
        })
            .split(/\s*(?![^(]*\)),\s*/)
            .map(function (s) {
            return s.replace(/\u200C/g, ',');
        });
    }
    /**
     * Parse declaration.
     */
    function declaration() {
        var pos = position();
        // prop
        var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
        if (!prop)
            return;
        prop = trim(prop[0]);
        // :
        if (!match(/^:\s*/))
            return error(`property missing ':'`);
        // val
        var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
        var ret = pos({
            type: 'declaration',
            property: prop.replace(commentre, ''),
            value: val ? trim(val[0]).replace(commentre, '') : ''
        });
        // ;
        match(/^[;\s]*/);
        return ret;
    }
    /**
     * Parse declarations.
     */
    function declarations() {
        var decls = [];
        if (!open())
            return error(`missing '{'`);
        comments(decls);
        // declarations
        var decl;
        while (decl = declaration()) {
            if (decl !== false) {
                decls.push(decl);
                comments(decls);
            }
        }
        if (!close())
            return error(`missing '}'`);
        return decls;
    }
    /**
     * Parse keyframe.
     */
    function keyframe() {
        var m;
        var vals = [];
        var pos = position();
        while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
            vals.push(m[1]);
            match(/^,\s*/);
        }
        if (!vals.length)
            return;
        return pos({
            type: 'keyframe',
            values: vals,
            declarations: declarations()
        });
    }
    /**
     * Parse keyframes.
     */
    function atkeyframes() {
        var pos = position();
        var m = match(/^@([-\w]+)?keyframes\s*/);
        if (!m)
            return;
        var vendor = m[1];
        // identifier
        m = match(/^([-\w]+)\s*/);
        if (!m)
            return error(`@keyframes missing name`);
        var name = m[1];
        if (!open())
            return error(`@keyframes missing '{'`);
        var frame;
        var frames = comments();
        while (frame = keyframe()) {
            frames.push(frame);
            frames = frames.concat(comments());
        }
        if (!close())
            return error(`@keyframes missing '}'`);
        return pos({
            type: 'keyframes',
            name: name,
            vendor: vendor,
            keyframes: frames
        });
    }
    /**
     * Parse supports.
     */
    function atsupports() {
        var pos = position();
        var m = match(/^@supports *([^{]+)/);
        if (!m)
            return;
        var supports = trim(m[1]);
        if (!open())
            return error(`@supports missing '{'`);
        var style = comments().concat(rules());
        if (!close())
            return error(`@supports missing '}'`);
        return pos({
            type: 'supports',
            supports: supports,
            rules: style
        });
    }
    /**
     * Parse host.
     */
    function athost() {
        var pos = position();
        var m = match(/^@host\s*/);
        if (!m)
            return;
        if (!open())
            return error(`@host missing '{'`);
        var style = comments().concat(rules());
        if (!close())
            return error(`@host missing '}'`);
        return pos({
            type: 'host',
            rules: style
        });
    }
    /**
     * Parse media.
     */
    function atmedia() {
        var pos = position();
        var m = match(/^@media *([^{]+)/);
        if (!m)
            return;
        var media = trim(m[1]);
        if (!open())
            return error(`@media missing '{'`);
        var style = comments().concat(rules());
        if (!close())
            return error(`@media missing '}'`);
        return pos({
            type: 'media',
            media: media,
            rules: style
        });
    }
    /**
     * Parse custom-media.
     */
    function atcustommedia() {
        var pos = position();
        var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
        if (!m)
            return;
        return pos({
            type: 'custom-media',
            name: trim(m[1]),
            media: trim(m[2])
        });
    }
    /**
     * Parse paged media.
     */
    function atpage() {
        var pos = position();
        var m = match(/^@page */);
        if (!m)
            return;
        var sel = selector() || [];
        if (!open())
            return error(`@page missing '{'`);
        var decls = comments();
        // declarations
        var decl;
        while (decl = declaration()) {
            decls.push(decl);
            decls = decls.concat(comments());
        }
        if (!close())
            return error(`@page missing '}'`);
        return pos({
            type: 'page',
            selectors: sel,
            declarations: decls
        });
    }
    /**
     * Parse document.
     */
    function atdocument() {
        var pos = position();
        var m = match(/^@([-\w]+)?document *([^{]+)/);
        if (!m)
            return;
        var vendor = trim(m[1]);
        var doc = trim(m[2]);
        if (!open())
            return error(`@document missing '{'`);
        var style = comments().concat(rules());
        if (!close())
            return error(`@document missing '}'`);
        return pos({
            type: 'document',
            document: doc,
            vendor: vendor,
            rules: style
        });
    }
    /**
     * Parse font-face.
     */
    function atfontface() {
        var pos = position();
        var m = match(/^@font-face\s*/);
        if (!m)
            return;
        if (!open())
            return error(`@font-face missing '{'`);
        var decls = comments();
        // declarations
        var decl;
        while (decl = declaration()) {
            decls.push(decl);
            decls = decls.concat(comments());
        }
        if (!close())
            return error(`@font-face missing '}'`);
        return pos({
            type: 'font-face',
            declarations: decls
        });
    }
    /**
     * Parse import
     */
    var atimport = _compileAtrule('import');
    /**
     * Parse charset
     */
    var atcharset = _compileAtrule('charset');
    /**
     * Parse namespace
     */
    var atnamespace = _compileAtrule('namespace');
    /**
     * Parse non-block at-rules
     */
    function _compileAtrule(name) {
        var re = new RegExp('^@' + name + '\\s*([^;]+);');
        return function () {
            var pos = position();
            var m = match(re);
            if (!m)
                return;
            var ret = { type: name };
            ret[name] = m[1].trim();
            return pos(ret);
        };
    }
    /**
     * Parse at rule.
     */
    function atrule() {
        if (css[0] !== '@')
            return;
        return atkeyframes()
            || atmedia()
            || atcustommedia()
            || atsupports()
            || atimport()
            || atcharset()
            || atnamespace()
            || atdocument()
            || atpage()
            || athost()
            || atfontface();
    }
    /**
     * Parse rule.
     */
    function rule() {
        var pos = position();
        var sel = selector();
        if (!sel)
            return error('selector missing');
        comments();
        return pos({
            type: 'rule',
            selectors: sel,
            declarations: declarations()
        });
    }
    return addParent(stylesheet());
}
/**
 * Trim `str`.
 */
function trim(str) {
    return str ? str.trim() : '';
}
/**
 * Adds non-enumerable parent node reference to each node.
 */
function addParent(obj, parent) {
    var isNode = obj && typeof obj.type === 'string';
    var childParent = isNode ? obj : parent;
    for (var k in obj) {
        var value = obj[k];
        if (Array.isArray(value)) {
            value.forEach(function (v) { addParent(v, childParent); });
        }
        else if (value && typeof value === 'object') {
            addParent(value, childParent);
        }
    }
    if (isNode) {
        Object.defineProperty(obj, 'parent', {
            configurable: true,
            writable: true,
            enumerable: false,
            value: parent || null
        });
    }
    return obj;
}

function getSelectors(sel) {
    // reusing global SELECTORS since this is a synchronous operation
    SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
    sel = sel.replace(/\./g, ' .')
        .replace(/\#/g, ' #')
        .replace(/\[/g, ' [')
        .replace(/\>/g, ' > ')
        .replace(/\+/g, ' + ')
        .replace(/\~/g, ' ~ ')
        .replace(/\*/g, ' * ')
        .replace(/\:not\((.*?)\)/g, ' ');
    const items = sel.split(' ');
    for (var i = 0; i < items.length; i++) {
        items[i] = items[i].split(':')[0];
        if (items[i].length === 0)
            continue;
        if (items[i].charAt(0) === '.') {
            SELECTORS.classNames.push(items[i].substr(1));
        }
        else if (items[i].charAt(0) === '#') {
            SELECTORS.ids.push(items[i].substr(1));
        }
        else if (items[i].charAt(0) === '[') {
            items[i] = items[i].substr(1).split('=')[0].split(']')[0].trim();
            SELECTORS.attrs.push(items[i].toLowerCase());
        }
        else if (/[a-z]/g.test(items[i].charAt(0))) {
            SELECTORS.tags.push(items[i].toLowerCase());
        }
    }
    SELECTORS.classNames = SELECTORS.classNames.sort((a, b) => {
        if (a.length < b.length)
            return -1;
        if (a.length > b.length)
            return 1;
        return 0;
    });
    return SELECTORS;
}
const SELECTORS = {
    all: [],
    tags: [],
    classNames: [],
    ids: [],
    attrs: []
};

/**
 * CSS stringify adopted from rework/css by
 * TJ Holowaychuk (@tj)
 * Licensed under the MIT License
 * https://github.com/reworkcss/css/blob/master/LICENSE
 */
class StringifyCss {
    constructor(opts) {
        this.usedSelectors = opts.usedSelectors;
    }
    /**
     * Visit `node`.
     */
    visit(node) {
        return this[node.type](node);
    }
    /**
     * Map visit over array of `nodes`, optionally using a `delim`
     */
    mapVisit(nodes, delim) {
        var buf = '';
        delim = delim || '';
        for (var i = 0, length = nodes.length; i < length; i++) {
            buf += this.visit(nodes[i]);
            if (delim && i < length - 1)
                buf += delim;
        }
        return buf;
    }
    /**
     * Compile `node`.
     */
    compile(node) {
        return node.stylesheet
            .rules.map(this.visit, this)
            .join('');
    }
    comment() {
        return '';
    }
    /**
     * Visit import node.
     */
    import(node) {
        return '@import ' + node.import + ';';
    }
    /**
     * Visit media node.
     */
    media(node) {
        const mediaCss = this.mapVisit(node.rules);
        if (mediaCss === '') {
            return '';
        }
        return '@media ' + node.media + '{' + this.mapVisit(node.rules) + '}';
    }
    /**
     * Visit document node.
     */
    document(node) {
        const documentCss = this.mapVisit(node.rules);
        if (documentCss === '') {
            return '';
        }
        var doc = '@' + (node.vendor || '') + 'document ' + node.document;
        return doc + '{' + documentCss + '}';
    }
    /**
     * Visit charset node.
     */
    charset(node) {
        return '@charset ' + node.charset + ';';
    }
    /**
     * Visit namespace node.
     */
    namespace(node) {
        return '@namespace ' + node.namespace + ';';
    }
    /**
     * Visit supports node.
     */
    supports(node) {
        const supportsCss = this.mapVisit(node.rules);
        if (supportsCss === '') {
            return '';
        }
        return '@supports ' + node.supports + '{' + supportsCss + '}';
    }
    /**
     * Visit keyframes node.
     */
    keyframes(node) {
        const keyframesCss = this.mapVisit(node.keyframes);
        if (keyframesCss === '') {
            return '';
        }
        return '@' + (node.vendor || '') + 'keyframes ' + node.name + '{' + keyframesCss + '}';
    }
    /**
     * Visit keyframe node.
     */
    keyframe(node) {
        var decls = node.declarations;
        return node.values.join(',') + '{' + this.mapVisit(decls) + '}';
    }
    /**
     * Visit page node.
     */
    page(node) {
        var sel = node.selectors.length
            ? node.selectors.join(', ')
            : '';
        return '@page ' + sel + '{' + this.mapVisit(node.declarations) + '}';
    }
    /**
     * Visit font-face node.
     */
    ['font-face'](node) {
        const fontCss = this.mapVisit(node.declarations);
        if (fontCss === '') {
            return '';
        }
        return '@font-face{' + fontCss + '}';
    }
    /**
     * Visit host node.
     */
    host(node) {
        return '@host{' + this.mapVisit(node.rules) + '}';
    }
    /**
     * Visit custom-media node.
     */
    ['custom-media'](node) {
        return '@custom-media ' + node.name + ' ' + node.media + ';';
    }
    /**
     * Visit rule node.
     */
    rule(node) {
        var decls = node.declarations;
        if (!decls.length)
            return '';
        var i, j;
        for (i = node.selectors.length - 1; i >= 0; i--) {
            var sel = getSelectors(node.selectors[i]);
            if (this.usedSelectors) {
                var include = true;
                // classes
                var jlen = sel.classNames.length;
                if (jlen > 0) {
                    for (j = 0; j < jlen; j++) {
                        if (this.usedSelectors.classNames.indexOf(sel.classNames[j]) === -1) {
                            include = false;
                            break;
                        }
                    }
                }
                // tags
                if (include) {
                    jlen = sel.tags.length;
                    if (jlen > 0) {
                        for (j = 0; j < jlen; j++) {
                            if (this.usedSelectors.tags.indexOf(sel.tags[j]) === -1) {
                                include = false;
                                break;
                            }
                        }
                    }
                }
                // attrs
                if (include) {
                    jlen = sel.attrs.length;
                    if (jlen > 0) {
                        for (j = 0; j < jlen; j++) {
                            if (this.usedSelectors.attrs.indexOf(sel.attrs[j]) === -1) {
                                include = false;
                                break;
                            }
                        }
                    }
                }
                // ids
                if (include) {
                    jlen = sel.ids.length;
                    if (jlen > 0) {
                        for (j = 0; j < jlen; j++) {
                            if (this.usedSelectors.ids.indexOf(sel.ids[j]) === -1) {
                                include = false;
                                break;
                            }
                        }
                    }
                }
                if (!include) {
                    node.selectors.splice(i, 1);
                }
            }
        }
        if (node.selectors.length === 0)
            return '';
        return `${node.selectors}{${this.mapVisit(decls)}}`;
    }
    /**
     * Visit declaration node.
     */
    declaration(node) {
        return node.property + ':' + node.value + ';';
    }
}

function removeUnusedStyles(config, usedSelectors, cssContent, cssFilePath, diagnostics) {
    let cleanedCss = cssContent;
    try {
        // parse the css from being applied to the document
        const cssAst = parseCss(config, cssContent, cssFilePath);
        if (cssAst.stylesheet.diagnostics.length) {
            cssAst.stylesheet.diagnostics.forEach(d => {
                diagnostics.push(d);
            });
            return cleanedCss;
        }
        try {
            // convert the parsed css back into a string
            // but only keeping what was found in our active selectors
            const stringify = new StringifyCss({ usedSelectors });
            cleanedCss = stringify.compile(cssAst);
        }
        catch (e) {
            diagnostics.push({
                level: 'error',
                type: 'css',
                header: 'CSS Stringify',
                messageText: e
            });
        }
    }
    catch (e) {
        diagnostics.push({
            level: 'error',
            type: 'css',
            absFilePath: cssFilePath,
            header: 'CSS Parse',
            messageText: e
        });
    }
    return cleanedCss;
}

class UsedSelectors {
    constructor(elm) {
        this.tags = [];
        this.classNames = [];
        this.ids = [];
        this.attrs = [];
        this.collectSelectors(elm);
    }
    collectSelectors(elm) {
        var i;
        if (elm && elm.tagName) {
            // tags
            var tagName = elm.tagName.toLowerCase();
            if (this.tags.indexOf(tagName) === -1) {
                this.tags.push(tagName);
            }
            // classes
            var classList = elm.classList;
            for (i = 0; i < classList.length; i++) {
                var className = classList[i];
                if (this.classNames.indexOf(className) === -1) {
                    this.classNames.push(className);
                }
            }
            // attributes
            var attributes = elm.attributes;
            for (i = 0; i < attributes.length; i++) {
                var attr = attributes[i];
                var attrName = attr.name.toLowerCase();
                if (!attrName || attrName === 'class' || attrName === 'id' || attrName === 'style')
                    continue;
                if (this.attrs.indexOf(attrName) === -1) {
                    this.attrs.push(attrName);
                }
            }
            // ids
            var idValue = elm.getAttribute('id');
            if (idValue) {
                idValue = idValue.trim();
                if (idValue && this.ids.indexOf(idValue) === -1) {
                    this.ids.push(idValue);
                }
            }
            // drill down
            for (i = 0; i < elm.children.length; i++) {
                this.collectSelectors(elm.children[i]);
            }
        }
    }
}

function inlineStyles(config, doc, stylesMap, opts, diagnostics) {
    const styleFileNames = Object.keys(stylesMap);
    if (!styleFileNames.length) {
        return;
    }
    let styles = [];
    if (opts.removeUnusedStyles !== false) {
        // removeUnusedStyles is the default
        try {
            // pick out all of the selectors that are actually
            // being used in the html document
            const usedSelectors = new UsedSelectors(doc.documentElement);
            const cssFilePaths = Object.keys(stylesMap);
            styles = cssFilePaths.map(styleTag => {
                return removeUnusedStyles(config, usedSelectors, stylesMap[styleTag], styleTag, diagnostics);
            });
        }
        catch (e) {
            diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'HTML Selector Parse',
                messageText: e
            });
        }
    }
    else {
        // do not removeUnusedStyles
        styles = styleFileNames.map(styleFileName => stylesMap[styleFileName]);
    }
    // insert our styles to the head of the document
    insertStyles(doc, styles);
}
function insertStyles(doc, styles) {
    if (!styles.length) {
        return;
    }
    const styleElm = doc.createElement('style');
    styleElm.setAttribute('data-styles', '');
    styleElm.innerHTML = styles.join('').trim();
    if (styleElm.innerHTML.length) {
        doc.head.insertBefore(styleElm, doc.head.firstChild);
    }
}

function insertCanonicalLink(config, doc, url) {
    if (!url)
        return;
    // https://webmasters.googleblog.com/2009/02/specify-your-canonical.html
    // <link rel="canonical" href="http://www.example.com/product.php?item=swedish-fish" />
    let canonicalLink = doc.querySelector('link[rel="canonical"]');
    if (canonicalLink)
        return;
    const parsedUrl = config.sys.url.parse(url);
    canonicalLink = doc.createElement('link');
    canonicalLink.setAttribute('rel', 'canonical');
    canonicalLink.setAttribute('href', parsedUrl.path);
    doc.head.appendChild(canonicalLink);
}

function optimizeHtml(config, ctx, doc, stylesMap, opts, results) {
    setHtmlDataSsrAttr(doc);
    if (opts.canonicalLink !== false) {
        try {
            insertCanonicalLink(config, doc, results.url);
        }
        catch (e) {
            results.diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'Insert Canonical Link',
                messageText: e
            });
        }
    }
    if (opts.inlineStyles !== false) {
        try {
            inlineStyles(config, doc, stylesMap, opts, results.diagnostics);
        }
        catch (e) {
            results.diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'Inline Styles',
                messageText: e
            });
        }
    }
    if (opts.inlineLoaderScript !== false) {
        // remove the script to the external loader script request
        // inline the loader script at the bottom of the html
        try {
            inlineLoaderScript(config, ctx, doc);
        }
        catch (e) {
            results.diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'Inline Loader Script',
                messageText: e
            });
        }
    }
    if (opts.collapseWhitespace !== false && !config.devMode) {
        // collapseWhitespace is the default
        try {
            collapseHtmlWhitepace(doc.documentElement);
        }
        catch (e) {
            results.diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'Reduce HTML Whitespace',
                messageText: e
            });
        }
    }
}
function setHtmlDataSsrAttr(doc) {
    doc.documentElement.setAttribute('data-ssr', '');
}

function hydrateHtml(config, ctx, registry, opts) {
    return new Promise(resolve => {
        const hydrateResults = {
            diagnostics: [],
            url: opts.url,
            html: opts.html,
            styles: null,
            anchors: []
        };
        const registeredTags = Object.keys(registry || {});
        let ssrIds = 0;
        // if there are no components registered at all
        // then let's skip all this (and why didn't we get components!?)
        if (registeredTags.length === 0) {
            hydrateResults.diagnostics.push({
                header: 'Hydrate Components',
                messageText: `No registered components found`,
                type: 'hydrate',
                level: 'info'
            });
            hydrateResults.html = opts.html;
            resolve(hydrateResults);
            return;
        }
        // create a emulated window
        // attach data the request to the window
        const dom = config.sys.createDom();
        const win = dom.parse(opts);
        const doc = win.document;
        const domApi = createDomApi(win, doc);
        // normalize dir and lang before connecting elements
        // so that the info is their incase they read it at runtime
        normalizeDirection(doc, opts);
        normalizeLanguage(doc, opts);
        // create the platform
        const plt = createPlatformServer(config, win, doc, domApi, hydrateResults.diagnostics, opts.isPrerender, ctx);
        // fully define each of our components onto this new platform instance
        registeredTags.forEach(registryTag => {
            registryTag = registryTag.toLowerCase();
            registry[registryTag].tagNameMeta = registryTag;
            registry[registryTag].membersMeta = registry[registryTag].membersMeta || {};
            plt.defineComponent(registry[registryTag]);
        });
        // fire off this function when the app has finished loading
        // and all components have finished hydrating
        plt.onAppLoad = (rootElm, stylesMap, failureDiagnostic) => {
            if (config._isTesting) {
                hydrateResults.__testPlatform = plt;
            }
            if (failureDiagnostic) {
                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);
                resolve(hydrateResults);
                return;
            }
            hydrateResults.root = rootElm;
            // all synchronous operations next
            if (rootElm) {
                try {
                    // optimize this document!!
                    optimizeHtml(config, ctx, doc, stylesMap, opts, hydrateResults);
                    // gather up all of the <a> tag information in the doc
                    if (opts.collectAnchors !== false) {
                        collectAnchors(doc, hydrateResults);
                    }
                    // serialize this dom back into a string
                    if (opts.serializeHtml !== false) {
                        hydrateResults.html = dom.serialize();
                    }
                    // also collect up any dom errors that may have happened
                    hydrateResults.diagnostics = hydrateResults.diagnostics.concat(dom.getDiagnostics());
                }
                catch (e) {
                    // gahh, something's up
                    hydrateResults.diagnostics.push({
                        level: 'error',
                        type: 'hydrate',
                        header: 'DOM Serialize',
                        messageText: e
                    });
                    // idk, some error, just use the original html
                    hydrateResults.html = opts.html;
                }
            }
            // cool, all good here, even if there are errors
            // we're passing back the result object
            resolve(hydrateResults);
        };
        // keep a collection of all the host elements we connected
        const connectedInfo = {
            elementCount: 0
        };
        // patch the render function that we can add SSR ids
        // and to connect any elements it may have just appened to the DOM
        const pltRender = plt.render;
        plt.render = function render(oldVNode, newVNode, isUpdate, hostContentNodes, encapsulation) {
            let ssrId;
            let existingSsrId;
            if (opts.ssrIds !== false) {
                // this may have been patched more than once
                // so reuse the ssr id if it already has one
                if (oldVNode && oldVNode.elm) {
                    existingSsrId = oldVNode.elm.getAttribute(SSR_VNODE_ID);
                }
                if (existingSsrId) {
                    ssrId = parseInt(existingSsrId, 10);
                }
                else {
                    ssrId = ssrIds++;
                }
            }
            newVNode = pltRender(oldVNode, newVNode, isUpdate, hostContentNodes, encapsulation, ssrId);
            connectElement(plt, newVNode.elm, connectedInfo, config.hydratedCssClass);
            return newVNode;
        };
        // loop through each node and start connecting/hydrating
        // any elements that are host elements to components
        // this kicks off all the async loading and hydrating
        connectElement(plt, win.document.body, connectedInfo, config.hydratedCssClass);
        if (connectedInfo.elementCount === 0) {
            // what gives, never found ANY host elements to connect!
            // ok we're just done i guess, idk
            hydrateResults.html = opts.html;
            resolve(hydrateResults);
        }
    });
}
function connectElement(plt, elm, connectedInfo, hydratedCssClass) {
    if (!elm.$connected) {
        // only connect elements which is a registered component
        const cmpMeta = plt.getComponentMeta(elm);
        if (cmpMeta && cmpMeta.encapsulation !== 1 /* ShadowDom */) {
            elm.$initLoad = () => {
                initLoad(plt, elm, hydratedCssClass);
            };
            proxyHostElementPrototype(plt, cmpMeta.membersMeta, elm);
            connectedCallback(plt, cmpMeta, elm);
            // keep count of how many host elements we actually connected
            connectedInfo.elementCount++;
        }
    }
    const elmChildren = elm.children;
    if (elmChildren) {
        // continue drilling down through child elements
        for (var i = 0, l = elmChildren.length; i < l; i++) {
            connectElement(plt, elmChildren[i], connectedInfo, hydratedCssClass);
        }
    }
}
function collectAnchors(doc, hydrateResults) {
    const anchorElements = doc.querySelectorAll('a');
    for (var i = 0; i < anchorElements.length; i++) {
        var attrs = {};
        var anchorAttrs = anchorElements[i].attributes;
        for (var j = 0; j < anchorAttrs.length; j++) {
            attrs[anchorAttrs[j].nodeName.toLowerCase()] = anchorAttrs[j].nodeValue;
        }
        hydrateResults.anchors.push(attrs);
    }
}
function normalizeDirection(doc, opts) {
    let dir = doc.body.getAttribute('dir');
    if (dir) {
        dir = dir.trim().toLowerCase();
        if (dir.trim().length > 0) {
            console.warn(`dir="${dir}" should be placed on the <html> instead of <body>`);
        }
    }
    if (opts.dir) {
        dir = opts.dir;
    }
    else {
        dir = doc.documentElement.getAttribute('dir');
    }
    if (dir) {
        dir = dir.trim().toLowerCase();
        if (dir !== 'ltr' && dir !== 'rtl') {
            console.warn(`only "ltr" and "rtl" are valid "dir" values on the <html> element`);
        }
    }
    if (dir !== 'ltr' && dir !== 'rtl') {
        dir = 'ltr';
    }
    doc.documentElement.dir = dir;
}
function normalizeLanguage(doc, opts) {
    let lang = doc.body.getAttribute('lang');
    if (lang) {
        lang = lang.trim().toLowerCase();
        if (lang.trim().length > 0) {
            console.warn(`lang="${lang}" should be placed on <html> instead of <body>`);
        }
    }
    if (opts.lang) {
        lang = opts.lang;
    }
    else {
        lang = doc.documentElement.getAttribute('lang');
    }
    if (lang) {
        lang = lang.trim().toLowerCase();
        if (lang.length > 0) {
            doc.documentElement.lang = lang;
        }
    }
}
function generateFailureDiagnostic(d) {
    return `
    <div style="padding: 20px;">
      <div style="font-weight: bold;">${d.header}</div>
      <div>${d.messageText}</div>
    </div>
  `;
}

function createRenderer(config, registry, ctx) {
    validateBuildConfig(config);
    ctx = ctx || {};
    // init the buid context
    getBuildContext(ctx);
    // load the app global file into the context
    loadAppGlobal(config, ctx);
    if (!registry) {
        // figure out the component registry
        // if one wasn't passed in already
        registry = registerComponents(config);
    }
    // overload with two options for hydrateToString
    // one that returns a promise, and one that takes a callback as the last arg
    function hydrateToString(hydrateOpts) {
        // validate the hydrate options and add any missing info
        normalizeHydrateOptions(config, hydrateOpts);
        // kick off hydrated, which is an async opertion
        return hydrateHtml(config, ctx, registry, hydrateOpts).catch(err => {
            const hydrateResults = {
                diagnostics: [buildError(err)],
                html: hydrateOpts.html,
                styles: null,
                anchors: []
            };
            return hydrateResults;
        });
    }
    return {
        hydrateToString: hydrateToString
    };
}
function registerComponents(config) {
    let registry = null;
    try {
        const registryJsonFilePath = getRegistryJsonWWW(config);
        // open up the registry json file
        const cmpRegistryJson = config.sys.fs.readFileSync(registryJsonFilePath, 'utf-8');
        // parse the json into js object
        const registryData = JSON.parse(cmpRegistryJson);
        // object should have the components property on it
        const components = registryData.components;
        if (Array.isArray(components) && components.length > 0) {
            // i think we're good, let's create a registry
            // object to fill up with component data
            registry = {};
            // each component should be a LoadComponentRegistry interface
            components.forEach(cmpRegistryData => {
                // parse the LoadComponentRegistry data and
                // move it to the ComponentRegistry data
                parseComponentLoaders(cmpRegistryData, registry);
            });
        }
        else {
            throw new Error(`No components were found within the registry data`);
        }
    }
    catch (e) {
        throw new Error(`Unable to open component registry: ${e}`);
    }
    return registry;
}
function normalizeHydrateOptions(config, opts) {
    const req = opts.req;
    if (req && typeof req.get === 'function') {
        // assuming node express request object
        // https://expressjs.com/
        if (!opts.url)
            opts.url = req.protocol + '://' + req.get('host') + req.originalUrl;
        if (!opts.referrer)
            opts.referrer = req.get('referrer');
        if (!opts.userAgent)
            opts.userAgent = req.get('user-agent');
        if (!opts.cookie)
            opts.cookie = req.get('cookie');
    }
    if (!opts.url) {
        opts.url = '/';
    }
    const urlObj = config.sys.url.parse(opts.url);
    if (!urlObj.protocol)
        urlObj.protocol = 'https:';
    if (!urlObj.hostname)
        urlObj.hostname = DEFAULT_PRERENDER_CONFIG.host;
    opts.url = config.sys.url.format(urlObj);
}
function loadAppGlobal(config, ctx) {
    ctx.appFiles = ctx.appFiles || {};
    if (ctx.appFiles.global) {
        // already loaded the global js content
        return;
    }
    // let's load the app global js content
    const appGlobalPath = getGlobalWWW(config);
    try {
        ctx.appFiles.global = config.sys.fs.readFileSync(appGlobalPath, 'utf-8');
    }
    catch (e) {
        config.logger.debug(`missing app global: ${appGlobalPath}`);
    }
}

/**
 * SSR Path Regex matches urls which end with index.html,
 * urls with a trailing /, and urls with no trailing slash,
 * but also do not have a file extension. The following example
 * urls would all match (with or without a querystring):
 *   /index.html
 *   /about
 *   /about/
 *   /
 *
 * The follwing example url would not match:
 *   /image.jpg
 *   /font.woff
 *
 * Please see the unit tests if any changes are required.
 */

function prerenderUrl(config, ctx, indexSrcHtml, prerenderLocation) {
    const timeSpan = config.logger.createTimeSpan(`prerender, started: ${prerenderLocation.pathname}`);
    const results = {
        diagnostics: []
    };
    return Promise.resolve().then(() => {
        // create the renderer config
        const rendererConfig = Object.assign({}, config);
        // create the hydrate options from the prerender config
        const hydrateOpts = Object.assign({}, config.prerender);
        hydrateOpts.url = prerenderLocation.url;
        hydrateOpts.isPrerender = true;
        // set the input html which we just read from the src index html file
        hydrateOpts.html = indexSrcHtml;
        // create a deep copy of the registry so any changes inside the render
        // don't affect what we'll be saving
        const registry = JSON.parse(JSON.stringify(ctx.registry));
        // create a server-side renderer
        const renderer = createRenderer(rendererConfig, registry, ctx);
        // parse the html to dom nodes, hydrate the components, then
        // serialize the hydrated dom nodes back to into html
        return renderer.hydrateToString(hydrateOpts).then(hydratedResults => {
            // hydrating to string is done!!
            // let's use this updated html for the index content now
            Object.assign(results, hydratedResults);
            ctx.prerenderedUrls++;
        });
    }).catch(err => {
        // ahh man! what happened!
        catchError(ctx.diagnostics, err);
    }).then(() => {
        timeSpan.finish(`prerender, finished: ${prerenderLocation.pathname}`);
        return results;
    });
}

function prerenderApp(config, ctx) {
    if (hasError(ctx.diagnostics)) {
        // no need to rebuild index.html if there were no app file changes
        config.logger.debug(`prerenderApp, skipping because build has errors`);
        return Promise.resolve();
    }
    if (!config.prerender) {
        // no need to rebuild index.html if there were no app file changes
        config.logger.debug(`prerenderApp, skipping because config.prerender is falsy`);
        return Promise.resolve();
    }
    if (!config.generateWWW) {
        // no need to rebuild index.html if there were no app file changes
        config.logger.debug(`prerenderApp, skipping because config.generateWWW is falsy`);
        return Promise.resolve();
    }
    // if there was src index.html file, then the process before this one
    // would have already loaded and updated the src index to its www path
    // get the www index html content for the template for all prerendered pages
    const indexHtml = ctx.filesToWrite[config.wwwIndexHtml];
    if (!indexHtml) {
        // looks like we don't have an index html file, which is fine
        config.logger.debug(`prerenderApp, missing index.html for prerendering`);
        return Promise.resolve();
    }
    const prerenderHost = `http://${config.prerender.host}`;
    getUrlsToPrerender(config, prerenderHost, ctx);
    if (!ctx.prerenderUrlQueue.length) {
        const d = buildError(ctx.diagnostics);
        d.messageText = `No urls found in the prerender config`;
        return Promise.resolve();
    }
    // keep track of how long the entire build process takes
    const timeSpan = config.logger.createTimeSpan(`prerendering started`);
    return new Promise(resolve => {
        drainPrerenderQueue(config, ctx, indexHtml, resolve);
    }).catch(err => {
        catchError(ctx.diagnostics, err);
    }).then(() => {
        if (hasError(ctx.diagnostics)) {
            timeSpan.finish(`prerendering failed`);
        }
        else {
            timeSpan.finish(`prerendered urls: ${ctx.prerenderedUrls}`);
        }
        if (ctx.localPrerenderServer) {
            ctx.localPrerenderServer.close();
            delete ctx.localPrerenderServer;
        }
    });
}
function drainPrerenderQueue(config, ctx, indexSrcHtml, resolve) {
    for (var i = 0; i < config.prerender.maxConcurrent; i++) {
        var activelyProcessingCount = ctx.prerenderUrlQueue.filter(p => p.status === PrerenderStatus.processing).length;
        if (activelyProcessingCount >= config.prerender.maxConcurrent) {
            // whooaa, slow down there buddy, let's not get carried away
            return;
        }
        runNextPrerenderUrl(config, ctx, indexSrcHtml, resolve);
    }
    var remaining = ctx.prerenderUrlQueue.filter(p => {
        return p.status === PrerenderStatus.processing || p.status === PrerenderStatus.pending;
    }).length;
    if (remaining === 0) {
        // we're not actively processing anything
        // and there aren't anymore urls in the queue to be prerendered
        // so looks like our job here is done, good work team
        resolve();
    }
}
function runNextPrerenderUrl(config, ctx, indexSrcHtml, resolve) {
    const p = ctx.prerenderUrlQueue.find(p => p.status === PrerenderStatus.pending);
    if (!p)
        return;
    // we've got a url that's pending
    // well guess what, it's go time
    p.status = PrerenderStatus.processing;
    prerenderUrl(config, ctx, indexSrcHtml, p).then(results => {
        // awesome!!
        // merge any diagnostics we just got from this
        ctx.diagnostics = ctx.diagnostics.concat(results.diagnostics);
        if (config.prerender.crawl !== false) {
            crawlAnchorsForNextUrls(config, ctx, results);
        }
        writePrerenderDest(config, ctx, results);
    }).catch(err => {
        // darn, idk, bad news
        catchError(ctx.diagnostics, err);
    }).then(() => {
        p.status = PrerenderStatus.complete;
        // let's try to drain the queue again and let this
        // next call figure out if we're actually done or not
        drainPrerenderQueue(config, ctx, indexSrcHtml, resolve);
    });
}
function writePrerenderDest(config, ctx, results) {
    const parsedUrl = config.sys.url.parse(results.url);
    // figure out the directory where this file will be saved
    const dir = config.sys.path.join(config.prerender.prerenderDir, parsedUrl.pathname);
    // create the full path where this will be saved (normalize for windowz)
    const filePath = normalizePath(config.sys.path.join(dir, `index.html`));
    // add the prerender html content it to our collection of
    // files that need to be saved when we're all ready
    ctx.filesToWrite[filePath] = results.html;
}
function crawlAnchorsForNextUrls(config, ctx, results) {
    results.anchors && results.anchors.forEach(anchor => {
        addUrlToProcess(config, results.url, ctx, anchor.href);
    });
}
function normalizePrerenderUrl(config, windowLocationHref, urlStr) {
    let p = null;
    try {
        if (typeof urlStr !== 'string')
            return null;
        let parsedUrl = config.sys.url.parse(urlStr);
        // don't bother for basically empty <a> tags
        // or urls that are not on the same domain
        if (!parsedUrl.pathname || parsedUrl.protocol || parsedUrl.auth || parsedUrl.hostname || parsedUrl.port)
            return null;
        // clear out any querystrings and hashes
        parsedUrl.search = null;
        parsedUrl.hash = null;
        // convert it back to a nice in pretty url
        p = {
            url: config.sys.url.format(parsedUrl)
        };
        // resolve it against the base window location url
        p.url = config.sys.url.resolve(windowLocationHref, p.url);
        parsedUrl = config.sys.url.parse(p.url);
        p.pathname = parsedUrl.pathname;
    }
    catch (e) {
        config.logger.error(`normalizePrerenderUrl: ${e}`);
        return null;
    }
    return p;
}
function addUrlToProcess(config, windowLocationHref, ctx, urlStr) {
    const pUrl = normalizePrerenderUrl(config, windowLocationHref, urlStr);
    if (!pUrl || ctx.prerenderUrlQueue.some(p => p.url === pUrl.url))
        return;
    pUrl.status = PrerenderStatus.pending;
    ctx.prerenderUrlQueue.push(pUrl);
}
function getUrlsToPrerender(config, windowLocationHref, ctx) {
    ctx.prerenderUrlQueue = [];
    if (!config.prerender.include)
        return;
    config.prerender.include.forEach(prerenderUrl$$1 => {
        addUrlToProcess(config, windowLocationHref, ctx, prerenderUrl$$1.url);
    });
}

function setupWatcher(config, ctx) {
    // only create the watcher if this is a watch build
    // and we haven't created a watcher yet
    if (!config.watch || ctx.watcher)
        return;
    config.logger.debug(`setupWatcher: ${config.srcDir}`);
    const logger = config.logger;
    let queueChangeBuild = false;
    let queueFullBuild = false;
    ctx.watcher = config.sys.watch(config.srcDir, {
        ignored: config.watchIgnoredRegex,
        ignoreInitial: true
    });
    if (config.configPath) {
        config.configPath = normalizePath(config.configPath);
        config.logger.debug(`watch configPath: ${config.configPath}`);
        ctx.watcher.add(config.configPath);
    }
    ctx.watcher
        .on('change', (path) => {
        path = normalizePath(path);
        logger.debug(`watcher, change: ${path}, ${Date.now()}`);
        if (path === config.configPath) {
            // the actual stencil config file changed
            // this is a big deal, so do a full rebuild
            configFileReload(config);
            queueFullBuild = true;
            queue();
            return;
        }
        if (isWebDevFile(path)) {
            // web dev file was updaed
            // queue change build
            queueChangeBuild = true;
            queue(path);
        }
    })
        .on('unlink', (path) => {
        logger.debug(`watcher, unlink: ${path}, ${Date.now()}`);
        if (isWebDevFile(path)) {
            // web dev file was delete
            // do a full rebuild
            queueFullBuild = true;
            queue();
        }
    })
        .on('add', (path) => {
        logger.debug(`watcher, add: ${path}, ${Date.now()}`);
        if (isWebDevFile(path)) {
            // new web dev file was added
            // do a full rebuild
            queueFullBuild = true;
            queue();
        }
    })
        .on('addDir', (path) => {
        logger.debug(`watcher, addDir: ${path}, ${Date.now()}`);
        // no clue what's up, do a full rebuild
        queueFullBuild = true;
        queue();
    })
        .on('unlinkDir', (path) => {
        logger.debug(`watcher, unlinkDir: ${path}, ${Date.now()}`);
        // no clue what's up, do a full rebuild
        queueFullBuild = true;
        queue();
    })
        .on('error', (err) => {
        logger.error(err);
    });
    let timer;
    const changedFiles = [];
    function queue(path) {
        // debounce builds
        clearTimeout(timer);
        if (path && changedFiles.indexOf(path) === -1) {
            path = normalizePath(path);
            changedFiles.push(path);
        }
        timer = setTimeout(() => {
            try {
                const changedFileCopies = changedFiles.slice();
                changedFiles.length = 0;
                if (queueFullBuild) {
                    watchBuild(config, ctx, true, changedFileCopies);
                }
                else if (queueChangeBuild) {
                    watchBuild(config, ctx, false, changedFileCopies);
                }
                // reset
                queueFullBuild = queueChangeBuild = false;
            }
            catch (e) {
                logger.error(e.toString());
            }
        }, 50);
    }
}
function watchBuild(config, ctx, requiresFullBuild, changedFiles) {
    // always reset to do a full build
    ctx.isRebuild = true;
    ctx.isChangeBuild = false;
    ctx.changeHasComponentModules = true;
    ctx.changeHasNonComponentModules = true;
    ctx.changeHasSass = true;
    ctx.changeHasCss = true;
    ctx.changedFiles = changedFiles;
    if (!ctx.lastBuildHadError && !requiresFullBuild && changedFiles.length) {
        let changeHasComponentModules = false;
        let changeHasNonComponentModules = false;
        ctx.changeHasSass = false;
        ctx.changeHasCss = false;
        changedFiles.forEach(changedFile => {
            if (isTsFile(changedFile)) {
                // we know there's a module change
                const moduleFile = ctx.moduleFiles[changedFile];
                if (moduleFile && moduleFile.cmpMeta) {
                    // we've got a module file already in memory and
                    // the changed file we already know is a component file
                    changeHasComponentModules = true;
                }
                else {
                    // not in cache, so let's consider it a module change
                    changeHasNonComponentModules = true;
                }
                // remove its cached content
                delete ctx.moduleFiles[changedFile];
            }
            else if (isSassFile(changedFile)) {
                ctx.changeHasSass = true;
            }
            else if (isCssFile(changedFile)) {
                ctx.changeHasCss = true;
            }
            else if (isHtmlFile(changedFile)) {
                ctx.changeHasHtml = true;
            }
        });
        // if nothing is true then something is up
        // so let's do a full build if "isChangeBuild" ends up being false
        ctx.isChangeBuild = (changeHasComponentModules || changeHasNonComponentModules || ctx.changeHasSass || ctx.changeHasCss || ctx.changeHasHtml);
        if (ctx.isChangeBuild) {
            if (changeHasNonComponentModules && !changeHasComponentModules) {
                // there are module changes, but the changed modules
                // aren't components, when in doubt do a full rebuild
                ctx.changeHasNonComponentModules = true;
                ctx.changeHasComponentModules = false;
            }
            else if (!changeHasNonComponentModules && changeHasComponentModules) {
                // only modudle changes are ones that are components
                ctx.changeHasNonComponentModules = false;
                ctx.changeHasComponentModules = true;
            }
            else if (!changeHasNonComponentModules && !changeHasComponentModules) {
                // no modules were changed at all
                ctx.changeHasComponentModules = false;
                ctx.changeHasNonComponentModules = false;
            }
        }
    }
    if (!ctx.isChangeBuild) {
        // completely clear out the cache
        ctx.moduleFiles = {};
        ctx.jsFiles = {};
        ctx.cssFiles = {};
        ctx.moduleBundleOutputs = {};
        ctx.styleSassUnscopedOutputs = {};
    }
    changedFiles.sort();
    const totalChangedFiles = changedFiles.length;
    if (totalChangedFiles > 6) {
        const trimmedChangedFiles = changedFiles.slice(0, 5);
        const otherFilesTotal = totalChangedFiles - trimmedChangedFiles.length;
        let msg = `changed files: ${trimmedChangedFiles.map(f => config.sys.path.basename(f)).join(', ')}`;
        if (otherFilesTotal > 0) {
            msg += `, +${otherFilesTotal} other${otherFilesTotal > 1 ? 's' : ''}`;
        }
        config.logger.info(msg);
    }
    else if (totalChangedFiles > 1) {
        const msg = `changed files: ${changedFiles.map(f => config.sys.path.basename(f)).join(', ')}`;
        config.logger.info(msg);
    }
    else if (totalChangedFiles > 0) {
        const msg = `changed file: ${changedFiles.map(f => config.sys.path.basename(f)).join(', ')}`;
        config.logger.info(msg);
    }
    return build(config, ctx);
}
function configFileReload(existingConfig) {
    existingConfig.logger.debug(`reload config file: ${existingConfig.configPath}`);
    const updatedConfig = existingConfig.sys.loadConfigFile(existingConfig.configPath);
    // just update the existing config in place
    // not everything should be overwritten or merged
    // pick and choose what's ok to update
    existingConfig._isValidated = false;
    existingConfig.buildDir = updatedConfig.buildDir;
    existingConfig.distDir = updatedConfig.distDir;
    existingConfig.bundles = updatedConfig.bundles;
    existingConfig.collectionDir = updatedConfig.collectionDir;
    existingConfig.collections = updatedConfig.collections;
    existingConfig.exclude = updatedConfig.exclude;
    existingConfig.generateDistribution = updatedConfig.generateDistribution;
    existingConfig.generateWWW = updatedConfig.generateWWW;
    existingConfig.global = updatedConfig.global;
    existingConfig.hashedFileNameLength = updatedConfig.hashedFileNameLength;
    existingConfig.hashFileNames = updatedConfig.hashFileNames;
    existingConfig.wwwIndexHtml = updatedConfig.wwwIndexHtml;
    existingConfig.srcIndexHtml = updatedConfig.srcIndexHtml;
    existingConfig.minifyCss = updatedConfig.minifyCss;
    existingConfig.minifyJs = updatedConfig.minifyJs;
    existingConfig.namespace = updatedConfig.namespace;
    existingConfig.preamble = updatedConfig.preamble;
    existingConfig.prerender = updatedConfig.prerender;
    existingConfig.publicPath = updatedConfig.publicPath;
    existingConfig.srcDir = updatedConfig.srcDir;
    existingConfig.watchIgnoredRegex = updatedConfig.watchIgnoredRegex;
}

function validateServiceWorkerConfig(config) {
    if (!config.serviceWorker) {
        config.serviceWorker = null;
        return;
    }
    if (typeof config.serviceWorker !== 'object') {
        // what was passed in could have been a boolean
        // in that case let's just turn it into an empty obj so Object.assign doesn't crash
        config.serviceWorker = {};
    }
    const swConfig = Object.assign({}, DEFAULT_SW_CONFIG, config.serviceWorker);
    if (!swConfig.globDirectory) {
        swConfig.globDirectory = config.wwwDir;
    }
    if (!swConfig.swDest) {
        swConfig.swDest = config.sys.path.join(config.wwwDir, DEFAULT_SW_FILENAME);
    }
    if (!config.sys.path.isAbsolute(swConfig.swDest)) {
        swConfig.swDest = config.sys.path.join(config.wwwDir, swConfig.swDest);
    }
    config.serviceWorker = swConfig;
}
const DEFAULT_SW_CONFIG = {
    skipWaiting: true,
    clientsClaim: true,
    globPatterns: [
        '**/*.{js,css,json,html,ico,png,svg}'
    ]
};
const DEFAULT_SW_FILENAME = 'sw.js';

function validateManifestCompatibility(config, manifest) {
    if (!manifest.compiler) {
        // if there is no compiler data at all then this was probably
        // set on purpose and we should avoid doing any upgrading
        return [];
    }
    try {
        // fill in any default data if somehow it's missing entirely
        manifest.compiler.name = manifest.compiler.name || '@stencil/core';
        manifest.compiler.version = manifest.compiler.version || '0.0.1';
        manifest.compiler.typescriptVersion = manifest.compiler.typescriptVersion || '2.5.3';
        // parse version
        const manifestCompilerVersion = parseCompilerVersion(manifest.compiler.version);
        // figure out which compiler upgrades, if any, we need to do
        return calculateRequiredUpgrades(manifestCompilerVersion);
    }
    catch (e) {
        config.logger.error(`error parsing compiler version: ${e}`);
    }
    return [];
}
function calculateRequiredUpgrades(v) {
    // CUSTOM CHECKS PER KNOWN BREAKING CHANGES
    // UNIT TEST UNIT TEST UNIT TEST
    const upgrades = [];
    if (semverLessThan(v, '0.0.6-11')) {
        // 2017-10-04
        // between 0.0.5 and 0.0.6-11 we no longer have a custom JSX parser
        upgrades.push(0 /* JSX_Upgrade_From_0_0_5 */);
    }
    return upgrades;
}
function parseCompilerVersion(version) {
    const dashSplt = version.split('-');
    const dotSplt = dashSplt[0].split('.');
    if (dotSplt.length !== 3) {
        throw new Error(`invalid semver: ${version}`);
    }
    const semver = {
        major: parseInt(dotSplt[0], 10),
        minor: parseInt(dotSplt[1], 10),
        patch: parseInt(dotSplt[2], 10)
    };
    const prereleaseSplt = dashSplt.slice(1);
    if (prereleaseSplt.length > 1) {
        throw new Error(`invalid semver: ${version}`);
    }
    if (prereleaseSplt.length === 1) {
        const prerelease = parseInt(prereleaseSplt[0], 10);
        if (isNaN(prerelease)) {
            throw new Error(`invalid semver: ${version}`);
        }
        else {
            semver.prerelease = prerelease;
        }
    }
    return semver;
}
function semverLessThan(a, b) {
    const semverA = (typeof a === 'string') ? parseCompilerVersion(a) : a;
    const semverB = (typeof b === 'string') ? parseCompilerVersion(b) : b;
    if (semverA.major < semverB.major) {
        return true;
    }
    if (semverA.major > semverB.major) {
        return false;
    }
    // Assume major are equal
    if (semverA.minor < semverB.minor) {
        return true;
    }
    if (semverA.minor > semverB.minor) {
        return false;
    }
    // Assume major.minor are equal
    if (semverA.patch < semverB.patch) {
        return true;
    }
    if (semverA.patch > semverB.patch) {
        return false;
    }
    // Assume major.minor.patch are equal
    if (semverA.prerelease != null && semverB.prerelease == null) {
        return true;
    }
    if (semverA.prerelease != null && semverB.prerelease != null) {
        if (semverA.prerelease < semverB.prerelease) {
            return true;
        }
        if (semverA.prerelease > semverB.prerelease) {
            return false;
        }
    }
    // Asume major.minor.patch.prerelease are equal
    return false;
}

function upgradeJsxProps(transformContext) {
    return (tsSourceFile) => {
        return visit(tsSourceFile);
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.CallExpression:
                    const callNode = node;
                    if (callNode.expression.text === 'h') {
                        const tag = callNode.arguments[0];
                        if (tag && typeof tag.text === 'string') {
                            node = upgradeCall(callNode);
                        }
                    }
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(node);
                    }, transformContext);
            }
        }
    };
}
function upgradeCall(callNode) {
    const [tag, props, ...children] = callNode.arguments;
    let newArgs = [];
    newArgs.push(upgradeTagName(tag));
    newArgs.push(upgradeProps(props));
    if (children != null) {
        newArgs = newArgs.concat(upgradeChildren(children));
    }
    return ts.updateCall(callNode, callNode.expression, undefined, newArgs);
}
function upgradeTagName(tagName) {
    if (ts.isNumericLiteral(tagName) &&
        tagName.text === '0') {
        return ts.createLiteral('slot');
    }
    return tagName;
}
function upgradeProps(props) {
    let upgradedProps = {};
    let propHackValue;
    if (!ts.isObjectLiteralExpression(props)) {
        return ts.createNull();
    }
    let objectProps = objectLiteralToObjectMap(props);
    upgradedProps = Object.keys(objectProps).reduce((newProps, propName) => {
        const propValue = objectProps[propName];
        // If the propname is c, s, or k then map to proper name
        if (propName === 'c') {
            return Object.assign({}, newProps, { 'class': propValue });
        }
        if (propName === 's') {
            return Object.assign({}, newProps, { 'style': propValue });
        }
        if (propName === 'k') {
            return Object.assign({}, newProps, { 'key': propValue });
        }
        // If the propname is p or a then spread the value into props
        if (propName === 'a') {
            return Object.assign({}, newProps, propValue);
        }
        if (propName === 'p') {
            if (isInstanceOfObjectMap(propValue)) {
                return Object.assign({}, newProps, propValue);
            }
            else {
                propHackValue = propValue;
            }
        }
        // If the propname is o then we need to update names and then spread into props
        if (propName === 'o') {
            const eventListeners = Object.keys(propValue).reduce((newValue, eventName) => {
                return Object.assign({}, newValue, { [`on${eventName}`]: propValue[eventName] });
            }, {});
            return Object.assign({}, newProps, eventListeners);
        }
        return newProps;
    }, upgradedProps);
    try {
        
    }
    catch (e) {
        console.log(upgradedProps);
        console.log(objectProps);
        console.log(props);
        throw e;
    }
    let response = objectMapToObjectLiteral(upgradedProps);
    // Looks like someone used the props hack. So we need to create the following code:
    // Object.assign({}, upgradedProps, propHackValue);
    if (propHackValue) {
        const emptyObjectLiteral = ts.createObjectLiteral();
        return ts.createCall(ts.createPropertyAccess(ts.createIdentifier('Object'), ts.createIdentifier('assign')), undefined, [emptyObjectLiteral, response, propHackValue]);
    }
    return response;
}
function upgradeChildren(children) {
    return children.map(upgradeChild);
}
function upgradeChild(child) {
    if (ts.isCallExpression(child) && child.expression.text === 't') {
        return child.arguments[0];
    }
    return child;
}

var __awaiter$7 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function upgradeDependentComponents(config, ctx) {
    return __awaiter$7(this, void 0, void 0, function* () {
        const doUpgrade = createDoUpgrade(config, ctx);
        return Promise.all(Object.keys(ctx.dependentManifests).map(function (collectionName) {
            return __awaiter$7(this, void 0, void 0, function* () {
                const manifest = ctx.dependentManifests[collectionName];
                const upgrades = validateManifestCompatibility(config, manifest);
                try {
                    yield doUpgrade(manifest, upgrades);
                }
                catch (e) {
                    config.logger.error(`error performing compiler upgrade: ${e}`);
                }
            });
        }));
    });
}
function createDoUpgrade(config, ctx) {
    return (manifest, upgrades) => __awaiter$7(this, void 0, void 0, function* () {
        const upgradeTransforms = (upgrades.map((upgrade) => {
            switch (upgrade) {
                case 0 /* JSX_Upgrade_From_0_0_5 */:
                    config.logger.debug(`JSX_Upgrade_From_0_0_5, manifestCompilerVersion: ${manifest.compiler.version}`);
                    return upgradeJsxProps;
            }
            return () => (tsSourceFile) => (tsSourceFile);
        }));
        if (upgradeTransforms.length === 0) {
            return;
        }
        yield Promise.all(manifest.modulesFiles.map(function (moduleFile) {
            return __awaiter$7(this, void 0, void 0, function* () {
                return new Promise((resolve, reject) => {
                    config.sys.fs.readFile(moduleFile.jsFilePath, 'utf8', (err, source) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            let output = '';
                            try {
                                output = transformSourceString(moduleFile.jsFilePath, source, upgradeTransforms);
                            }
                            catch (e) {
                                config.logger.error(`error performing compiler upgrade on ${moduleFile.jsFilePath}: ${e}`);
                            }
                            ctx.jsFiles[moduleFile.jsFilePath] = output;
                            resolve();
                        }
                    });
                });
            });
        }));
    });
}

function build(config, context) {
    // create the build context if it doesn't exist
    // the buid context is the same object used for all builds and rebuilds
    // ctx is where stuff is cached for fast in-memory lookups later
    const ctx = getBuildContext(context);
    if (!ctx.isRebuild) {
        config.logger.info(config.logger.cyan(`${config.sys.compiler.name} v${config.sys.compiler.version}`));
    }
    // reset the build context, this is important for rebuilds
    resetBuildContext(ctx);
    // create the build results that get returned
    const buildResults = {
        files: [],
        diagnostics: [],
        manifest: {},
        changedFiles: ctx.isRebuild ? ctx.changedFiles : null
    };
    // validate the build config
    if (!isConfigValid(config, ctx, buildResults.diagnostics)) {
        // invalid build config, let's not continue
        config.logger.printDiagnostics(buildResults.diagnostics);
        return Promise.resolve(buildResults);
    }
    // create an initial index.html file if one doesn't already exist
    // this is synchronous on purpose
    if (!initIndexHtml(config, ctx, buildResults.diagnostics)) {
        // error initializing the index.html file
        // something's wrong, so let's not continue
        config.logger.printDiagnostics(buildResults.diagnostics);
        return Promise.resolve(buildResults);
    }
    // keep track of how long the entire build process takes
    const timeSpan = config.logger.createTimeSpan(`${ctx.isRebuild ? 'rebuild' : 'build'}, ${getAppFileName(config)}, ${config.devMode ? 'dev' : 'prod'} mode, started`);
    // begin the build
    return Promise.resolve().then(() => {
        // async scan the src directory for ts files
        // then transpile them all in one go
        return compileSrcDir(config, ctx);
    }).then(compileResults => {
        // generation the app manifest from the compiled results
        // and from all the dependent collections
        return generateAppManifest(config, ctx, compileResults.moduleFiles);
    }).then(() => {
        // Look at all dependent components from outside collections and
        // upgrade the components if need be
        return upgradeDependentComponents(config, ctx);
    }).then(() => {
        // bundle modules and styles into separate files phase
        return bundle(config, ctx);
    }).then(() => {
        // generate the app files, such as app.js, app.core.js
        return generateAppFiles(config, ctx);
    }).then(() => {
        // empty the build dest directory
        // doing this now incase the
        // copy tasks add to the dest directories
        return emptyDestDir(config, ctx);
    }).then(() => {
        // copy all assets
        return copyTasks(config, ctx);
    }).then(() => {
        // build index file and service worker
        return generateIndexHtml(config, ctx);
    }).then(() => {
        // prerender that app
        return prerenderApp(config, ctx);
    }).then(() => {
        // write all the files and copy asset files
        return writeBuildFiles(config, ctx, buildResults);
    }).then(() => {
        // generate the service worker
        return generateServiceWorker(config, ctx);
    }).then(() => {
        // setup watcher if need be
        return setupWatcher(config, ctx);
    }).catch(err => {
        // catch all phase
        catchError(ctx.diagnostics, err);
    }).then(() => {
        // finalize phase
        buildResults.diagnostics = cleanDiagnostics(ctx.diagnostics);
        config.logger.printDiagnostics(buildResults.diagnostics);
        let buildText = ctx.isRebuild ? 'rebuild' : 'build';
        let buildStatus = 'finished';
        let watchText = config.watch ? ', watching for changes...' : '';
        let statusColor = 'green';
        if (hasError(ctx.diagnostics)) {
            buildStatus = 'failed';
            statusColor = 'red';
        }
        timeSpan.finish(`${buildText} ${buildStatus}${watchText}`, statusColor, true, true);
        if (typeof ctx.onFinish === 'function') {
            // fire off any provided onFinish fn every time the build finishes
            ctx.onFinish(buildResults);
        }
        // remember if the last build had an error or not
        // this is useful if the next build should do a full build or not
        ctx.lastBuildHadError = hasError(ctx.diagnostics);
        // return what we've learned today
        return buildResults;
    });
}
function isConfigValid(config, ctx, diagnostics) {
    try {
        // validate the build config
        validateBuildConfig(config, true);
        if (!ctx.isRebuild) {
            validatePrerenderConfig(config);
            validateServiceWorkerConfig(config);
        }
    }
    catch (e) {
        if (config.logger) {
            catchError(diagnostics, e);
        }
        else {
            console.error(e);
        }
        return false;
    }
    return true;
}

const AUTO_GENERATE_COMMENT = `<!-- Auto Generated Below -->`;
const NOTE = `*Built by [StencilJS](https://stenciljs.com/)*`;

class MarkdownAttrs {
    constructor() {
        this.rows = [];
    }
    addRow(memberMeta) {
        this.rows.push(new Row(memberMeta));
    }
    toMarkdown() {
        const content = [];
        if (!this.rows.length) {
            return content;
        }
        content.push(`## Attributes`);
        content.push(``);
        this.rows = this.rows.sort((a, b) => {
            if (a.memberMeta.attribName < b.memberMeta.attribName)
                return -1;
            if (a.memberMeta.attribName > b.memberMeta.attribName)
                return 1;
            return 0;
        });
        this.rows.forEach(row => {
            content.push(...row.toMarkdown());
        });
        return content;
    }
}
class Row {
    constructor(memberMeta) {
        this.memberMeta = memberMeta;
    }
    toMarkdown() {
        const content = [];
        content.push(`#### ${this.memberMeta.attribName}`);
        content.push(``);
        content.push(getPropType(this.memberMeta.propType));
        content.push(``);
        content.push(``);
        return content;
    }
}
function getPropType(propType) {
    switch (propType) {
        case 1 /* Any */:
            return 'any';
        case 3 /* Boolean */:
            return 'boolean';
        case 4 /* Number */:
            return 'number';
        case 2 /* String */:
            return 'string';
    }
    return '';
}

class MarkdownEvents {
    constructor() {
        this.rows = [];
    }
    addRow(eventMeta) {
        this.rows.push(new Row$1(eventMeta));
    }
    toMarkdown() {
        const content = [];
        if (!this.rows.length) {
            return content;
        }
        content.push(`## Events`);
        content.push(``);
        this.rows = this.rows.sort((a, b) => {
            if (a.eventMeta.eventName < b.eventMeta.eventName)
                return -1;
            if (a.eventMeta.eventName > b.eventMeta.eventName)
                return 1;
            return 0;
        });
        this.rows.forEach(row => {
            content.push(...row.toMarkdown());
        });
        return content;
    }
}
class Row$1 {
    constructor(eventMeta) {
        this.eventMeta = eventMeta;
    }
    toMarkdown() {
        const content = [];
        content.push(`#### ${this.eventMeta.eventName}`);
        content.push(``);
        content.push(``);
        return content;
    }
}

class MarkdownMethods {
    constructor() {
        this.rows = [];
    }
    addRow(memberName) {
        this.rows.push(new Row$2(memberName));
    }
    toMarkdown() {
        const content = [];
        if (!this.rows.length) {
            return content;
        }
        content.push(`## Methods`);
        content.push(``);
        this.rows = this.rows.sort((a, b) => {
            if (a.memberName < b.memberName)
                return -1;
            if (a.memberName > b.memberName)
                return 1;
            return 0;
        });
        this.rows.forEach(row => {
            content.push(...row.toMarkdown());
        });
        return content;
    }
}
class Row$2 {
    constructor(memberName) {
        this.memberName = memberName;
    }
    toMarkdown() {
        const content = [];
        content.push(`#### ${this.memberName}()`);
        content.push(``);
        content.push(``);
        return content;
    }
}

class MarkdownProps {
    constructor() {
        this.rows = [];
    }
    addRow(memberName, memberMeta) {
        this.rows.push(new Row$3(memberName, memberMeta));
    }
    toMarkdown() {
        const content = [];
        if (!this.rows.length) {
            return content;
        }
        content.push(`## Properties`);
        content.push(``);
        this.rows = this.rows.sort((a, b) => {
            if (a.memberName < b.memberName)
                return -1;
            if (a.memberName > b.memberName)
                return 1;
            return 0;
        });
        this.rows.forEach(row => {
            content.push(...row.toMarkdown());
        });
        return content;
    }
}
class Row$3 {
    constructor(memberName, memberMeta) {
        this.memberName = memberName;
        this.memberMeta = memberMeta;
    }
    toMarkdown() {
        const content = [];
        content.push(`#### ${this.memberName}`);
        content.push(``);
        content.push(getPropType$1(this.memberMeta.propType));
        content.push(``);
        content.push(``);
        return content;
    }
}
function getPropType$1(propType) {
    switch (propType) {
        case 1 /* Any */:
            return 'any';
        case 3 /* Boolean */:
            return 'boolean';
        case 4 /* Number */:
            return 'number';
        case 2 /* String */:
            return 'string';
    }
    return '';
}

function addAutoGenerate(cmpMeta, content) {
    content.push(AUTO_GENERATE_COMMENT);
    content.push(``);
    content.push(``);
    content.push(...generateMemberMarkdown(cmpMeta));
    content.push(``);
    content.push(`----------------------------------------------`);
    content.push(``);
    content.push(NOTE);
    content.push(``);
}
function generateMemberMarkdown(cmpMeta) {
    const attrs = new MarkdownAttrs();
    const events = new MarkdownEvents();
    const methods = new MarkdownMethods();
    const props = new MarkdownProps();
    cmpMeta.membersMeta && Object.keys(cmpMeta.membersMeta).forEach(memberName => {
        const memberMeta = cmpMeta.membersMeta[memberName];
        if (memberMeta.memberType === 1 /* Prop */ || memberMeta.memberType === 2 /* PropMutable */) {
            props.addRow(memberName, memberMeta);
            if (memberMeta.attribName) {
                attrs.addRow(memberMeta);
            }
        }
        else if (memberMeta.memberType === 6 /* Method */) {
            methods.addRow(memberName);
        }
    });
    cmpMeta.eventsMeta && cmpMeta.eventsMeta.forEach(ev => {
        events.addRow(ev);
    });
    return [
        ...props.toMarkdown(),
        ...attrs.toMarkdown(),
        ...events.toMarkdown(),
        ...methods.toMarkdown()
    ];
}

var __awaiter$8 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function genereateReadmes(config, ctx) {
    const cmpDirectories = [];
    const promises = [];
    Object.keys(ctx.moduleFiles).forEach(filePath => {
        const moduleFile = ctx.moduleFiles[filePath];
        if (!moduleFile.cmpMeta) {
            return;
        }
        const dirPath = config.sys.path.dirname(moduleFile.tsFilePath);
        if (cmpDirectories.indexOf(dirPath) > -1) {
            config.logger.error(`multiple components found in: ${dirPath}`);
        }
        else {
            cmpDirectories.push(dirPath);
            promises.push(genereateReadme(config, moduleFile, dirPath));
        }
    });
    return Promise.all(promises);
}
function genereateReadme(config, moduleFile, dirPath) {
    return __awaiter$8(this, void 0, void 0, function* () {
        config.logger.info(`generated docs: ${moduleFile.cmpMeta.tagNameMeta}`);
        const readMePath = config.sys.path.join(dirPath, 'readme.md');
        return readFile(config.sys, readMePath).then(content => {
            // update
            return updateReadme(config, moduleFile, readMePath, content);
        }).catch(() => {
            // create
            return createReadme(config, moduleFile, readMePath);
        });
    });
}
function createReadme(config, moduleFile, readMePath) {
    let content = [];
    content.push(`# ${moduleFile.cmpMeta.tagNameMeta}`);
    content.push(``);
    content.push(``);
    content.push(``);
    addAutoGenerate(moduleFile.cmpMeta, content);
    return new Promise((resolve, reject) => {
        config.sys.fs.writeFile(readMePath, content.join('\n'), (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
function updateReadme(config, moduleFile, readMePath, existingContent) {
    let content = [];
    const existingLines = existingContent.split(/(\r?\n)/);
    let foundAutoGenerate = false;
    for (var i = 0; i < existingLines.length; i++) {
        if (existingLines[i].trim() === AUTO_GENERATE_COMMENT) {
            foundAutoGenerate = true;
            break;
        }
        if (existingLines[i] !== '\n' && existingLines[i] !== '\r') {
            content.push(existingLines[i]);
        }
    }
    if (!foundAutoGenerate) {
        config.logger.warn(`Unable to find ${AUTO_GENERATE_COMMENT} comment for docs auto-generation updates: ${readMePath}`);
        return Promise.resolve(true);
    }
    addAutoGenerate(moduleFile.cmpMeta, content);
    return new Promise((resolve, reject) => {
        config.sys.fs.writeFile(readMePath, content.join('\n'), (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(true);
            }
        });
    });
}

function docs(config) {
    const ctx = getBuildContext({});
    resetBuildContext(ctx);
    config.logger.info(config.logger.cyan(`${config.sys.compiler.name} v${config.sys.compiler.version}`));
    // validate the build config
    if (!isConfigValid(config, ctx, ctx.diagnostics)) {
        // invalid build config, let's not continue
        config.logger.printDiagnostics(ctx.diagnostics);
        return Promise.resolve(null);
    }
    // keep track of how long the entire build process takes
    const timeSpan = config.logger.createTimeSpan(`generate docs, ${getAppFileName(config)}, started`);
    // begin the build
    return Promise.resolve().then(() => {
        // async scan the src directory for ts files
        // then transpile them all in one go
        return compileSrcDir(config, ctx);
    }).then(() => {
        // generate each of the readmes
        return genereateReadmes(config, ctx);
    }).catch(err => {
        // catch all phase
        catchError(ctx.diagnostics, err);
    }).then(() => {
        // finalize phase
        ctx.diagnostics = cleanDiagnostics(ctx.diagnostics);
        config.logger.printDiagnostics(ctx.diagnostics);
        let buildStatus = 'finished';
        let statusColor = 'green';
        if (hasError(ctx.diagnostics)) {
            buildStatus = 'failed';
            statusColor = 'red';
        }
        timeSpan.finish(`generate docs ${buildStatus}`, statusColor, true, true);
        return null;
    });
}

exports.build = build;
exports.isConfigValid = isConfigValid;
exports.docs = docs;
