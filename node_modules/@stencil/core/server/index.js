'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * SSR Attribute Names
 */
var SSR_VNODE_ID = 'data-ssrv';
var SSR_CHILD_ID = 'data-ssrc';
/**
 * Default style mode id
 */
var DEFAULT_STYLE_MODE = '$';
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
var EMPTY_OBJ = {};
var EMPTY_ARR = [];
/**
 * Key Name to Key Code Map
 */
var KEY_CODE_MAP = {
    'enter': 13,
    'escape': 27,
    'space': 32,
    'tab': 9,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40
};
/**
 * Namespaces
 */



/**
 * File names and value
 */



var GLOBAL_NAME = 'global';

function getBuildContext(ctx) {
    // create the build context if it doesn't exist
    ctx = ctx || {};
    ctx.diagnostics = ctx.diagnostics || [];
    ctx.manifest = ctx.manifest || {};
    ctx.registry = ctx.registry || {};
    ctx.filesToWrite = ctx.filesToWrite || {};
    ctx.appFiles = ctx.appFiles || {};
    ctx.moduleFiles = ctx.moduleFiles || {};
    ctx.jsFiles = ctx.jsFiles || {};
    ctx.cssFiles = ctx.cssFiles || {};
    ctx.dependentManifests = ctx.dependentManifests || {};
    ctx.compiledFileCache = ctx.compiledFileCache || {};
    ctx.moduleBundleOutputs = ctx.moduleBundleOutputs || {};
    ctx.styleSassUnscopedOutputs = ctx.styleSassUnscopedOutputs || {};
    ctx.styleSassScopedOutputs = ctx.styleSassScopedOutputs || {};
    ctx.styleCssUnscopedOutputs = ctx.styleCssUnscopedOutputs || {};
    ctx.styleCssScopedOutputs = ctx.styleCssScopedOutputs || {};
    ctx.changedFiles = ctx.changedFiles || [];
    return ctx;
}

function getJsFile(sys, ctx, jsFilePath) {
    jsFilePath = normalizePath(jsFilePath);
    if (typeof ctx.filesToWrite[jsFilePath] === 'string') {
        return Promise.resolve(ctx.filesToWrite[jsFilePath]);
    }
    if (typeof ctx.jsFiles[jsFilePath] === 'string') {
        return Promise.resolve(ctx.jsFiles[jsFilePath]);
    }
    return new Promise(function (resolve, reject) {
        sys.fs.readFile(jsFilePath, 'utf-8', function (err, data) {
            if (err) {
                reject(err);
            }
            else {
                ctx.jsFiles[jsFilePath] = data;
                resolve(data);
            }
        });
    });
}











function buildError(diagnostics) {
    var d = {
        level: 'error',
        type: 'build',
        header: 'build error',
        messageText: 'build error',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    diagnostics.push(d);
    return d;
}




function pathJoin(config) {
    var paths = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        paths[_i - 1] = arguments[_i];
    }
    return normalizePath(config.sys.path.join.apply(config.sys.path, paths));
}
function normalizePath(str) {
    // Convert Windows backslash paths to slash paths: foo\\bar ➔ foo/bar
    // https://github.com/sindresorhus/slash MIT
    // By Sindre Sorhus
    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {
        return str;
    }
    return str.replace(SLASH_REGEX, '/');
}
var EXTENDED_PATH_REGEX = /^\\\\\?\\/;
var NON_ASCII_REGEX = /[^\x00-\x80]+/;
var SLASH_REGEX = /\\/g;

var DEFAULT_PRERENDER_CONFIG = {
    crawl: true,
    include: [
        { url: '/' }
    ],
    inlineLoaderScript: true,
    inlineStyles: true,
    removeUnusedStyles: true,
    collapseWhitespace: true,
    maxConcurrent: 4,
    host: 'dev.prerender.stenciljs.com'
};

function getAppFileName(config) {
    return config.namespace.toLowerCase();
}
function getAppWWWBuildDir(config) {
    var appFileName = getAppFileName(config);
    return pathJoin(config, config.buildDir, appFileName);
}

function getRegistryJsonWWW(config) {
    var appFileName = getAppFileName(config);
    return pathJoin(config, getAppWWWBuildDir(config), appFileName + ".registry.json");
}


function getGlobalFileName(config) {
    var appFileName = getAppFileName(config);
    return appFileName + "." + GLOBAL_NAME + ".js";
}
function getGlobalWWW(config) {
    return pathJoin(config, getAppWWWBuildDir(config), getGlobalFileName(config));
}

var Build = {
    verboseError: true,
    shadowDom: true,
    slot: true,
    ssrClientSide: true,
    ssrServerSide: true,
    styles: true,
    hostData: true,
    hostTheme: true,
    svg: true,
    observeAttr: true,
    // decorators
    element: true,
    event: true,
    listener: true,
    method: true,
    propConnect: true,
    propContext: true,
    propDidChange: true,
    propWillChange: true,
    // lifecycle events
    cmpDidLoad: true,
    cmpWillLoad: true,
    cmpDidUpdate: true,
    cmpWillUpdate: true,
    cmpDidUnload: true,
};

var isDef = function (v) { return v !== undefined && v !== null; };
var isUndef = function (v) { return v === undefined || v === null; };





var toLowerCase = function (str) { return str.toLowerCase(); };
var toDashCase = function (str) { return str.replace(/([A-Z])/g, function (g) { return '-' + toLowerCase(g[0]); }); };


var noop = function () { };

function initElementListeners(plt, elm) {
    // so the element was just connected, which means it's in the DOM
    // however, the component instance hasn't been created yet
    // but what if an event it should be listening to get emitted right now??
    // let's add our listeners right now to our element, and if it happens
    // to receive events between now and the instance being created let's
    // queue up all of the event data and fire it off on the instance when it's ready
    var cmpMeta = plt.getComponentMeta(elm);
    if (cmpMeta.listenersMeta) {
        cmpMeta.listenersMeta.forEach(function (listener) {
            if (!listener.eventDisabled) {
                (elm._listeners = elm._listeners || {})[listener.eventName] = addListener(plt, elm, listener.eventName, createListenerCallback(elm, listener.eventMethodName), listener.eventCapture, listener.eventPassive);
            }
        });
    }
}
function createListenerCallback(elm, eventMethodName) {
    // create the function that gets called when the element receives
    // an event which it should be listening for
    return function (ev) {
        if (elm._instance) {
            // instance is ready, let's call it's member method for this event
            elm._instance[eventMethodName](ev);
        }
        else {
            // instance is not ready!!
            // let's queue up this event data and replay it later
            // when the instance is ready
            (elm._queuedEvents = elm._queuedEvents || []).push(eventMethodName, ev);
        }
    };
}
function replayQueuedEventsOnInstance(elm, i) {
    // the element has an instance now and
    // we already added the event listeners to the element
    var queuedEvents = elm._queuedEvents;
    if (queuedEvents) {
        // events may have already fired before the instance was even ready
        // now that the instance is ready, let's replay all of the events that
        // we queued up earlier that were originally meant for the instance
        for (i = 0; i < queuedEvents.length; i += 2) {
            // data was added in sets of two
            // first item the eventMethodName
            // second item is the event data
            // take a look at initElementListener()
            elm._instance[queuedEvents[i]](queuedEvents[i + 1]);
        }
        // no longer need this data, be gone with you
        elm._queuedEvents = null;
    }
}

function addListener(plt, elm, eventName, listenerCallback, useCapture, usePassive, splt, eventListener) {
    // depending on the event name, we could actually be attaching
    // this element to something like the document or window
    splt = eventName.split(':');
    if (elm && splt.length > 1) {
        // document:mousemove
        // parent:touchend
        // body:keyup.enter
        elm = plt.domApi.$elementRef(elm, splt[0]);
        eventName = splt[1];
    }
    if (!elm) {
        // something's up, let's not continue and just return a noop()
        return noop;
    }
    eventListener = listenerCallback;
    // test to see if we're looking for an exact keycode
    splt = eventName.split('.');
    if (splt.length > 1) {
        // looks like this listener is also looking for a keycode
        // keyup.enter
        eventName = splt[0];
        eventListener = function (ev) {
            // wrap the user's event listener with our own check to test
            // if this keyboard event has the keycode they're looking for
            if (ev.keyCode === KEY_CODE_MAP[splt[1]]) {
                listenerCallback(ev);
            }
        };
    }
    // good to go now, add the event listener
    // and the returned value is a function to remove the same event listener
    return plt.domApi.$addEventListener(elm, eventName, eventListener, useCapture, usePassive);
}

function updateElement(plt, oldVnode, newVnode, isSvgMode, name) {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    var elm = (newVnode.elm.nodeType === 11 /* DocumentFragment */ && newVnode.elm.host) ? newVnode.elm.host : newVnode.elm;
    var oldVnodeAttrs = (oldVnode && oldVnode.vattrs) || EMPTY_OBJ;
    var newVnodeAttrs = newVnode.vattrs || EMPTY_OBJ;
    // remove attributes no longer present on the vnode by setting them to undefined
    for (name in oldVnodeAttrs) {
        if (!(newVnodeAttrs && newVnodeAttrs[name] != null) && oldVnodeAttrs[name] != null) {
            setAccessor(plt, elm, name, oldVnodeAttrs[name], undefined, isSvgMode);
        }
    }
    // add new & update changed attributes
    for (name in newVnodeAttrs) {
        if (!(name in oldVnodeAttrs) || newVnodeAttrs[name] !== (name === 'value' || name === 'checked' ? elm[name] : oldVnodeAttrs[name])) {
            setAccessor(plt, elm, name, oldVnodeAttrs[name], newVnodeAttrs[name], isSvgMode);
        }
    }
}
function setAccessor(plt, elm, name, oldValue, newValue, isSvg, i, ilen) {
    if (name === 'class' && !isSvg) {
        // Class
        if (oldValue !== newValue) {
            var oldList_1 = (oldValue == null || oldValue === '') ? EMPTY_ARR : oldValue.trim().split(/\s+/);
            var newList = (newValue == null || newValue === '') ? EMPTY_ARR : newValue.trim().split(/\s+/);
            var classList = (elm.className == null || elm.className === '') ? EMPTY_ARR : elm.className.trim().split(/\s+/);
            for (i = 0, ilen = oldList_1.length; i < ilen; i++) {
                if (newList.indexOf(oldList_1[i]) === -1) {
                    classList = classList.filter(function (c) { return c !== oldList_1[i]; });
                }
            }
            for (i = 0, ilen = newList.length; i < ilen; i++) {
                if (oldList_1.indexOf(newList[i]) === -1) {
                    classList = classList.concat([newList[i]]);
                }
            }
            elm.className = classList.join(' ');
        }
    }
    else if (name === 'style') {
        // Style
        oldValue = oldValue || EMPTY_OBJ;
        newValue = newValue || EMPTY_OBJ;
        for (i in oldValue) {
            if (!newValue[i]) {
                elm.style[i] = '';
            }
        }
        for (i in newValue) {
            if (newValue[i] !== oldValue[i]) {
                elm.style[i] = newValue[i];
            }
        }
    }
    else if (name[0] === 'o' && name[1] === 'n' && (!(name in elm))) {
        // Event Handlers
        // adding an standard event listener, like <button onClick=...> or something
        name = toLowerCase(name).substring(2);
        var listeners = (elm._listeners = elm._listeners || {});
        if (newValue) {
            if (!oldValue) {
                // add listener
                listeners[name] = addListener(plt, elm, name, newValue);
            }
        }
        else if (listeners[name]) {
            // remove listener
            listeners[name]();
        }
    }
    else if (name !== 'list' && name !== 'type' && !isSvg &&
        (name in elm || (['object', 'function'].indexOf(typeof newValue) !== -1) && newValue !== null)) {
        // Properties
        // - list and type are attributes that get applied as values on the element
        // - all svgs get values as attributes not props
        // - check if elm contains name or if the value is array, object, or function
        var cmpMeta = plt.getComponentMeta(elm);
        if (cmpMeta && cmpMeta.membersMeta && name in cmpMeta.membersMeta) {
            // setting a known @Prop on this element
            setProperty(elm, name, newValue);
        }
        else if (name !== 'ref') {
            // property setting a prop on a native property, like "value" or something
            setProperty(elm, name, newValue == null ? '' : newValue);
            if (newValue == null || newValue === false) {
                elm.removeAttribute(name);
            }
        }
    }
    else if (newValue != null) {
        // Element Attributes
        i = (name !== (name = name.replace(/^xlink\:?/, '')));
        if (BOOLEAN_ATTRS[name] === 1 && (!newValue || newValue === 'false')) {
            if (i) {
                elm.removeAttributeNS(XLINK_NS$1, toLowerCase(name));
            }
            else {
                elm.removeAttribute(name);
            }
        }
        else if (typeof newValue !== 'function') {
            if (i) {
                elm.setAttributeNS(XLINK_NS$1, toLowerCase(name), newValue);
            }
            else {
                elm.setAttribute(name, newValue);
            }
        }
    }
}
/**
 * Attempt to set a DOM property to the given value.
 * IE & FF throw for certain property-value combinations.
 */
function setProperty(elm, name, value) {
    try {
        elm[name] = value;
    }
    catch (e) { }
}
var BOOLEAN_ATTRS = {
    'allowfullscreen': 1,
    'async': 1,
    'autofocus': 1,
    'autoplay': 1,
    'checked': 1,
    'controls': 1,
    'disabled': 1,
    'enabled': 1,
    'formnovalidate': 1,
    'hidden': 1,
    'multiple': 1,
    'noresize': 1,
    'readonly': 1,
    'required': 1,
    'selected': 1,
    'spellcheck': 1,
};
var XLINK_NS$1 = 'http://www.w3.org/1999/xlink';

var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
 *
 * Modified for Stencil's renderer and slot projection
 */
var isSvgMode = false;
function createRendererPatch(plt, domApi) {
    // createRenderer() is only created once per app
    // the patch() function which createRenderer() returned is the function
    // which gets called numerous times by each component
    function createElm(vnode, parentElm, childIndex) {
        var i = 0;
        if (typeof vnode.vtag === 'function') {
            vnode = vnode.vtag(__assign({}, vnode.vattrs, { children: vnode.vchildren }));
        }
        if (Build.slot && vnode.vtag === 'slot' && !useNativeShadowDom) {
            if (hostContentNodes) {
                if (scopeId) {
                    domApi.$setAttribute(parentElm, scopeId + '-slot', '');
                }
                // special case for manually relocating host content nodes
                // to their new home in either a named slot or the default slot
                var namedSlot = (vnode.vattrs && vnode.vattrs.name);
                var slotNodes = void 0;
                if (isDef(namedSlot)) {
                    // this vnode is a named slot
                    slotNodes = hostContentNodes.namedSlots && hostContentNodes.namedSlots[namedSlot];
                }
                else {
                    // this vnode is the default slot
                    slotNodes = hostContentNodes.defaultSlot;
                }
                if (isDef(slotNodes)) {
                    // the host element has some nodes that need to be moved around
                    // we have a slot for the user's vnode to go into
                    // while we're moving nodes around, temporarily disable
                    // the disconnectCallback from working
                    plt.tmpDisconnected = true;
                    for (; i < slotNodes.length; i++) {
                        // remove the host content node from it's original parent node
                        // then relocate the host content node to its new slotted home
                        domApi.$appendChild(parentElm, domApi.$removeChild(domApi.$parentNode(slotNodes[i]), slotNodes[i]));
                    }
                    // done moving nodes around
                    // allow the disconnect callback to work again
                    plt.tmpDisconnected = false;
                }
            }
            // this was a slot node, we do not create slot elements, our work here is done
            // no need to return any element to be added to the dom
            return null;
        }
        if (isDef(vnode.vtext)) {
            // create text node
            vnode.elm = domApi.$createTextNode(vnode.vtext);
        }
        else {
            // create element
            var elm = vnode.elm = ((Build.svg && (isSvgMode || vnode.vtag === 'svg')) ? domApi.$createElementNS('http://www.w3.org/2000/svg', vnode.vtag) : domApi.$createElement(vnode.vtag));
            if (Build.svg) {
                isSvgMode = vnode.vtag === 'svg' ? true : (vnode.vtag === 'foreignObject' ? false : isSvgMode);
            }
            // add css classes, attrs, props, listeners, etc.
            updateElement(plt, null, vnode, isSvgMode);
            if (scopeId !== null && elm._scopeId !== scopeId) {
                // if there is a scopeId and this is the initial render
                // then let's add the scopeId as an attribute
                domApi.$setAttribute(elm, (elm._scopeId = scopeId), '');
            }
            var children = vnode.vchildren;
            if (Build.ssrServerSide && isDef(ssrId)) {
                // SSR ONLY: this is an SSR render and this
                // logic does not run on the client
                // give this element the SSR child id that can be read by the client
                domApi.$setAttribute(elm, SSR_CHILD_ID, ssrId + '.' + childIndex + (hasChildNodes(children) ? '' : '.'));
            }
            if (children) {
                var childNode = void 0;
                for (; i < children.length; ++i) {
                    // create the node
                    childNode = createElm(children[i], elm, i);
                    // return node could have been null
                    if (childNode) {
                        if (Build.ssrServerSide && isDef(ssrId) && childNode.nodeType === 3 /* TextNode */) {
                            // SSR ONLY: add the text node's start comment
                            domApi.$appendChild(elm, domApi.$createComment('s.' + ssrId + '.' + i));
                        }
                        // append our new node
                        domApi.$appendChild(elm, childNode);
                        if (Build.ssrServerSide && isDef(ssrId) && childNode.nodeType === 3) {
                            // SSR ONLY: add the text node's end comment
                            domApi.$appendChild(elm, domApi.$createComment('/'));
                            domApi.$appendChild(elm, domApi.$createTextNode(' '));
                        }
                    }
                }
            }
        }
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
        var containerElm = (parentElm.$defaultHolder && domApi.$parentNode(parentElm.$defaultHolder)) || parentElm;
        var childNode;
        for (; startIdx <= endIdx; ++startIdx) {
            var vnodeChild = vnodes[startIdx];
            if (isDef(vnodeChild)) {
                if (isDef(vnodeChild.vtext)) {
                    childNode = domApi.$createTextNode(vnodeChild.vtext);
                }
                else {
                    childNode = createElm(vnodeChild, parentElm, startIdx);
                }
                if (isDef(childNode)) {
                    vnodeChild.elm = childNode;
                    domApi.$insertBefore(containerElm, childNode, before);
                }
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            if (isDef(vnodes[startIdx])) {
                domApi.$removeChild(parentElm, vnodes[startIdx].elm);
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh) {
        var oldStartIdx = 0, newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var node;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (oldStartVnode == null) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldStartVnode, newStartVnode)) {
                patchVNode(oldStartVnode, newStartVnode);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (isSameVnode(oldEndVnode, newEndVnode)) {
                patchVNode(oldEndVnode, newEndVnode);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldStartVnode, newEndVnode)) {
                patchVNode(oldStartVnode, newEndVnode);
                domApi.$insertBefore(parentElm, oldStartVnode.elm, domApi.$nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (isSameVnode(oldEndVnode, newStartVnode)) {
                patchVNode(oldEndVnode, newStartVnode);
                domApi.$insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (isUndef(oldKeyToIdx)) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.vkey];
                if (isUndef(idxInOld)) {
                    // new element
                    node = createElm(newStartVnode, parentElm, newStartIdx);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.vtag !== newStartVnode.vtag) {
                        node = createElm(newStartVnode, parentElm, idxInOld);
                    }
                    else {
                        patchVNode(elmToMove, newStartVnode);
                        oldCh[idxInOld] = undefined;
                        node = elmToMove.elm;
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
                if (node) {
                    domApi.$insertBefore(parentElm, node, oldStartVnode.elm);
                }
            }
        }
        if (oldStartIdx > oldEndIdx) {
            addVnodes(parentElm, (newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm), newCh, newStartIdx, newEndIdx);
        }
        else if (newStartIdx > newEndIdx) {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function isSameVnode(vnode1, vnode2) {
        // compare if two vnode to see if they're "technically" the same
        // need to have the same element tag, and same key to be the same
        return vnode1.vtag === vnode2.vtag && vnode1.vkey === vnode2.vkey;
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
        var i, map = {}, key, ch;
        for (i = beginIdx; i <= endIdx; ++i) {
            ch = children[i];
            if (ch != null) {
                key = ch.vkey;
                if (key !== undefined) {
                    map.k = i;
                }
            }
        }
        return map;
    }
    function patchVNode(oldVNode, newVNode) {
        var elm = newVNode.elm = oldVNode.elm;
        var oldChildren = oldVNode.vchildren;
        var newChildren = newVNode.vchildren;
        if (Build.svg) {
            isSvgMode = newVNode.elm && newVNode.elm.parentElement != null && newVNode.elm.ownerSVGElement !== undefined;
            isSvgMode = newVNode.vtag === 'svg' ? true : (newVNode.vtag === 'foreignObject' ? false : isSvgMode);
        }
        if (isUndef(newVNode.vtext)) {
            // element node
            if (newVNode.vtag !== 'slot') {
                // either this is the first render of an element OR it's an update
                // AND we already know it's possible it could have changed
                // this updates the element's css classes, attrs, props, listeners, etc.
                updateElement(plt, oldVNode, newVNode, isSvgMode);
            }
            if (isDef(oldChildren) && isDef(newChildren)) {
                // looks like there's child vnodes for both the old and new vnodes
                updateChildren(elm, oldChildren, newChildren);
            }
            else if (isDef(newChildren)) {
                // no old child vnodes, but there are new child vnodes to add
                if (isDef(oldVNode.vtext)) {
                    // the old vnode was text, so be sure to clear it out
                    domApi.$setTextContent(elm, '');
                }
                // add the new vnode children
                addVnodes(elm, null, newChildren, 0, newChildren.length - 1);
            }
            else if (isDef(oldChildren)) {
                // no new child vnodes, but there are old child vnodes to remove
                removeVnodes(elm, oldChildren, 0, oldChildren.length - 1);
            }
        }
        else if (elm._hostContentNodes && elm._hostContentNodes.defaultSlot) {
            // this element has slotted content
            var parentElement = elm._hostContentNodes.defaultSlot[0].parentElement;
            domApi.$setTextContent(parentElement, newVNode.vtext);
            elm._hostContentNodes.defaultSlot = [parentElement.childNodes[0]];
        }
        else if (oldVNode.vtext !== newVNode.vtext) {
            // update the text content for the text only vnode
            // and also only if the text is different than before
            domApi.$setTextContent(elm, newVNode.vtext);
        }
    }
    // internal variables to be reused per patch() call
    var isUpdate, hostContentNodes, useNativeShadowDom, ssrId, scopeId;
    return function patch(oldVNode, newVNode, isUpdatePatch, hostElementContentNodes, encapsulation, ssrPatchId) {
        // patchVNode() is synchronous
        // so it is safe to set these variables and internally
        // the same patch() call will reference the same data
        isUpdate = isUpdatePatch;
        hostContentNodes = hostElementContentNodes;
        if (Build.ssrServerSide) {
            ssrId = ssrPatchId;
        }
        scopeId = (encapsulation === 2 /* ScopedCss */ || (encapsulation === 1 /* ShadowDom */ && !domApi.$supportsShadowDom)) ? 'data-' + domApi.$tagName(oldVNode.elm) : null;
        if (Build.shadowDom) {
            // use native shadow dom only if the component wants to use it
            // and if this browser supports native shadow dom
            useNativeShadowDom = (encapsulation === 1 /* ShadowDom */ && domApi.$supportsShadowDom);
        }
        if (!isUpdate) {
            if (Build.shadowDom && useNativeShadowDom) {
                // this component SHOULD use native slot/shadow dom
                // this browser DOES support native shadow dom
                // and this is the first render
                // let's create that shadow root
                oldVNode.elm = domApi.$attachShadow(oldVNode.elm, { mode: 'open' });
            }
            else if (scopeId) {
                // this host element should use scoped css
                // add the scope attribute to the host
                domApi.$setAttribute(oldVNode.elm, scopeId + '-host', '');
            }
        }
        // synchronous patch
        patchVNode(oldVNode, newVNode);
        if (Build.ssrServerSide && isDef(ssrId)) {
            // SSR ONLY: we've been given an SSR id, so the host element
            // should be given the ssr id attribute
            domApi.$setAttribute(oldVNode.elm, SSR_VNODE_ID, ssrId);
        }
        // return our new vnode
        return newVNode;
    };
}
function callNodeRefs(vNode, isDestroy) {
    if (vNode) {
        vNode.vref && vNode.vref(isDestroy ? null : vNode.elm);
        vNode.vchildren && vNode.vchildren.forEach(function (vChild) {
            callNodeRefs(vChild, isDestroy);
        });
    }
}
function hasChildNodes(children) {
    // SSR ONLY: check if there are any more nested child elements
    // if there aren't, this info is useful so the client runtime
    // doesn't have to climb down and check so many elements
    if (children) {
        for (var i = 0; i < children.length; i++) {
            if (children[i].vtag !== 'slot' || hasChildNodes(children[i].vchildren)) {
                return true;
            }
        }
    }
    return false;
}

function initEventEmitters(plt, componentEvents, instance) {
    if (componentEvents) {
        componentEvents.forEach(function (eventMeta) {
            instance[eventMeta.eventMethodName] = {
                emit: function (data) {
                    var eventData = {
                        bubbles: eventMeta.eventBubbles,
                        composed: eventMeta.eventComposed,
                        cancelable: eventMeta.eventCancelable,
                        detail: data
                    };
                    plt.emitEvent(instance.__el, eventMeta.eventName, eventData);
                }
            };
        });
    }
}

function parseComponentLoaders(cmpRegistryData, registry, attr) {
    // tag name will always be lower case
    var cmpMeta = {
        tagNameMeta: cmpRegistryData[0],
        membersMeta: {
            // every component defaults to always have
            // the mode and color properties
            // but only color should observe any attribute changes
            'mode': { memberType: 1 /* Prop */ },
            'color': { memberType: 1 /* Prop */, attribName: 'color' }
        }
    };
    // map of the modes w/ bundle id and style data
    cmpMeta.bundleIds = cmpRegistryData[1];
    // parse member meta
    // this data only includes props that are attributes that need to be observed
    // it does not include all of the props yet
    parseMembersData(cmpMeta, cmpRegistryData[3], attr);
    // encapsulation
    cmpMeta.encapsulation = cmpRegistryData[4];
    // slot
    cmpMeta.slotMeta = cmpRegistryData[5];
    if (cmpRegistryData[6]) {
        // parse listener meta
        cmpMeta.listenersMeta = cmpRegistryData[6].map(parseListenerData);
    }
    // bundle load priority
    cmpMeta.loadPriority = cmpRegistryData[7];
    return registry[cmpMeta.tagNameMeta] = cmpMeta;
}
function parseListenerData(listenerData) {
    return {
        eventName: listenerData[0],
        eventMethodName: listenerData[1],
        eventDisabled: !!listenerData[2],
        eventPassive: !!listenerData[3],
        eventCapture: !!listenerData[4]
    };
}
function parseMembersData(cmpMeta, memberData, attr) {
    if (memberData) {
        cmpMeta.membersMeta = cmpMeta.membersMeta || {};
        for (var i = 0; i < memberData.length; i++) {
            var d = memberData[i];
            cmpMeta.membersMeta[d[0]] = {
                memberType: d[1],
                attribName: d[2] ? attr === 1 /* LowerCase */ ? toLowerCase(d[0]) : toDashCase(d[0]) : 0,
                propType: d[3],
                ctrlId: d[4]
            };
        }
    }
}
function parseComponentMeta(registry, moduleImports, cmpMetaData, attr) {
    // tag name will always be lowser case
    var cmpMeta = registry[cmpMetaData[0]];
    // get the component class which was added to moduleImports
    // using the tag as the key on the export object
    cmpMeta.componentModule = moduleImports[cmpMetaData[0]];
    // component members
    parseMembersData(cmpMeta, cmpMetaData[1], attr);
    // host element meta
    cmpMeta.hostMeta = cmpMetaData[2];
    // component instance events
    if (cmpMetaData[3]) {
        cmpMeta.eventsMeta = cmpMetaData[3].map(parseEventData);
    }
    // component instance prop WILL change methods
    cmpMeta.propsWillChangeMeta = cmpMetaData[4];
    // component instance prop DID change methods
    cmpMeta.propsDidChangeMeta = cmpMetaData[5];
}
function parseEventData(d) {
    return {
        eventName: d[0],
        eventMethodName: d[1] || d[0],
        eventBubbles: !d[2],
        eventCancelable: !d[3],
        eventComposed: !d[4]
    };
}
function parsePropertyValue(propType, propValue) {
    // ensure this value is of the correct prop type
    if (isDef(propValue)) {
        if (propType === 3 /* Boolean */) {
            // per the HTML spec, any string value means it is a boolean true value
            // but we'll cheat here and say that the string "false" is the boolean false
            return (propValue === 'false' ? false : propValue === '' || !!propValue);
        }
        if (propType === 4 /* Number */) {
            // force it to be a number
            return parseFloat(propValue);
        }
    }
    // not sure exactly what type we want
    // so no need to change to a different type
    return propValue;
}

function proxyHostElementPrototype(plt, membersMeta, hostPrototype) {
    // create getters/setters on the host element prototype to represent the public API
    // the setters allows us to know when data has changed so we can re-render
    membersMeta && Object.keys(membersMeta).forEach(function (memberName) {
        // add getters/setters
        var memberType = membersMeta[memberName].memberType;
        if (memberType === 1 /* Prop */ || memberType === 2 /* PropMutable */) {
            // @Prop() or @Prop({ mutable: true })
            definePropertyGetterSetter(hostPrototype, memberName, function getHostElementProp() {
                // host element getter (cannot be arrow fn)
                // yup, ugly, srynotsry
                // but its creating _values if it doesn't already exist
                return (this._values = this._values || {})[memberName];
            }, function setHostElementProp(newValue) {
                // host element setter (cannot be arrow fn)
                setValue(plt, this, memberName, newValue);
            });
        }
        else if (memberType === 6 /* Method */) {
            // @Method()
            // add a placeholder noop value on the host element's prototype
            // incase this method gets called before setup
            definePropertyValue(hostPrototype, memberName, noop);
        }
    });
}
function proxyComponentInstance(plt, cmpMeta, elm, instance) {
    // at this point we've got a specific node of a host element, and created a component class instance
    // and we've already created getters/setters on both the host element and component class prototypes
    // let's upgrade any data that might have been set on the host element already
    // and let's have the getters/setters kick in and do their jobs
    // let's automatically add a reference to the host element on the instance
    instance.__el = elm;
    // create the _values object if it doesn't already exist
    // this will hold all of the internal getter/setter values
    elm._values = elm._values || {};
    cmpMeta.membersMeta && Object.keys(cmpMeta.membersMeta).forEach(function (memberName) {
        defineMember(plt, cmpMeta, elm, instance, memberName);
    });
}
function defineMember(plt, cmpMeta, elm, instance, memberName) {
    var memberMeta = cmpMeta.membersMeta[memberName];
    var memberType = memberMeta.memberType;
    function getComponentProp() {
        // component instance prop/state getter
        // get the property value directly from our internal values
        var elm = this.__el;
        return elm && elm._values && elm._values[memberName];
    }
    function setComponentProp(newValue) {
        // component instance prop/state setter (cannot be arrow fn)
        var elm = this.__el;
        if (elm) {
            if (memberType !== 1 /* Prop */) {
                setValue(plt, elm, memberName, newValue);
            }
            else if (Build.verboseError) {
                console.warn("@Prop() \"" + memberName + "\" on \"" + elm.tagName + "\" cannot be modified.");
            }
        }
    }
    if (memberType === 1 /* Prop */ || memberType === 5 /* State */ || memberType === 2 /* PropMutable */) {
        if (memberType !== 5 /* State */) {
            if (memberMeta.attribName && (elm._values[memberName] === undefined || elm._values[memberName] === '')) {
                // check the prop value from the host element attribute
                var hostAttrValue = elm.getAttribute(memberMeta.attribName);
                if (hostAttrValue != null) {
                    // looks like we've got an attribute value
                    // let's set it to our internal values
                    elm._values[memberName] = parsePropertyValue(memberMeta.propType, hostAttrValue);
                }
            }
            if (elm.hasOwnProperty(memberName)) {
                // @Prop or @Prop({mutable:true})
                // property values on the host element should override
                // any default values on the component instance
                if (elm._values[memberName] === undefined) {
                    elm._values[memberName] = elm[memberName];
                }
                if (plt.isClient) {
                    // within the browser, the element's prototype
                    // already has its getter/setter set, but on the
                    // server the prototype is shared causing issues
                    // so instead the server's elm has the getter/setter
                    // on the actual element instance, not its prototype
                    // for the client, let's delete its "own" property
                    delete elm[memberName];
                }
            }
        }
        if (instance.hasOwnProperty(memberName) && elm._values[memberName] === undefined) {
            // @Prop() or @Prop({mutable:true}) or @State()
            // we haven't yet got a value from the above checks so let's
            // read any "own" property instance values already set
            // to our internal value as the source of getter data
            // we're about to define a property and it'll overwrite this "own" property
            elm._values[memberName] = instance[memberName];
        }
        // add getter/setter to the component instance
        // these will be pointed to the internal data set from the above checks
        definePropertyGetterSetter(instance, memberName, getComponentProp, setComponentProp);
        // add watchers to props if they exist
        if (Build.propDidChange) {
            proxyPropChangeMethods(cmpMeta.propsWillChangeMeta, PROP_WILL_CHG, elm, instance, memberName);
        }
        if (Build.propWillChange) {
            proxyPropChangeMethods(cmpMeta.propsDidChangeMeta, PROP_DID_CHG, elm, instance, memberName);
        }
    }
    else if (Build.element && memberType === 7 /* Element */) {
        // @Element()
        // add a getter to the element reference using
        // the member name the component meta provided
        definePropertyValue(instance, memberName, elm);
    }
    else if (Build.method && memberType === 6 /* Method */) {
        // @Method()
        // add a property "value" on the host element
        // which we'll bind to the instance's method
        definePropertyValue(elm, memberName, instance[memberName].bind(instance));
    }
    else if (Build.propContext && memberType === 3 /* PropContext */) {
        // @Prop({ context: 'config' })
        var contextObj = plt.getContextItem(memberMeta.ctrlId);
        if (contextObj) {
            definePropertyValue(instance, memberName, (contextObj.getContext && contextObj.getContext(elm)) || contextObj);
        }
    }
    else if (Build.propConnect && memberType === 4 /* PropConnect */) {
        // @Prop({ connect: 'ion-loading-ctrl' })
        definePropertyValue(instance, memberName, plt.propConnect(memberMeta.ctrlId));
    }
}
function proxyPropChangeMethods(propChangeMeta, prefix, elm, instance, memberName) {
    // there are prop WILL change methods for this component
    var propChangeMthd = propChangeMeta && propChangeMeta.find(function (m) { return m[0 /* PropName */] === memberName; });
    if (propChangeMthd) {
        // cool, we should watch for changes to this property
        // let's bind their watcher function and add it to our list
        // of watchers, so any time this property changes we should
        // also fire off their method
        elm._values[prefix + memberName] = instance[propChangeMthd[1 /* MethodName */]].bind(instance);
    }
}
function setValue(plt, elm, memberName, newVal) {
    // get the internal values object, which should always come from the host element instance
    // create the _values object if it doesn't already exist
    var internalValues = (elm._values = elm._values || {});
    // check our new property value against our internal value
    var oldVal = internalValues[memberName];
    if (newVal !== oldVal) {
        // gadzooks! the property's value has changed!!
        if (Build.propWillChange && internalValues[PROP_WILL_CHG + memberName]) {
            // this instance is watching for when this property WILL change
            internalValues[PROP_WILL_CHG + memberName](newVal, oldVal);
        }
        // set our new value!
        // https://youtu.be/dFtLONl4cNc?t=22
        internalValues[memberName] = newVal;
        if (Build.propDidChange && internalValues[PROP_DID_CHG + memberName]) {
            // this instance is watching for when this property DID change
            internalValues[PROP_DID_CHG + memberName](newVal, oldVal);
        }
        if (elm._instance && !plt.activeRender) {
            // looks like this value actually changed, so we've got work to do!
            // but only if we've already created an instance, otherwise just chill out
            // queue that we need to do an update, but don't worry about queuing
            // up millions cuz this function ensures it only runs once
            queueUpdate(plt, elm);
        }
    }
}
function definePropertyValue(obj, propertyKey, value) {
    // minification shortcut
    Object.defineProperty(obj, propertyKey, {
        'configurable': true,
        'value': value
    });
}
function definePropertyGetterSetter(obj, propertyKey, get, set) {
    // minification shortcut
    Object.defineProperty(obj, propertyKey, {
        'configurable': true,
        'get': get,
        'set': set
    });
}
function proxyController(domApi, controllerComponents, ctrlTag) {
    return {
        'create': proxyProp(domApi, controllerComponents, ctrlTag, 'create'),
        'componentOnReady': proxyProp(domApi, controllerComponents, ctrlTag, 'componentOnReady')
    };
}
function loadComponent(domApi, controllerComponents, ctrlTag) {
    return new Promise(function (resolve) {
        var ctrlElm = controllerComponents[ctrlTag];
        if (!ctrlElm) {
            ctrlElm = domApi.$body.querySelector(ctrlTag);
        }
        if (!ctrlElm) {
            ctrlElm = controllerComponents[ctrlTag] = domApi.$createElement(ctrlTag);
            domApi.$appendChild(domApi.$body, ctrlElm);
        }
        ctrlElm.componentOnReady(resolve);
    });
}
function proxyProp(domApi, controllerComponents, ctrlTag, proxyMethodName) {
    return function () {
        var args = arguments;
        return loadComponent(domApi, controllerComponents, ctrlTag)
            .then(function (ctrlElm) { return ctrlElm[proxyMethodName].apply(ctrlElm, args); });
    };
}
var PROP_WILL_CHG = '$$wc';
var PROP_DID_CHG = '$$dc';

function initComponentInstance(plt, elm, cmpMeta) {
    try {
        // using the user's component class, let's create a new instance
        cmpMeta = plt.getComponentMeta(elm);
        elm._instance = new cmpMeta.componentModule();
        // ok cool, we've got an host element now, and a actual instance
        // and there were no errors creating the instance
        // let's upgrade the data on the host element
        // and let the getters/setters do their jobs
        proxyComponentInstance(plt, cmpMeta, elm, elm._instance);
        if (Build.event) {
            // add each of the event emitters which wire up instance methods
            // to fire off dom events from the host element
            initEventEmitters(plt, cmpMeta.eventsMeta, elm._instance);
        }
        if (Build.listener) {
            try {
                // replay any event listeners on the instance that
                // were queued up between the time the element was
                // connected and before the instance was ready
                replayQueuedEventsOnInstance(elm);
            }
            catch (e) {
                plt.onError(e, 2 /* QueueEventsError */, elm);
            }
        }
    }
    catch (e) {
        // something done went wrong trying to create a component instance
        // create a dumby instance so other stuff can load
        // but chances are the app isn't fully working cuz this component has issues
        elm._instance = {};
        plt.onError(e, 7 /* InitInstanceError */, elm, true);
    }
}
function initLoad(plt, elm, hydratedCssClass) {
    // all is good, this component has been told it's time to finish loading
    // it's possible that we've already decided to destroy this element
    // check if this element has any actively loading child elements
    if (elm._instance && !elm._hasDestroyed && (!elm.$activeLoading || !elm.$activeLoading.length)) {
        // cool, so at this point this element isn't already being destroyed
        // and it does not have any child elements that are still loading
        // ensure we remove any child references cuz it doesn't matter at this point
        elm.$activeLoading = null;
        // sweet, this particular element is good to go
        // all of this element's children have loaded (if any)
        elm._hasLoaded = true;
        try {
            // fire off the ref if it exists
            callNodeRefs(elm._vnode);
            // fire off the user's elm.componentOnReady() callbacks that were
            // put directly on the element (well before anything was ready)
            if (elm._onReadyCallbacks) {
                elm._onReadyCallbacks.forEach(function (cb) { return cb(elm); });
                elm._onReadyCallbacks = null;
            }
            if (Build.cmpDidLoad) {
                // fire off the user's componentDidLoad method (if one was provided)
                // componentDidLoad only runs ONCE, after the instance's element has been
                // assigned as the host element, and AFTER render() has been called
                // we'll also fire this method off on the element, just to
                elm._instance.componentDidLoad && elm._instance.componentDidLoad();
            }
        }
        catch (e) {
            plt.onError(e, 4 /* DidLoadError */, elm);
        }
        // add the css class that this element has officially hydrated
        elm.classList.add(hydratedCssClass);
        // ( •_•)
        // ( •_•)>⌐■-■
        // (⌐■_■)
        // load events fire from bottom to top
        // the deepest elements load first then bubbles up
        propagateElementLoaded(elm);
    }
}
function propagateElementLoaded(elm, index, ancestorsActivelyLoadingChildren) {
    // load events fire from bottom to top
    // the deepest elements load first then bubbles up
    if (elm._ancestorHostElement) {
        // ok so this element already has a known ancestor host element
        // let's make sure we remove this element from its ancestor's
        // known list of child elements which are actively loading
        ancestorsActivelyLoadingChildren = elm._ancestorHostElement.$activeLoading;
        if (ancestorsActivelyLoadingChildren) {
            index = ancestorsActivelyLoadingChildren.indexOf(elm);
            if (index > -1) {
                // yup, this element is in the list of child elements to wait on
                // remove it so we can work to get the length down to 0
                ancestorsActivelyLoadingChildren.splice(index, 1);
            }
            // the ancestor's initLoad method will do the actual checks
            // to see if the ancestor is actually loaded or not
            // then let's call the ancestor's initLoad method if there's no length
            // (which actually ends up as this method again but for the ancestor)
            !ancestorsActivelyLoadingChildren.length && elm._ancestorHostElement.$initLoad();
        }
        // fuhgeddaboudit, no need to keep a reference after this element loaded
        elm._ancestorHostElement = null;
    }
}

function createThemedClasses(mode, color, classList) {
    var allClasses = {};
    return classList.split(' ')
        .reduce(function (classObj, classString) {
        classObj[classString] = true;
        if (mode) {
            classObj[classString + "-" + mode] = true;
            if (color) {
                classObj[classString + "-" + color] = true;
                classObj[classString + "-" + mode + "-" + color] = true;
            }
        }
        return classObj;
    }, allClasses);
}

var VNode = /** @class */ (function () {
    function VNode() {
    }
    return VNode;
}());

/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
var stack = [];
function h(nodeName, vnodeData, child) {
    var children;
    var lastSimple = false;
    var simple = false;
    for (var i = arguments.length; i-- > 2;) {
        stack.push(arguments[i]);
    }
    while (stack.length) {
        if ((child = stack.pop()) && child.pop !== undefined) {
            for (i = child.length; i--;) {
                stack.push(child[i]);
            }
        }
        else {
            if (typeof child === 'boolean')
                child = null;
            if ((simple = typeof nodeName !== 'function')) {
                if (child == null)
                    child = '';
                else if (typeof child === 'number')
                    child = String(child);
                else if (typeof child !== 'string')
                    simple = false;
            }
            if (simple && lastSimple) {
                children[children.length - 1].vtext += child;
            }
            else if (children === undefined) {
                children = [simple ? t(child) : child];
            }
            else {
                children.push(simple ? t(child) : child);
            }
            lastSimple = simple;
        }
    }
    var vnode = new VNode();
    vnode.vtag = nodeName;
    vnode.vchildren = children;
    if (vnodeData) {
        vnode.vattrs = vnodeData;
        vnode.vkey = vnodeData.key;
        vnode.vref = vnodeData.ref;
        // normalize class / classname attributes
        if (vnodeData['className']) {
            vnodeData['class'] = vnodeData['className'];
        }
        if (typeof vnodeData['class'] === 'object') {
            for (i in vnodeData['class']) {
                if (vnodeData['class'][i]) {
                    stack.push(i);
                }
            }
            vnodeData['class'] = stack.join(' ');
            stack.length = 0;
        }
    }
    return vnode;
}
function t(textValue) {
    var vnode = new VNode();
    vnode.vtext = textValue;
    return vnode;
}

function render(plt, elm, cmpMeta, isUpdateRender) {
    var instance = elm._instance;
    // if this component has a render function, let's fire
    // it off and generate the child vnodes for this host element
    // note that we do not create the host element cuz it already exists
    var hostMeta = cmpMeta.hostMeta;
    if (instance.render || instance.hostData || hostMeta) {
        // tell the platform we're actively rendering
        // if a value is changed within a render() then
        // this tells the platform not to queue the change
        plt.activeRender = true;
        var vnodeChildren = instance.render && instance.render();
        var vnodeHostData = void 0;
        if (Build.hostData) {
            // user component provided a "hostData()" method
            // the returned data/attributes are used on the host element
            vnodeHostData = instance.hostData && instance.hostData();
        }
        // tell the platform we're done rendering
        // now any changes will again queue
        plt.activeRender = false;
        if (Build.hostTheme && hostMeta) {
            // component meta data has a "theme"
            // use this to automatically generate a good css class
            // from the mode and color to add to the host element
            vnodeHostData = Object.keys(hostMeta).reduce(function (hostData, key) {
                switch (key) {
                    case 'theme':
                        hostData['class'] = hostData['class'] || {};
                        hostData['class'] = Object.assign(hostData['class'], createThemedClasses(instance.mode, instance.color, hostMeta['theme']));
                }
                return hostData;
            }, vnodeHostData || {});
        }
        // looks like we've got child nodes to render into this host element
        // or we need to update the css class/attrs on the host element
        // if we haven't already created a vnode, then we give the renderer the actual element
        // if this is a re-render, then give the renderer the last vnode we already created
        var oldVNode = elm._vnode || new VNode();
        oldVNode.elm = elm;
        // each patch always gets a new vnode
        // the host element itself isn't patched because it already exists
        // kick off the actual render and any DOM updates
        elm._vnode = plt.render(oldVNode, h(null, vnodeHostData, vnodeChildren), isUpdateRender, elm._hostContentNodes, cmpMeta.encapsulation);
    }
    if (Build.styles) {
        // attach the styles this component needs, if any
        // this fn figures out if the styles should go in a
        // shadow root or if they should be global
        plt.attachStyles(cmpMeta, instance.mode, elm);
    }
    // it's official, this element has rendered
    elm.$rendered = true;
    if (elm.$onRender) {
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        elm.$onRender.forEach(function (cb) { return cb(); });
        elm.$onRender = null;
    }
}

function queueUpdate(plt, elm) {
    // only run patch if it isn't queued already
    if (!elm._isQueuedForUpdate) {
        elm._isQueuedForUpdate = true;
        // run the patch in the next tick
        plt.queue.add(function () {
            // no longer queued
            elm._isQueuedForUpdate = false;
            // vdom diff and patch the host element for differences
            update(plt, elm);
        });
    }
}
function update(plt, elm) {
    // everything is async, so somehow we could have already disconnected
    // this node, so be sure to do nothing if we've already disconnected
    if (!elm._hasDestroyed) {
        var isInitialLoad_1 = !elm._instance;
        var userPromise = void 0;
        if (isInitialLoad_1) {
            var ancestorHostElement = elm._ancestorHostElement;
            if (ancestorHostElement && !ancestorHostElement.$rendered) {
                // this is the intial load
                // this element has an ancestor host element
                // but the ancestor host element has NOT rendered yet
                // so let's just cool our jets and wait for the ancestor to render
                (ancestorHostElement.$onRender = ancestorHostElement.$onRender || []).push(function () {
                    // this will get fired off when the ancestor host element
                    // finally gets around to rendering its lazy self
                    update(plt, elm);
                });
                return;
            }
            // haven't created a component instance for this host element yet!
            // create the instance from the user's component class
            // https://www.youtube.com/watch?v=olLxrojmvMg
            initComponentInstance(plt, elm);
            if (Build.cmpWillLoad) {
                // fire off the user's componentWillLoad method (if one was provided)
                // componentWillLoad only runs ONCE, after instance's element has been
                // assigned as the host element, but BEFORE render() has been called
                try {
                    if (elm._instance.componentWillLoad) {
                        userPromise = elm._instance.componentWillLoad();
                    }
                }
                catch (e) {
                    plt.onError(e, 3 /* WillLoadError */, elm);
                }
            }
        }
        else if (Build.cmpWillUpdate) {
            // already created an instance and this is an update
            // fire off the user's componentWillUpdate method (if one was provided)
            // componentWillUpdate runs BEFORE render() has been called
            // but only BEFORE an UPDATE and not before the intial render
            // get the returned promise (if one was provided)
            try {
                if (elm._instance.componentWillUpdate) {
                    userPromise = elm._instance.componentWillUpdate();
                }
            }
            catch (e) {
                plt.onError(e, 5 /* WillUpdateError */, elm);
            }
        }
        if (userPromise && userPromise.then) {
            // looks like the user return a promise!
            // let's not actually kick off the render
            // until the user has resolved their promise
            userPromise.then(function () { return renderUpdate(plt, elm, isInitialLoad_1); });
        }
        else {
            // user never returned a promise so there's
            // no need to wait on anything, let's do the render now my friend
            renderUpdate(plt, elm, isInitialLoad_1);
        }
    }
}
function renderUpdate(plt, elm, isInitialLoad) {
    // if this component has a render function, let's fire
    // it off and generate a vnode for this
    try {
        render(plt, elm, plt.getComponentMeta(elm), !isInitialLoad);
        // _hasRendered was just set
        // _onRenderCallbacks were all just fired off
    }
    catch (e) {
        plt.onError(e, 8 /* RenderError */, elm, true);
    }
    try {
        if (isInitialLoad) {
            // so this was the initial load i guess
            elm.$initLoad();
            // componentDidLoad just fired off
        }
        else {
            if (Build.cmpDidUpdate) {
                // fire off the user's componentDidUpdate method (if one was provided)
                // componentDidUpdate runs AFTER render() has been called
                // but only AFTER an UPDATE and not after the intial render
                elm._instance.componentDidUpdate && elm._instance.componentDidUpdate();
            }
        }
    }
    catch (e) {
        // derp
        plt.onError(e, 6 /* DidUpdateError */, elm, true);
    }
}

function connectedCallback(plt, cmpMeta, elm) {
    // do not reconnect if we've already created an instance for this element
    if (!elm.$connected) {
        // first time we've connected
        elm.$connected = true;
        // if somehow this node was reused, ensure we've removed this property
        elm._hasDestroyed = null;
        if (Build.listener) {
            // initialize our event listeners on the host element
            // we do this now so that we can listening to events that may
            // have fired even before the instance is ready
            initElementListeners(plt, elm);
        }
        // register this component as an actively
        // loading child to its parent component
        registerWithParentComponent(plt, elm);
        // add to the queue to load the bundle
        // it's important to have an async tick in here so we can
        // ensure the "mode" attribute has been added to the element
        // place in high priority since it's not much work and we need
        // to know as fast as possible, but still an async tick in between
        plt.queue.add(function () {
            // only collects slot references if this component even has slots
            plt.connectHostElement(cmpMeta, elm);
            // start loading this component mode's bundle
            // if it's already loaded then the callback will be synchronous
            plt.loadBundle(cmpMeta, elm, function () {
                // we've fully loaded the component mode data
                // let's queue it up to be rendered next
                return queueUpdate(plt, elm);
            });
        }, 3 /* High */);
    }
}
function registerWithParentComponent(plt, elm, ancestorHostElement) {
    // find the first ancestor host element (if there is one) and register
    // this element as one of the actively loading child elements for its ancestor
    ancestorHostElement = elm;
    while (ancestorHostElement = plt.domApi.$parentElement(ancestorHostElement)) {
        // climb up the ancestors looking for the first registered component
        if (plt.isDefinedComponent(ancestorHostElement)) {
            // we found this elements the first ancestor host element
            // if the ancestor already loaded then do nothing, it's too late
            if (!ancestorHostElement._hasLoaded) {
                // keep a reference to this element's ancestor host element
                elm._ancestorHostElement = ancestorHostElement;
                // ensure there is an array to contain a reference to each of the child elements
                // and set this element as one of the ancestor's child elements it should wait on
                (ancestorHostElement.$activeLoading = ancestorHostElement.$activeLoading || []).push(elm);
            }
            break;
        }
    }
}

function createDomApi(win, doc, WindowCustomEvent) {
    // using the $ prefix so that closure is
    // cool with property renaming each of these
    var domApi = {
        $documentElement: doc.documentElement,
        $head: doc.head,
        $body: doc.body,
        $nodeType: function (node) {
            return node.nodeType;
        },
        $createElement: function (tagName) {
            return doc.createElement(tagName);
        },
        $createElementNS: function (namespace, tagName) {
            return doc.createElementNS(namespace, tagName);
        },
        $createTextNode: function (text) { return doc.createTextNode(text); },
        $createComment: function (data) { return doc.createComment(data); },
        $insertBefore: function (parentNode, childNode, referenceNode) {
            return parentNode.insertBefore(childNode, referenceNode);
        },
        $removeChild: function (parentNode, childNode) {
            return parentNode.removeChild(childNode);
        },
        $appendChild: function (parentNode, childNode) {
            return parentNode.appendChild(childNode);
        },
        $childNodes: function (node) {
            return node.childNodes;
        },
        $parentNode: function (node) {
            return node.parentNode;
        },
        $nextSibling: function (node) {
            return node.nextSibling;
        },
        $tagName: function (elm) {
            return toLowerCase(elm.tagName);
        },
        $getTextContent: function (node) {
            return node.textContent;
        },
        $setTextContent: function (node, text) {
            return node.textContent = text;
        },
        $getAttribute: function (elm, key) {
            return elm.getAttribute(key);
        },
        $setAttribute: function (elm, key, val) {
            return elm.setAttribute(key, val);
        },
        $setAttributeNS: function (elm, namespaceURI, qualifiedName, val) {
            return elm.setAttributeNS(namespaceURI, qualifiedName, val);
        },
        $removeAttribute: function (elm, key) {
            return elm.removeAttribute(key);
        },
        $addEventListener: function (elm, eventName, eventListener, useCapture, usePassive, eventListenerOpts) {
            eventListenerOpts = domApi.$supportsEventOptions ? {
                capture: !!useCapture,
                passive: !!usePassive
            } : !!useCapture;
            // ok, good to go, let's add the actual listener to the dom element
            elm.addEventListener(eventName, eventListener, eventListenerOpts);
            // return a function which is used to remove this very same listener
            return function () { return elm && elm.removeEventListener(eventName, eventListener, eventListenerOpts); };
        },
        $elementRef: function (elm, referenceName) {
            if (referenceName === 'child') {
                return elm.firstElementChild;
            }
            if (referenceName === 'parent') {
                return domApi.$parentElement(elm);
            }
            if (referenceName === 'body') {
                return domApi.$body;
            }
            if (referenceName === 'document') {
                return doc;
            }
            if (referenceName === 'window') {
                return win;
            }
            return elm;
        }
    };
    if (Build.shadowDom) {
        domApi.$attachShadow = function (elm, shadowRootInit) { return elm.attachShadow(shadowRootInit); };
        domApi.$supportsShadowDom = !!domApi.$documentElement.attachShadow;
    }
    if (Build.event) {
        WindowCustomEvent = win.CustomEvent;
        if (typeof WindowCustomEvent !== 'function') {
            // CustomEvent polyfill
            WindowCustomEvent = function (event, data, evt) {
                evt = doc.createEvent('CustomEvent');
                evt.initCustomEvent(event, data.bubbles, data.cancelable, data.detail);
                return evt;
            };
            WindowCustomEvent.prototype = win.Event.prototype;
        }
        // test if this browser supports event options or not
        try {
            win.addEventListener('e', null, Object.defineProperty({}, 'passive', {
                get: function () { return domApi.$supportsEventOptions = true; }
            }));
        }
        catch (e) { }
        domApi.$dispatchEvent = function (elm, eventName, data) { return elm && elm.dispatchEvent(new WindowCustomEvent(eventName, data)); };
    }
    domApi.$parentElement = function (elm, parentNode) {
        // if the parent node is a document fragment (shadow root)
        // then use the "host" property on it
        // otherwise use the parent node
        parentNode = domApi.$parentNode(elm);
        return (parentNode && domApi.$nodeType(parentNode) === 11 /* DocumentFragment */) ? parentNode.host : parentNode;
    };
    return domApi;
}

function assignHostContentSlots(domApi, cmpMeta, elm, childNodes) {
    // compiler has already figured out if this component has slots or not
    // if the component doesn't even have slots then we'll skip over all of this code
    if (cmpMeta.slotMeta) {
        // looks like this component has slots
        // so let's loop through each of the childNodes to the host element
        // and pick out the ones that have a slot attribute
        // if it doesn't have a slot attribute, than it's a default slot
        if (!elm.$defaultHolder) {
            // create a comment to represent where the original
            // content was first placed, which is useful later on
            domApi.$insertBefore(elm, (elm.$defaultHolder = domApi.$createComment('')), childNodes[0]);
        }
        var slotName = void 0;
        var defaultSlot = void 0;
        var namedSlots = void 0;
        var i = 0;
        for (; i < childNodes.length; i++) {
            var childNode = childNodes[i];
            if (domApi.$nodeType(childNode) === 1 /* ElementNode */ && ((slotName = domApi.$getAttribute(childNode, 'slot')) != null)) {
                // is element node
                // this element has a slot name attribute
                // so this element will end up getting relocated into
                // the component's named slot once it renders
                namedSlots = namedSlots || {};
                if (namedSlots[slotName]) {
                    namedSlots[slotName].push(childNode);
                }
                else {
                    namedSlots[slotName] = [childNode];
                }
            }
            else {
                // this is a text node
                // or it's an element node that doesn't have a slot attribute
                // let's add this node to our collection for the default slot
                if (defaultSlot) {
                    defaultSlot.push(childNode);
                }
                else {
                    defaultSlot = [childNode];
                }
            }
        }
        // keep a reference to all of the initial nodes
        // found as immediate childNodes to the host element
        elm._hostContentNodes = {
            defaultSlot: defaultSlot,
            namedSlots: namedSlots
        };
    }
}

function createQueueServer() {
    var highCallbacks = [];
    var mediumCallbacks = [];
    var lowCallbacks = [];
    var queued = false;
    function flush(cb) {
        while (highCallbacks.length > 0) {
            highCallbacks.shift()();
        }
        while (mediumCallbacks.length > 0) {
            mediumCallbacks.shift()();
        }
        while (lowCallbacks.length > 0) {
            lowCallbacks.shift()();
        }
        queued = (highCallbacks.length > 0) || (mediumCallbacks.length > 0) || (lowCallbacks.length > 0);
        if (queued) {
            process.nextTick(flush);
        }
        cb && cb();
    }
    function add(cb, priority) {
        if (priority === 3 /* High */) {
            highCallbacks.push(cb);
        }
        else if (priority === 1 /* Low */) {
            lowCallbacks.push(cb);
        }
        else {
            mediumCallbacks.push(cb);
        }
        if (!queued) {
            queued = true;
            process.nextTick(flush);
        }
    }
    return {
        add: add,
        flush: flush
    };
}

function createPlatformServer(config, win, doc, domApi, diagnostics, isPrerender, ctx) {
    var registry = { 'html': {} };
    var moduleImports = {};
    var bundleCallbacks = {};
    var loadedBundles = {};
    var pendingBundleFileReads = {};
    var stylesMap = {};
    var controllerComponents = {};
    // init build context
    ctx = ctx || {};
    // initialize Core global object
    var Context = {};
    Context.addListener = noop;
    Context.enableListener = noop;
    Context.emit = noop;
    Context.isClient = false;
    Context.isServer = true;
    Context.isPrerender = isPrerender;
    Context.window = win;
    Context.location = win.location;
    Context.document = doc;
    // add the Core global to the window context
    // Note: "Core" is not on the window context on the client-side
    win.Context = Context;
    // create the app global
    var App = {};
    // add the app's global to the window context
    win[config.namespace] = App;
    // keep a global set of tags we've already defined
    var globalDefined = win.$definedComponents = win.$definedComponents || {};
    var appWwwDir = config.wwwDir;
    var appBuildDir = config.sys.path.join(config.buildDir, getAppFileName(config));
    // create the sandboxed context with a new instance of a V8 Context
    // V8 Context provides an isolated global environment
    config.sys.vm.createContext(ctx, appWwwDir, win);
    // execute the global scripts (if there are any)
    runGlobalScripts();
    // create the platform api which is used throughout common core code
    var plt = {
        attachStyles: noop,
        connectHostElement: connectHostElement,
        defineComponent: defineComponent,
        domApi: domApi,
        emitEvent: noop,
        getComponentMeta: getComponentMeta,
        getContextItem: getContextItem,
        isDefinedComponent: isDefinedComponent,
        loadBundle: loadBundle,
        onError: onError,
        propConnect: propConnect,
        queue: createQueueServer(),
        tmpDisconnected: false,
    };
    // create the renderer which will be used to patch the vdom
    plt.render = createRendererPatch(plt, domApi);
    // setup the root node of all things
    // which is the mighty <html> tag
    var rootElm = domApi.$documentElement;
    rootElm.$rendered = true;
    rootElm.$activeLoading = [];
    rootElm.$initLoad = function appLoadedCallback() {
        rootElm._hasLoaded = true;
        appLoaded();
    };
    function appLoaded(failureDiagnostic) {
        if (rootElm._hasLoaded || failureDiagnostic) {
            // the root node has loaded
            // and there are no css files still loading
            plt.onAppLoad && plt.onAppLoad(rootElm, stylesMap, failureDiagnostic);
        }
    }
    function connectHostElement(cmpMeta, elm) {
        // set the "mode" property
        if (!elm.mode) {
            // looks like mode wasn't set as a property directly yet
            // first check if there's an attribute
            // next check the app's global
            elm.mode = domApi.$getAttribute(elm, 'mode') || Context.mode;
        }
        // pick out all of the light dom nodes from the host element
        assignHostContentSlots(domApi, cmpMeta, elm, elm.childNodes);
    }
    function getComponentMeta(elm) {
        // registry tags are always lower-case
        return registry[elm.tagName.toLowerCase()];
    }
    function defineComponent(cmpMeta) {
        // default mode and color props
        cmpMeta.membersMeta = cmpMeta.membersMeta || {};
        cmpMeta.membersMeta.mode = { memberType: 1 /* Prop */ };
        cmpMeta.membersMeta.color = { memberType: 1 /* Prop */, attribName: 'color' };
        // registry tags are always lower-case
        var registryTag = cmpMeta.tagNameMeta.toLowerCase();
        if (!globalDefined[registryTag]) {
            globalDefined[registryTag] = true;
            registry[registryTag] = cmpMeta;
            if (cmpMeta.componentModule) {
                // for unit testing
                moduleImports[registryTag] = cmpMeta.componentModule;
            }
        }
    }
    function isDefinedComponent(elm) {
        return !!(globalDefined[elm.tagName.toLowerCase()] || registry[elm.tagName.toLowerCase()]);
    }
    App.loadComponents = function loadComponents(bundleId, importFn) {
        var args = arguments;
        // import component function
        // inject globals
        importFn(moduleImports, h, Context, appBuildDir);
        for (var i = 2; i < args.length; i++) {
            parseComponentMeta(registry, moduleImports, args[i], Context.attr);
        }
        // fire off all the callbacks waiting on this bundle to load
        var callbacks = bundleCallbacks[bundleId];
        if (callbacks) {
            for (i = 0; i < callbacks.length; i++) {
                callbacks[i]();
            }
            delete bundleCallbacks[bundleId];
        }
        // remember that we've already loaded this bundle
        loadedBundles[bundleId] = true;
    };
    App.loadStyles = function loadStyles() {
        // jsonp callback from requested bundles
        var args = arguments;
        for (var i = 0; i < args.length; i += 2) {
            stylesMap[args[i]] = args[i + 1];
        }
    };
    function loadBundle(cmpMeta, elm, cb) {
        if (cmpMeta.componentModule) {
            // we already have the module loaded
            // (this is probably a unit test)
            cb();
            return;
        }
        var bundleId = (cmpMeta.bundleIds[elm.mode] || cmpMeta.bundleIds[DEFAULT_STYLE_MODE] || cmpMeta.bundleIds).es2015;
        if (loadedBundles[bundleId]) {
            // sweet, we've already loaded this bundle
            cb();
        }
        else {
            // never seen this bundle before, let's start loading the file
            // and add it to the bundle callbacks to fire when it's loaded
            (bundleCallbacks[bundleId] = bundleCallbacks[bundleId] || []).push(cb);
            var requestBundleId = bundleId;
            if (cmpMeta.encapsulation === 2 /* ScopedCss */ || cmpMeta.encapsulation === 1 /* ShadowDom */) {
                requestBundleId += '.sc';
            }
            requestBundleId += '.js';
            // create the bundle filePath we'll be reading
            var jsFilePath_1 = normalizePath(config.sys.path.join(appBuildDir, requestBundleId));
            if (!pendingBundleFileReads[jsFilePath_1]) {
                // not already actively reading this file
                // remember that we're now actively requesting this url
                pendingBundleFileReads[jsFilePath_1] = true;
                // let's kick off reading the bundle
                // this could come from the cache or a new readFile
                getJsFile(config.sys, ctx, jsFilePath_1).then(function (jsContent) {
                    // remove it from the list of file reads we're waiting on
                    delete pendingBundleFileReads[jsFilePath_1];
                    // run the code in this sandboxed context
                    config.sys.vm.runInContext(jsContent, win, { timeout: 10000 });
                }).catch(function (err) {
                    onError(err, 1 /* LoadBundleError */, elm, true);
                });
            }
        }
    }
    function runGlobalScripts() {
        if (!ctx || !ctx.appFiles || !ctx.appFiles.global) {
            return;
        }
        config.sys.vm.runInContext(ctx.appFiles.global, win);
    }
    function onError(err, type, elm, appFailure) {
        var d = {
            type: 'runtime',
            header: 'Runtime error detected',
            level: 'error',
            messageText: err ? err.message ? err.message : err.toString() : null
        };
        switch (type) {
            case 1 /* LoadBundleError */:
                d.header += ' while loading bundle';
                break;
            case 2 /* QueueEventsError */:
                d.header += ' while running initial events';
                break;
            case 3 /* WillLoadError */:
                d.header += ' during componentWillLoad()';
                break;
            case 4 /* DidLoadError */:
                d.header += ' during componentDidLoad()';
                break;
            case 7 /* InitInstanceError */:
                d.header += ' while initializing instance';
                break;
            case 8 /* RenderError */:
                d.header += ' while rendering';
                break;
            case 6 /* DidUpdateError */:
                d.header += ' while updating';
                break;
        }
        if (elm && elm.tagName) {
            d.header += ': ' + elm.tagName.toLowerCase();
        }
        diagnostics.push(d);
        if (appFailure) {
            appLoaded(d);
        }
    }
    function propConnect(ctrlTag) {
        return proxyController(domApi, controllerComponents, ctrlTag);
    }
    function getContextItem(contextKey) {
        return Context[contextKey];
    }
    return plt;
}

function collapseHtmlWhitepace(node) {
    // this isn't about reducing HTML filesize (cuz it doesn't really matter after gzip)
    // this is more about having many less nodes for the client side to
    // have to climb through while it's creating vnodes from this HTML
    if (WHITESPACE_SENSITIVE_TAGS.indexOf(node.tagName) > -1) {
        return;
    }
    var lastWhitespaceTextNode = null;
    for (var i = node.childNodes.length - 1; i >= 0; i--) {
        var childNode = node.childNodes[i];
        if (childNode.nodeType === 3 /* TextNode */ || childNode.nodeType === 8 /* CommentNode */) {
            childNode.nodeValue = childNode.nodeValue.replace(REDUCE_WHITESPACE_REGEX, ' ');
            if (childNode.nodeValue === ' ') {
                if (lastWhitespaceTextNode === null) {
                    childNode.nodeValue = ' ';
                    lastWhitespaceTextNode = childNode;
                }
                else {
                    childNode.parentNode.removeChild(childNode);
                }
                continue;
            }
        }
        else if (childNode.childNodes) {
            collapseHtmlWhitepace(childNode);
        }
        lastWhitespaceTextNode = null;
    }
}
var REDUCE_WHITESPACE_REGEX = /\s\s+/g;
var WHITESPACE_SENSITIVE_TAGS = ['PRE', 'SCRIPT', 'STYLE', 'TEXTAREA'];

function inlineLoaderScript(config, ctx, doc) {
    if (!ctx.appFiles || !ctx.appFiles.loader) {
        // don't bother if we don't have good loader content for whatever reason
        return;
    }
    // create the script url we'll be looking for
    var loaderExternalSrcUrl = config.publicPath;
    if (loaderExternalSrcUrl.charAt(loaderExternalSrcUrl.length - 1) !== '/') {
        loaderExternalSrcUrl += '/';
    }
    loaderExternalSrcUrl += getAppFileName(config) + '.js';
    // remove the app loader script url request
    var removedLoader = removeExternalLoaderScript(doc, loaderExternalSrcUrl);
    if (removedLoader) {
        // append the loader script content to the bottom of the document
        appendInlineLoaderScript(ctx, doc);
    }
}
function removeExternalLoaderScript(doc, loaderExternalSrcUrl) {
    var removedLoader = false;
    var scriptElements = doc.getElementsByTagName('script');
    for (var i = 0; i < scriptElements.length; i++) {
        if (scriptElements[i].src.indexOf(loaderExternalSrcUrl) > -1) {
            // this is a script element with a src attribute which is
            // pointing to the app's external loader script
            // remove the script from the document, be gone with you
            scriptElements[i].parentNode.removeChild(scriptElements[i]);
            removedLoader = true;
        }
    }
    return removedLoader;
}
function appendInlineLoaderScript(ctx, doc) {
    // now that we've removed the external script
    // let's add the loader script back in, except let's
    // inline the js directly into the document
    // and append it as the last child in the body
    var scriptElm = doc.createElement('script');
    scriptElm.innerHTML = ctx.appFiles.loader;
    doc.body.appendChild(scriptElm);
}

function formatFileName(rootDir, fileName) {
    if (!rootDir || !fileName)
        return '';
    fileName = fileName.replace(rootDir, '');
    if (/\/|\\/.test(fileName.charAt(0))) {
        fileName = fileName.substr(1);
    }
    if (fileName.length > 80) {
        fileName = '...' + fileName.substr(fileName.length - 80);
    }
    return fileName;
}
function formatHeader(type, fileName, rootDir, startLineNumber, endLineNumber) {
    if (startLineNumber === void 0) { startLineNumber = null; }
    if (endLineNumber === void 0) { endLineNumber = null; }
    var header = type + ": " + formatFileName(rootDir, fileName);
    if (startLineNumber !== null && startLineNumber > 0) {
        if (endLineNumber !== null && endLineNumber > startLineNumber) {
            header += ", lines: " + startLineNumber + " - " + endLineNumber;
        }
        else {
            header += ", line: " + startLineNumber;
        }
    }
    return header;
}

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
function parseCss(config, css, filePath) {
    /**
     * Positional.
     */
    var lineno = 1;
    var column = 1;
    var srcLines;
    /**
     * Update lineno and column based on `str`.
     */
    function updatePosition(str) {
        var lines = str.match(/\n/g);
        if (lines)
            lineno += lines.length;
        var i = str.lastIndexOf('\n');
        column = ~i ? str.length - i : column + str.length;
    }
    /**
     * Mark position and patch `node.position`.
     */
    function position() {
        var start = { line: lineno, column: column };
        return function (node) {
            node.position = new ParsePosition(start);
            whitespace();
            return node;
        };
    }
    /**
     * Store position information for a node
     */
    var ParsePosition = /** @class */ (function () {
        function ParsePosition(start) {
            this.start = start;
            this.end = { line: lineno, column: column };
            this.source = filePath;
        }
        return ParsePosition;
    }());
    /**
     * Non-enumerable source string
     */
    ParsePosition.prototype.content = css;
    /**
     * Error `msg`.
     */
    var diagnostics = [];
    function error(msg) {
        if (!srcLines) {
            srcLines = css.split('\n');
        }
        var d = {
            level: 'error',
            type: 'css',
            language: 'css',
            header: 'CSS Parse',
            messageText: msg,
            absFilePath: filePath,
            lines: [{
                    lineIndex: lineno - 1,
                    lineNumber: lineno,
                    errorCharStart: column,
                    text: css[lineno - 1],
                }]
        };
        d.header = formatHeader('CSS', filePath, config.rootDir, lineno);
        if (lineno > 1) {
            var previousLine = {
                lineIndex: lineno - 1,
                lineNumber: lineno - 1,
                text: css[lineno - 2],
                errorCharStart: -1,
                errorLength: -1
            };
            d.lines.unshift(previousLine);
        }
        if (lineno + 2 < srcLines.length) {
            var nextLine = {
                lineIndex: lineno,
                lineNumber: lineno + 1,
                text: srcLines[lineno],
                errorCharStart: -1,
                errorLength: -1
            };
            d.lines.push(nextLine);
        }
        diagnostics.push(d);
    }
    /**
     * Parse stylesheet.
     */
    function stylesheet() {
        var rulesList = rules();
        return {
            type: 'stylesheet',
            stylesheet: {
                source: filePath,
                rules: rulesList,
                diagnostics: diagnostics
            }
        };
    }
    /**
     * Opening brace.
     */
    function open() {
        return match(/^{\s*/);
    }
    /**
     * Closing brace.
     */
    function close() {
        return match(/^}/);
    }
    /**
     * Parse ruleset.
     */
    function rules() {
        var node;
        var rules = [];
        whitespace();
        comments(rules);
        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
            if (node !== false) {
                rules.push(node);
                comments(rules);
            }
        }
        return rules;
    }
    /**
     * Match `re` and return captures.
     */
    function match(re) {
        var m = re.exec(css);
        if (!m)
            return;
        var str = m[0];
        updatePosition(str);
        css = css.slice(str.length);
        return m;
    }
    /**
     * Parse whitespace.
     */
    function whitespace() {
        match(/^\s*/);
    }
    /**
     * Parse comments;
     */
    function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment()) {
            if (c !== false) {
                rules.push(c);
            }
        }
        return rules;
    }
    /**
     * Parse comment.
     */
    function comment() {
        var pos = position();
        if ('/' !== css.charAt(0) || '*' !== css.charAt(1))
            return;
        var i = 2;
        while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1)))
            ++i;
        i += 2;
        if ('' === css.charAt(i - 1)) {
            return error('End of comment missing');
        }
        var str = css.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        css = css.slice(i);
        column += 2;
        return pos({
            type: 'comment',
            comment: str
        });
    }
    /**
     * Parse selector.
     */
    function selector() {
        var m = match(/^([^{]+)/);
        if (!m)
            return;
        /* @fix Remove all comments from selectors
         * http://ostermiller.org/findcomment.html */
        return trim(m[0])
            .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
            .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (m) {
            return m.replace(/,/g, '\u200C');
        })
            .split(/\s*(?![^(]*\)),\s*/)
            .map(function (s) {
            return s.replace(/\u200C/g, ',');
        });
    }
    /**
     * Parse declaration.
     */
    function declaration() {
        var pos = position();
        // prop
        var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
        if (!prop)
            return;
        prop = trim(prop[0]);
        // :
        if (!match(/^:\s*/))
            return error("property missing ':'");
        // val
        var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
        var ret = pos({
            type: 'declaration',
            property: prop.replace(commentre, ''),
            value: val ? trim(val[0]).replace(commentre, '') : ''
        });
        // ;
        match(/^[;\s]*/);
        return ret;
    }
    /**
     * Parse declarations.
     */
    function declarations() {
        var decls = [];
        if (!open())
            return error("missing '{'");
        comments(decls);
        // declarations
        var decl;
        while (decl = declaration()) {
            if (decl !== false) {
                decls.push(decl);
                comments(decls);
            }
        }
        if (!close())
            return error("missing '}'");
        return decls;
    }
    /**
     * Parse keyframe.
     */
    function keyframe() {
        var m;
        var vals = [];
        var pos = position();
        while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
            vals.push(m[1]);
            match(/^,\s*/);
        }
        if (!vals.length)
            return;
        return pos({
            type: 'keyframe',
            values: vals,
            declarations: declarations()
        });
    }
    /**
     * Parse keyframes.
     */
    function atkeyframes() {
        var pos = position();
        var m = match(/^@([-\w]+)?keyframes\s*/);
        if (!m)
            return;
        var vendor = m[1];
        // identifier
        m = match(/^([-\w]+)\s*/);
        if (!m)
            return error("@keyframes missing name");
        var name = m[1];
        if (!open())
            return error("@keyframes missing '{'");
        var frame;
        var frames = comments();
        while (frame = keyframe()) {
            frames.push(frame);
            frames = frames.concat(comments());
        }
        if (!close())
            return error("@keyframes missing '}'");
        return pos({
            type: 'keyframes',
            name: name,
            vendor: vendor,
            keyframes: frames
        });
    }
    /**
     * Parse supports.
     */
    function atsupports() {
        var pos = position();
        var m = match(/^@supports *([^{]+)/);
        if (!m)
            return;
        var supports = trim(m[1]);
        if (!open())
            return error("@supports missing '{'");
        var style = comments().concat(rules());
        if (!close())
            return error("@supports missing '}'");
        return pos({
            type: 'supports',
            supports: supports,
            rules: style
        });
    }
    /**
     * Parse host.
     */
    function athost() {
        var pos = position();
        var m = match(/^@host\s*/);
        if (!m)
            return;
        if (!open())
            return error("@host missing '{'");
        var style = comments().concat(rules());
        if (!close())
            return error("@host missing '}'");
        return pos({
            type: 'host',
            rules: style
        });
    }
    /**
     * Parse media.
     */
    function atmedia() {
        var pos = position();
        var m = match(/^@media *([^{]+)/);
        if (!m)
            return;
        var media = trim(m[1]);
        if (!open())
            return error("@media missing '{'");
        var style = comments().concat(rules());
        if (!close())
            return error("@media missing '}'");
        return pos({
            type: 'media',
            media: media,
            rules: style
        });
    }
    /**
     * Parse custom-media.
     */
    function atcustommedia() {
        var pos = position();
        var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
        if (!m)
            return;
        return pos({
            type: 'custom-media',
            name: trim(m[1]),
            media: trim(m[2])
        });
    }
    /**
     * Parse paged media.
     */
    function atpage() {
        var pos = position();
        var m = match(/^@page */);
        if (!m)
            return;
        var sel = selector() || [];
        if (!open())
            return error("@page missing '{'");
        var decls = comments();
        // declarations
        var decl;
        while (decl = declaration()) {
            decls.push(decl);
            decls = decls.concat(comments());
        }
        if (!close())
            return error("@page missing '}'");
        return pos({
            type: 'page',
            selectors: sel,
            declarations: decls
        });
    }
    /**
     * Parse document.
     */
    function atdocument() {
        var pos = position();
        var m = match(/^@([-\w]+)?document *([^{]+)/);
        if (!m)
            return;
        var vendor = trim(m[1]);
        var doc = trim(m[2]);
        if (!open())
            return error("@document missing '{'");
        var style = comments().concat(rules());
        if (!close())
            return error("@document missing '}'");
        return pos({
            type: 'document',
            document: doc,
            vendor: vendor,
            rules: style
        });
    }
    /**
     * Parse font-face.
     */
    function atfontface() {
        var pos = position();
        var m = match(/^@font-face\s*/);
        if (!m)
            return;
        if (!open())
            return error("@font-face missing '{'");
        var decls = comments();
        // declarations
        var decl;
        while (decl = declaration()) {
            decls.push(decl);
            decls = decls.concat(comments());
        }
        if (!close())
            return error("@font-face missing '}'");
        return pos({
            type: 'font-face',
            declarations: decls
        });
    }
    /**
     * Parse import
     */
    var atimport = _compileAtrule('import');
    /**
     * Parse charset
     */
    var atcharset = _compileAtrule('charset');
    /**
     * Parse namespace
     */
    var atnamespace = _compileAtrule('namespace');
    /**
     * Parse non-block at-rules
     */
    function _compileAtrule(name) {
        var re = new RegExp('^@' + name + '\\s*([^;]+);');
        return function () {
            var pos = position();
            var m = match(re);
            if (!m)
                return;
            var ret = { type: name };
            ret[name] = m[1].trim();
            return pos(ret);
        };
    }
    /**
     * Parse at rule.
     */
    function atrule() {
        if (css[0] !== '@')
            return;
        return atkeyframes()
            || atmedia()
            || atcustommedia()
            || atsupports()
            || atimport()
            || atcharset()
            || atnamespace()
            || atdocument()
            || atpage()
            || athost()
            || atfontface();
    }
    /**
     * Parse rule.
     */
    function rule() {
        var pos = position();
        var sel = selector();
        if (!sel)
            return error('selector missing');
        comments();
        return pos({
            type: 'rule',
            selectors: sel,
            declarations: declarations()
        });
    }
    return addParent(stylesheet());
}
/**
 * Trim `str`.
 */
function trim(str) {
    return str ? str.trim() : '';
}
/**
 * Adds non-enumerable parent node reference to each node.
 */
function addParent(obj, parent) {
    var isNode = obj && typeof obj.type === 'string';
    var childParent = isNode ? obj : parent;
    for (var k in obj) {
        var value = obj[k];
        if (Array.isArray(value)) {
            value.forEach(function (v) { addParent(v, childParent); });
        }
        else if (value && typeof value === 'object') {
            addParent(value, childParent);
        }
    }
    if (isNode) {
        Object.defineProperty(obj, 'parent', {
            configurable: true,
            writable: true,
            enumerable: false,
            value: parent || null
        });
    }
    return obj;
}

function getSelectors(sel) {
    // reusing global SELECTORS since this is a synchronous operation
    SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
    sel = sel.replace(/\./g, ' .')
        .replace(/\#/g, ' #')
        .replace(/\[/g, ' [')
        .replace(/\>/g, ' > ')
        .replace(/\+/g, ' + ')
        .replace(/\~/g, ' ~ ')
        .replace(/\*/g, ' * ')
        .replace(/\:not\((.*?)\)/g, ' ');
    var items = sel.split(' ');
    for (var i = 0; i < items.length; i++) {
        items[i] = items[i].split(':')[0];
        if (items[i].length === 0)
            continue;
        if (items[i].charAt(0) === '.') {
            SELECTORS.classNames.push(items[i].substr(1));
        }
        else if (items[i].charAt(0) === '#') {
            SELECTORS.ids.push(items[i].substr(1));
        }
        else if (items[i].charAt(0) === '[') {
            items[i] = items[i].substr(1).split('=')[0].split(']')[0].trim();
            SELECTORS.attrs.push(items[i].toLowerCase());
        }
        else if (/[a-z]/g.test(items[i].charAt(0))) {
            SELECTORS.tags.push(items[i].toLowerCase());
        }
    }
    SELECTORS.classNames = SELECTORS.classNames.sort(function (a, b) {
        if (a.length < b.length)
            return -1;
        if (a.length > b.length)
            return 1;
        return 0;
    });
    return SELECTORS;
}
var SELECTORS = {
    all: [],
    tags: [],
    classNames: [],
    ids: [],
    attrs: []
};

/**
 * CSS stringify adopted from rework/css by
 * TJ Holowaychuk (@tj)
 * Licensed under the MIT License
 * https://github.com/reworkcss/css/blob/master/LICENSE
 */
var StringifyCss = /** @class */ (function () {
    function StringifyCss(opts) {
        this.usedSelectors = opts.usedSelectors;
    }
    /**
     * Visit `node`.
     */
    StringifyCss.prototype.visit = function (node) {
        return this[node.type](node);
    };
    /**
     * Map visit over array of `nodes`, optionally using a `delim`
     */
    StringifyCss.prototype.mapVisit = function (nodes, delim) {
        var buf = '';
        delim = delim || '';
        for (var i = 0, length = nodes.length; i < length; i++) {
            buf += this.visit(nodes[i]);
            if (delim && i < length - 1)
                buf += delim;
        }
        return buf;
    };
    /**
     * Compile `node`.
     */
    StringifyCss.prototype.compile = function (node) {
        return node.stylesheet
            .rules.map(this.visit, this)
            .join('');
    };
    StringifyCss.prototype.comment = function () {
        return '';
    };
    /**
     * Visit import node.
     */
    StringifyCss.prototype.import = function (node) {
        return '@import ' + node.import + ';';
    };
    /**
     * Visit media node.
     */
    StringifyCss.prototype.media = function (node) {
        var mediaCss = this.mapVisit(node.rules);
        if (mediaCss === '') {
            return '';
        }
        return '@media ' + node.media + '{' + this.mapVisit(node.rules) + '}';
    };
    /**
     * Visit document node.
     */
    StringifyCss.prototype.document = function (node) {
        var documentCss = this.mapVisit(node.rules);
        if (documentCss === '') {
            return '';
        }
        var doc = '@' + (node.vendor || '') + 'document ' + node.document;
        return doc + '{' + documentCss + '}';
    };
    /**
     * Visit charset node.
     */
    StringifyCss.prototype.charset = function (node) {
        return '@charset ' + node.charset + ';';
    };
    /**
     * Visit namespace node.
     */
    StringifyCss.prototype.namespace = function (node) {
        return '@namespace ' + node.namespace + ';';
    };
    /**
     * Visit supports node.
     */
    StringifyCss.prototype.supports = function (node) {
        var supportsCss = this.mapVisit(node.rules);
        if (supportsCss === '') {
            return '';
        }
        return '@supports ' + node.supports + '{' + supportsCss + '}';
    };
    /**
     * Visit keyframes node.
     */
    StringifyCss.prototype.keyframes = function (node) {
        var keyframesCss = this.mapVisit(node.keyframes);
        if (keyframesCss === '') {
            return '';
        }
        return '@' + (node.vendor || '') + 'keyframes ' + node.name + '{' + keyframesCss + '}';
    };
    /**
     * Visit keyframe node.
     */
    StringifyCss.prototype.keyframe = function (node) {
        var decls = node.declarations;
        return node.values.join(',') + '{' + this.mapVisit(decls) + '}';
    };
    /**
     * Visit page node.
     */
    StringifyCss.prototype.page = function (node) {
        var sel = node.selectors.length
            ? node.selectors.join(', ')
            : '';
        return '@page ' + sel + '{' + this.mapVisit(node.declarations) + '}';
    };
    /**
     * Visit font-face node.
     */
    StringifyCss.prototype['font-face'] = function (node) {
        var fontCss = this.mapVisit(node.declarations);
        if (fontCss === '') {
            return '';
        }
        return '@font-face{' + fontCss + '}';
    };
    /**
     * Visit host node.
     */
    StringifyCss.prototype.host = function (node) {
        return '@host{' + this.mapVisit(node.rules) + '}';
    };
    /**
     * Visit custom-media node.
     */
    StringifyCss.prototype['custom-media'] = function (node) {
        return '@custom-media ' + node.name + ' ' + node.media + ';';
    };
    /**
     * Visit rule node.
     */
    StringifyCss.prototype.rule = function (node) {
        var decls = node.declarations;
        if (!decls.length)
            return '';
        var i, j;
        for (i = node.selectors.length - 1; i >= 0; i--) {
            var sel = getSelectors(node.selectors[i]);
            if (this.usedSelectors) {
                var include = true;
                // classes
                var jlen = sel.classNames.length;
                if (jlen > 0) {
                    for (j = 0; j < jlen; j++) {
                        if (this.usedSelectors.classNames.indexOf(sel.classNames[j]) === -1) {
                            include = false;
                            break;
                        }
                    }
                }
                // tags
                if (include) {
                    jlen = sel.tags.length;
                    if (jlen > 0) {
                        for (j = 0; j < jlen; j++) {
                            if (this.usedSelectors.tags.indexOf(sel.tags[j]) === -1) {
                                include = false;
                                break;
                            }
                        }
                    }
                }
                // attrs
                if (include) {
                    jlen = sel.attrs.length;
                    if (jlen > 0) {
                        for (j = 0; j < jlen; j++) {
                            if (this.usedSelectors.attrs.indexOf(sel.attrs[j]) === -1) {
                                include = false;
                                break;
                            }
                        }
                    }
                }
                // ids
                if (include) {
                    jlen = sel.ids.length;
                    if (jlen > 0) {
                        for (j = 0; j < jlen; j++) {
                            if (this.usedSelectors.ids.indexOf(sel.ids[j]) === -1) {
                                include = false;
                                break;
                            }
                        }
                    }
                }
                if (!include) {
                    node.selectors.splice(i, 1);
                }
            }
        }
        if (node.selectors.length === 0)
            return '';
        return node.selectors + "{" + this.mapVisit(decls) + "}";
    };
    /**
     * Visit declaration node.
     */
    StringifyCss.prototype.declaration = function (node) {
        return node.property + ':' + node.value + ';';
    };
    return StringifyCss;
}());

function removeUnusedStyles(config, usedSelectors, cssContent, cssFilePath, diagnostics) {
    var cleanedCss = cssContent;
    try {
        // parse the css from being applied to the document
        var cssAst = parseCss(config, cssContent, cssFilePath);
        if (cssAst.stylesheet.diagnostics.length) {
            cssAst.stylesheet.diagnostics.forEach(function (d) {
                diagnostics.push(d);
            });
            return cleanedCss;
        }
        try {
            // convert the parsed css back into a string
            // but only keeping what was found in our active selectors
            var stringify = new StringifyCss({ usedSelectors: usedSelectors });
            cleanedCss = stringify.compile(cssAst);
        }
        catch (e) {
            diagnostics.push({
                level: 'error',
                type: 'css',
                header: 'CSS Stringify',
                messageText: e
            });
        }
    }
    catch (e) {
        diagnostics.push({
            level: 'error',
            type: 'css',
            absFilePath: cssFilePath,
            header: 'CSS Parse',
            messageText: e
        });
    }
    return cleanedCss;
}

var UsedSelectors = /** @class */ (function () {
    function UsedSelectors(elm) {
        this.tags = [];
        this.classNames = [];
        this.ids = [];
        this.attrs = [];
        this.collectSelectors(elm);
    }
    UsedSelectors.prototype.collectSelectors = function (elm) {
        var i;
        if (elm && elm.tagName) {
            // tags
            var tagName = elm.tagName.toLowerCase();
            if (this.tags.indexOf(tagName) === -1) {
                this.tags.push(tagName);
            }
            // classes
            var classList = elm.classList;
            for (i = 0; i < classList.length; i++) {
                var className = classList[i];
                if (this.classNames.indexOf(className) === -1) {
                    this.classNames.push(className);
                }
            }
            // attributes
            var attributes = elm.attributes;
            for (i = 0; i < attributes.length; i++) {
                var attr = attributes[i];
                var attrName = attr.name.toLowerCase();
                if (!attrName || attrName === 'class' || attrName === 'id' || attrName === 'style')
                    continue;
                if (this.attrs.indexOf(attrName) === -1) {
                    this.attrs.push(attrName);
                }
            }
            // ids
            var idValue = elm.getAttribute('id');
            if (idValue) {
                idValue = idValue.trim();
                if (idValue && this.ids.indexOf(idValue) === -1) {
                    this.ids.push(idValue);
                }
            }
            // drill down
            for (i = 0; i < elm.children.length; i++) {
                this.collectSelectors(elm.children[i]);
            }
        }
    };
    return UsedSelectors;
}());

function inlineStyles(config, doc, stylesMap, opts, diagnostics) {
    var styleFileNames = Object.keys(stylesMap);
    if (!styleFileNames.length) {
        return;
    }
    var styles = [];
    if (opts.removeUnusedStyles !== false) {
        // removeUnusedStyles is the default
        try {
            // pick out all of the selectors that are actually
            // being used in the html document
            var usedSelectors_1 = new UsedSelectors(doc.documentElement);
            var cssFilePaths = Object.keys(stylesMap);
            styles = cssFilePaths.map(function (styleTag) {
                return removeUnusedStyles(config, usedSelectors_1, stylesMap[styleTag], styleTag, diagnostics);
            });
        }
        catch (e) {
            diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'HTML Selector Parse',
                messageText: e
            });
        }
    }
    else {
        // do not removeUnusedStyles
        styles = styleFileNames.map(function (styleFileName) { return stylesMap[styleFileName]; });
    }
    // insert our styles to the head of the document
    insertStyles(doc, styles);
}
function insertStyles(doc, styles) {
    if (!styles.length) {
        return;
    }
    var styleElm = doc.createElement('style');
    styleElm.setAttribute('data-styles', '');
    styleElm.innerHTML = styles.join('').trim();
    if (styleElm.innerHTML.length) {
        doc.head.insertBefore(styleElm, doc.head.firstChild);
    }
}

function insertCanonicalLink(config, doc, url) {
    if (!url)
        return;
    // https://webmasters.googleblog.com/2009/02/specify-your-canonical.html
    // <link rel="canonical" href="http://www.example.com/product.php?item=swedish-fish" />
    var canonicalLink = doc.querySelector('link[rel="canonical"]');
    if (canonicalLink)
        return;
    var parsedUrl = config.sys.url.parse(url);
    canonicalLink = doc.createElement('link');
    canonicalLink.setAttribute('rel', 'canonical');
    canonicalLink.setAttribute('href', parsedUrl.path);
    doc.head.appendChild(canonicalLink);
}

function optimizeHtml(config, ctx, doc, stylesMap, opts, results) {
    setHtmlDataSsrAttr(doc);
    if (opts.canonicalLink !== false) {
        try {
            insertCanonicalLink(config, doc, results.url);
        }
        catch (e) {
            results.diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'Insert Canonical Link',
                messageText: e
            });
        }
    }
    if (opts.inlineStyles !== false) {
        try {
            inlineStyles(config, doc, stylesMap, opts, results.diagnostics);
        }
        catch (e) {
            results.diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'Inline Styles',
                messageText: e
            });
        }
    }
    if (opts.inlineLoaderScript !== false) {
        // remove the script to the external loader script request
        // inline the loader script at the bottom of the html
        try {
            inlineLoaderScript(config, ctx, doc);
        }
        catch (e) {
            results.diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'Inline Loader Script',
                messageText: e
            });
        }
    }
    if (opts.collapseWhitespace !== false && !config.devMode) {
        // collapseWhitespace is the default
        try {
            collapseHtmlWhitepace(doc.documentElement);
        }
        catch (e) {
            results.diagnostics.push({
                level: 'error',
                type: 'hydrate',
                header: 'Reduce HTML Whitespace',
                messageText: e
            });
        }
    }
}
function setHtmlDataSsrAttr(doc) {
    doc.documentElement.setAttribute('data-ssr', '');
}

function hydrateHtml(config, ctx, registry, opts) {
    return new Promise(function (resolve) {
        var hydrateResults = {
            diagnostics: [],
            url: opts.url,
            html: opts.html,
            styles: null,
            anchors: []
        };
        var registeredTags = Object.keys(registry || {});
        var ssrIds = 0;
        // if there are no components registered at all
        // then let's skip all this (and why didn't we get components!?)
        if (registeredTags.length === 0) {
            hydrateResults.diagnostics.push({
                header: 'Hydrate Components',
                messageText: "No registered components found",
                type: 'hydrate',
                level: 'info'
            });
            hydrateResults.html = opts.html;
            resolve(hydrateResults);
            return;
        }
        // create a emulated window
        // attach data the request to the window
        var dom = config.sys.createDom();
        var win = dom.parse(opts);
        var doc = win.document;
        var domApi = createDomApi(win, doc);
        // normalize dir and lang before connecting elements
        // so that the info is their incase they read it at runtime
        normalizeDirection(doc, opts);
        normalizeLanguage(doc, opts);
        // create the platform
        var plt = createPlatformServer(config, win, doc, domApi, hydrateResults.diagnostics, opts.isPrerender, ctx);
        // fully define each of our components onto this new platform instance
        registeredTags.forEach(function (registryTag) {
            registryTag = registryTag.toLowerCase();
            registry[registryTag].tagNameMeta = registryTag;
            registry[registryTag].membersMeta = registry[registryTag].membersMeta || {};
            plt.defineComponent(registry[registryTag]);
        });
        // fire off this function when the app has finished loading
        // and all components have finished hydrating
        plt.onAppLoad = function (rootElm, stylesMap, failureDiagnostic) {
            if (config._isTesting) {
                hydrateResults.__testPlatform = plt;
            }
            if (failureDiagnostic) {
                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);
                resolve(hydrateResults);
                return;
            }
            hydrateResults.root = rootElm;
            // all synchronous operations next
            if (rootElm) {
                try {
                    // optimize this document!!
                    optimizeHtml(config, ctx, doc, stylesMap, opts, hydrateResults);
                    // gather up all of the <a> tag information in the doc
                    if (opts.collectAnchors !== false) {
                        collectAnchors(doc, hydrateResults);
                    }
                    // serialize this dom back into a string
                    if (opts.serializeHtml !== false) {
                        hydrateResults.html = dom.serialize();
                    }
                    // also collect up any dom errors that may have happened
                    hydrateResults.diagnostics = hydrateResults.diagnostics.concat(dom.getDiagnostics());
                }
                catch (e) {
                    // gahh, something's up
                    hydrateResults.diagnostics.push({
                        level: 'error',
                        type: 'hydrate',
                        header: 'DOM Serialize',
                        messageText: e
                    });
                    // idk, some error, just use the original html
                    hydrateResults.html = opts.html;
                }
            }
            // cool, all good here, even if there are errors
            // we're passing back the result object
            resolve(hydrateResults);
        };
        // keep a collection of all the host elements we connected
        var connectedInfo = {
            elementCount: 0
        };
        // patch the render function that we can add SSR ids
        // and to connect any elements it may have just appened to the DOM
        var pltRender = plt.render;
        plt.render = function render(oldVNode, newVNode, isUpdate, hostContentNodes, encapsulation) {
            var ssrId;
            var existingSsrId;
            if (opts.ssrIds !== false) {
                // this may have been patched more than once
                // so reuse the ssr id if it already has one
                if (oldVNode && oldVNode.elm) {
                    existingSsrId = oldVNode.elm.getAttribute(SSR_VNODE_ID);
                }
                if (existingSsrId) {
                    ssrId = parseInt(existingSsrId, 10);
                }
                else {
                    ssrId = ssrIds++;
                }
            }
            newVNode = pltRender(oldVNode, newVNode, isUpdate, hostContentNodes, encapsulation, ssrId);
            connectElement(plt, newVNode.elm, connectedInfo, config.hydratedCssClass);
            return newVNode;
        };
        // loop through each node and start connecting/hydrating
        // any elements that are host elements to components
        // this kicks off all the async loading and hydrating
        connectElement(plt, win.document.body, connectedInfo, config.hydratedCssClass);
        if (connectedInfo.elementCount === 0) {
            // what gives, never found ANY host elements to connect!
            // ok we're just done i guess, idk
            hydrateResults.html = opts.html;
            resolve(hydrateResults);
        }
    });
}
function connectElement(plt, elm, connectedInfo, hydratedCssClass) {
    if (!elm.$connected) {
        // only connect elements which is a registered component
        var cmpMeta = plt.getComponentMeta(elm);
        if (cmpMeta && cmpMeta.encapsulation !== 1 /* ShadowDom */) {
            elm.$initLoad = function () {
                initLoad(plt, elm, hydratedCssClass);
            };
            proxyHostElementPrototype(plt, cmpMeta.membersMeta, elm);
            connectedCallback(plt, cmpMeta, elm);
            // keep count of how many host elements we actually connected
            connectedInfo.elementCount++;
        }
    }
    var elmChildren = elm.children;
    if (elmChildren) {
        // continue drilling down through child elements
        for (var i = 0, l = elmChildren.length; i < l; i++) {
            connectElement(plt, elmChildren[i], connectedInfo, hydratedCssClass);
        }
    }
}
function collectAnchors(doc, hydrateResults) {
    var anchorElements = doc.querySelectorAll('a');
    for (var i = 0; i < anchorElements.length; i++) {
        var attrs = {};
        var anchorAttrs = anchorElements[i].attributes;
        for (var j = 0; j < anchorAttrs.length; j++) {
            attrs[anchorAttrs[j].nodeName.toLowerCase()] = anchorAttrs[j].nodeValue;
        }
        hydrateResults.anchors.push(attrs);
    }
}
function normalizeDirection(doc, opts) {
    var dir = doc.body.getAttribute('dir');
    if (dir) {
        dir = dir.trim().toLowerCase();
        if (dir.trim().length > 0) {
            console.warn("dir=\"" + dir + "\" should be placed on the <html> instead of <body>");
        }
    }
    if (opts.dir) {
        dir = opts.dir;
    }
    else {
        dir = doc.documentElement.getAttribute('dir');
    }
    if (dir) {
        dir = dir.trim().toLowerCase();
        if (dir !== 'ltr' && dir !== 'rtl') {
            console.warn("only \"ltr\" and \"rtl\" are valid \"dir\" values on the <html> element");
        }
    }
    if (dir !== 'ltr' && dir !== 'rtl') {
        dir = 'ltr';
    }
    doc.documentElement.dir = dir;
}
function normalizeLanguage(doc, opts) {
    var lang = doc.body.getAttribute('lang');
    if (lang) {
        lang = lang.trim().toLowerCase();
        if (lang.trim().length > 0) {
            console.warn("lang=\"" + lang + "\" should be placed on <html> instead of <body>");
        }
    }
    if (opts.lang) {
        lang = opts.lang;
    }
    else {
        lang = doc.documentElement.getAttribute('lang');
    }
    if (lang) {
        lang = lang.trim().toLowerCase();
        if (lang.length > 0) {
            doc.documentElement.lang = lang;
        }
    }
}
function generateFailureDiagnostic(d) {
    return "\n    <div style=\"padding: 20px;\">\n      <div style=\"font-weight: bold;\">" + d.header + "</div>\n      <div>" + d.messageText + "</div>\n    </div>\n  ";
}

function validateBuildConfig(config, setEnvVariables) {
    if (!config) {
        throw new Error("invalid build config");
    }
    if (config._isValidated) {
        // don't bother if we've already validated this config
        return config;
    }
    if (!config.logger) {
        throw new Error("config.logger required");
    }
    if (!config.rootDir) {
        throw new Error('config.rootDir required');
    }
    if (!config.sys) {
        throw new Error('config.sys required');
    }
    if (typeof config.namespace !== 'string') {
        config.namespace = DEFAULT_NAMESPACE;
    }
    config.namespace = validateNamespace(config.namespace);
    var path = config.sys.path;
    if (typeof config.global === 'string' && !path.isAbsolute(config.global)) {
        config.global = normalizePath(path.join(config.rootDir, config.global));
    }
    if (typeof config.src === 'string') {
        // deprecated: 2017-08-14
        console.warn("stencil config property \"src\" has been renamed to \"srcDir\"");
        config.srcDir = config.src;
    }
    if (typeof config.srcDir !== 'string') {
        config.srcDir = DEFAULT_SRC_DIR;
    }
    if (!path.isAbsolute(config.srcDir)) {
        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));
    }
    if (typeof config.wwwDir !== 'string') {
        config.wwwDir = DEFAULT_WWW_DIR;
    }
    if (!path.isAbsolute(config.wwwDir)) {
        config.wwwDir = normalizePath(path.join(config.rootDir, config.wwwDir));
    }
    if (typeof config.buildDir !== 'string') {
        config.buildDir = DEFAULT_BUILD_DIR;
    }
    if (!path.isAbsolute(config.buildDir)) {
        config.buildDir = normalizePath(path.join(config.wwwDir, config.buildDir));
    }
    if (typeof config.distDir !== 'string') {
        config.distDir = DEFAULT_DIST_DIR;
    }
    if (!path.isAbsolute(config.distDir)) {
        config.distDir = normalizePath(path.join(config.rootDir, config.distDir));
    }
    if (typeof config.collectionDir !== 'string') {
        config.collectionDir = DEFAULT_COLLECTION_DIR;
    }
    if (!path.isAbsolute(config.collectionDir)) {
        config.collectionDir = normalizePath(path.join(config.distDir, config.collectionDir));
    }
    if (typeof config.srcIndexHtml !== 'string') {
        config.srcIndexHtml = normalizePath(path.join(config.srcDir, DEFAULT_INDEX_HTML));
    }
    if (!path.isAbsolute(config.srcIndexHtml)) {
        config.srcIndexHtml = normalizePath(path.join(config.rootDir, config.srcIndexHtml));
    }
    if (typeof config.wwwIndexHtml !== 'string') {
        config.wwwIndexHtml = normalizePath(path.join(config.wwwDir, DEFAULT_INDEX_HTML));
    }
    if (!path.isAbsolute(config.wwwIndexHtml)) {
        config.wwwIndexHtml = normalizePath(path.join(config.rootDir, config.wwwDir));
    }
    if (typeof config.publicPath !== 'string') {
        // CLIENT SIDE ONLY! Do not use this for server-side file read/writes
        // this is a reference to the public static directory from the index.html running from a browser
        // in most cases it's just "build", as in index page would request scripts from `/build/`
        config.publicPath = normalizePath(path.relative(config.wwwDir, config.buildDir));
        if (config.publicPath.charAt(0) !== '/') {
            // ensure prefix / by default
            config.publicPath = '/' + config.publicPath;
        }
    }
    if (config.publicPath.charAt(config.publicPath.length - 1) !== '/') {
        // ensure there's a trailing /
        config.publicPath += '/';
    }
    // default devMode false
    config.devMode = !!config.devMode;
    // default watch false
    config.watch = !!config.watch;
    if (typeof config.minifyCss !== 'boolean') {
        // if no config, minify css when it's the prod build
        config.minifyCss = (!config.devMode);
    }
    config.logger.debug("minifyCss: " + config.minifyCss);
    if (typeof config.minifyJs !== 'boolean') {
        // if no config, minify js when it's the prod build
        config.minifyJs = (!config.devMode);
    }
    config.logger.debug("minifyJs: " + config.minifyJs);
    if (typeof config.hashFileNames !== 'boolean' && typeof config.hashFilenames === 'boolean') {
        config.hashFileNames = config.hashFilenames;
        config.logger.warn("\"hashFilenames\" was used in the config, did you mean \"hashFileNames\"? (Has a capital N)");
    }
    if (typeof config.hashFileNames !== 'boolean') {
        // hashFileNames config was not provided, so let's create the default
        if (config.devMode || config.watch) {
            // dev mode should not hash filenames
            // during watch rebuilds it should not hash filenames
            config.hashFileNames = false;
        }
        else {
            // prod builds should hash filenames
            config.hashFileNames = true;
        }
    }
    config.logger.debug("hashFileNames: " + config.hashFileNames);
    if (typeof config.hashedFileNameLength !== 'number') {
        config.hashedFileNameLength = DEFAULT_HASHED_FILENAME_LENTH;
    }
    if (config.hashFileNames) {
        if (config.hashedFileNameLength < 4) {
            throw new Error("config.hashedFileNameLength must be at least 4 characters");
        }
    }
    config.logger.debug("hashedFileNameLength: " + config.hashedFileNameLength);
    config.generateDistribution = !!config.generateDistribution;
    if (typeof config.generateWWW !== 'boolean') {
        config.generateWWW = true;
    }
    if (config.copy) {
        // merge user copy tasks into the default
        config.copy = Object.assign({}, DEFAULT_COPY_TASKS, config.copy);
    }
    else if (config.copy === null || config.copy === false) {
        // manually forcing to skip the copy task
        config.copy = null;
    }
    else {
        // use the default copy tasks
        config.copy = Object.assign({}, DEFAULT_COPY_TASKS);
    }
    if (!config.watchIgnoredRegex) {
        config.watchIgnoredRegex = DEFAULT_WATCH_IGNORED_REGEX;
    }
    if (typeof config.hydratedCssClass !== 'string') {
        config.hydratedCssClass = DEFAULT_HYDRATED_CSS_CLASS;
    }
    if (typeof config.es5Fallback !== 'boolean') {
        if (config.devMode) {
            // default dev mode only builds es2015
            config.es5Fallback = false;
        }
        else {
            // default prod mode builds both es2015 and es5
            config.es5Fallback = true;
        }
    }
    config.emptyDist = !!config.emptyDist;
    config.emptyWWW = !!config.emptyWWW;
    config.collections = config.collections || [];
    config.collections = config.collections.map(validateDependentCollection);
    config.bundles = config.bundles || [];
    validateUserBundles(config.bundles);
    config.exclude = config.exclude || DEFAULT_EXCLUDES;
    // set to true so it doesn't bother going through all this again on rebuilds
    config._isValidated = true;
    config.logger.debug("validated build config");
    if (setEnvVariables !== false) {
        setProcessEnvironment(config);
    }
    return config;
}
function validateNamespace(namespace) {
    namespace = namespace.trim();
    var invalidNamespaceChars = namespace.replace(/(\w)|(\-)|(\$)/g, '');
    if (invalidNamespaceChars !== '') {
        throw new Error("Namespace \"" + namespace + "\" contains invalid characters: " + invalidNamespaceChars);
    }
    if (namespace.length < 3) {
        throw new Error("Namespace \"" + namespace + "\" must be at least 3 characters");
    }
    if (/^\d+$/.test(namespace.charAt(0))) {
        throw new Error("Namespace \"" + namespace + "\" cannot have a number for the first character");
    }
    if (namespace.charAt(0) === '-') {
        throw new Error("Namespace \"" + namespace + "\" cannot have a dash for the first character");
    }
    if (namespace.charAt(namespace.length - 1) === '-') {
        throw new Error("Namespace \"" + namespace + "\" cannot have a dash for the last character");
    }
    return namespace;
}
function setProcessEnvironment(config) {
    process.env.NODE_ENV = config.devMode ? 'development' : 'production';
}
function validateDependentCollection(userInput) {
    if (!userInput || Array.isArray(userInput) || typeof userInput === 'number' || typeof userInput === 'boolean') {
        throw new Error("invalid collection: " + userInput);
    }
    var collection;
    if (typeof userInput === 'string') {
        collection = {
            name: userInput
        };
    }
    else {
        collection = userInput;
    }
    if (!collection.name || typeof collection.name !== 'string' || collection.name.trim() === '') {
        throw new Error("missing collection name");
    }
    collection.name = collection.name.trim();
    collection.includeBundledOnly = !!collection.includeBundledOnly;
    return collection;
}
function validateUserBundles(bundles) {
    if (!bundles) {
        throw new Error("Invalid bundles");
    }
    // normalize bundle component tags
    // sort by tag name and ensure they're lower case
    bundles.forEach(function (b) {
        if (!Array.isArray(b.components)) {
            throw new Error("manifest missing bundle components array, instead received: " + b.components);
        }
        b.components = b.components.filter(function (c) { return typeof c === 'string' && c.trim().length; });
        if (!b.components.length) {
            throw new Error("No valid bundle components found within stencil config");
        }
        b.components = b.components.map(function (tag) { return validateComponentTag(tag); }).sort();
    });
    bundles.sort(function (a, b) {
        if (a.components && a.components.length && b.components && b.components.length) {
            if (a.components[0].toLowerCase() < b.components[0].toLowerCase())
                return -1;
            if (a.components[0].toLowerCase() > b.components[0].toLowerCase())
                return 1;
        }
        return 0;
    });
}
function validateComponentTag(tag) {
    if (typeof tag !== 'string') {
        throw new Error("Tag \"" + tag + "\" must be a string type");
    }
    tag = tag.trim().toLowerCase();
    if (tag.length === 0) {
        throw new Error("Received empty tag value");
    }
    if (tag.indexOf(' ') > -1) {
        throw new Error("\"" + tag + "\" tag cannot contain a space");
    }
    if (tag.indexOf(',') > -1) {
        throw new Error("\"" + tag + "\" tag cannot be use for multiple tags");
    }
    var invalidChars = tag.replace(/\w|-/g, '');
    if (invalidChars !== '') {
        throw new Error("\"" + tag + "\" tag contains invalid characters: " + invalidChars);
    }
    if (tag.indexOf('-') === -1) {
        throw new Error("\"" + tag + "\" tag must contain a dash (-) to work as a valid web component");
    }
    if (tag.indexOf('--') > -1) {
        throw new Error("\"" + tag + "\" tag cannot contain multiple dashes (--) next to each other");
    }
    if (tag.indexOf('-') === 0) {
        throw new Error("\"" + tag + "\" tag cannot start with a dash (-)");
    }
    if (tag.lastIndexOf('-') === tag.length - 1) {
        throw new Error("\"" + tag + "\" tag cannot end with a dash (-)");
    }
    return tag;
}
var DEFAULT_SRC_DIR = 'src';
var DEFAULT_WWW_DIR = 'www';
var DEFAULT_BUILD_DIR = 'build';
var DEFAULT_INDEX_HTML = 'index.html';
var DEFAULT_DIST_DIR = 'dist';
var DEFAULT_COLLECTION_DIR = 'collection';
var DEFAULT_NAMESPACE = 'App';
var DEFAULT_HASHED_FILENAME_LENTH = 8;
var DEFAULT_EXCLUDES = ['node_modules', 'bower_components'];
var DEFAULT_WATCH_IGNORED_REGEX = /(\.(jpg|jpeg|png|gif|woff|woff2|ttf|eot)|(?:^|[\\\/])(\.(?!\.)[^\\\/]+)$)$/i;
var DEFAULT_HYDRATED_CSS_CLASS = 'hydrated';
var DEFAULT_COPY_TASKS = {
    assets: { src: 'assets', warn: false },
    manifestJson: { src: 'manifest.json', warn: false }
};

function createRenderer(config, registry, ctx) {
    validateBuildConfig(config);
    ctx = ctx || {};
    // init the buid context
    getBuildContext(ctx);
    // load the app global file into the context
    loadAppGlobal(config, ctx);
    if (!registry) {
        // figure out the component registry
        // if one wasn't passed in already
        registry = registerComponents(config);
    }
    // overload with two options for hydrateToString
    // one that returns a promise, and one that takes a callback as the last arg
    function hydrateToString(hydrateOpts) {
        // validate the hydrate options and add any missing info
        normalizeHydrateOptions(config, hydrateOpts);
        // kick off hydrated, which is an async opertion
        return hydrateHtml(config, ctx, registry, hydrateOpts).catch(function (err) {
            var hydrateResults = {
                diagnostics: [buildError(err)],
                html: hydrateOpts.html,
                styles: null,
                anchors: []
            };
            return hydrateResults;
        });
    }
    return {
        hydrateToString: hydrateToString
    };
}
function registerComponents(config) {
    var registry = null;
    try {
        var registryJsonFilePath = getRegistryJsonWWW(config);
        // open up the registry json file
        var cmpRegistryJson = config.sys.fs.readFileSync(registryJsonFilePath, 'utf-8');
        // parse the json into js object
        var registryData = JSON.parse(cmpRegistryJson);
        // object should have the components property on it
        var components = registryData.components;
        if (Array.isArray(components) && components.length > 0) {
            // i think we're good, let's create a registry
            // object to fill up with component data
            registry = {};
            // each component should be a LoadComponentRegistry interface
            components.forEach(function (cmpRegistryData) {
                // parse the LoadComponentRegistry data and
                // move it to the ComponentRegistry data
                parseComponentLoaders(cmpRegistryData, registry);
            });
        }
        else {
            throw new Error("No components were found within the registry data");
        }
    }
    catch (e) {
        throw new Error("Unable to open component registry: " + e);
    }
    return registry;
}
function normalizeHydrateOptions(config, opts) {
    var req = opts.req;
    if (req && typeof req.get === 'function') {
        // assuming node express request object
        // https://expressjs.com/
        if (!opts.url)
            opts.url = req.protocol + '://' + req.get('host') + req.originalUrl;
        if (!opts.referrer)
            opts.referrer = req.get('referrer');
        if (!opts.userAgent)
            opts.userAgent = req.get('user-agent');
        if (!opts.cookie)
            opts.cookie = req.get('cookie');
    }
    if (!opts.url) {
        opts.url = '/';
    }
    var urlObj = config.sys.url.parse(opts.url);
    if (!urlObj.protocol)
        urlObj.protocol = 'https:';
    if (!urlObj.hostname)
        urlObj.hostname = DEFAULT_PRERENDER_CONFIG.host;
    opts.url = config.sys.url.format(urlObj);
}
function loadAppGlobal(config, ctx) {
    ctx.appFiles = ctx.appFiles || {};
    if (ctx.appFiles.global) {
        // already loaded the global js content
        return;
    }
    // let's load the app global js content
    var appGlobalPath = getGlobalWWW(config);
    try {
        ctx.appFiles.global = config.sys.fs.readFileSync(appGlobalPath, 'utf-8');
    }
    catch (e) {
        config.logger.debug("missing app global: " + appGlobalPath);
    }
}

function createContext(ctx, wwwDir, sandbox) {
    var vm = require('vm');
    // https://github.com/tmpvar/jsdom/issues/1724
    // manually adding a fetch polyfill until jsdom adds it
    patchFetch(ctx, wwwDir, sandbox);
    patchRaf(sandbox);
    return vm.createContext(sandbox);
}
function patchFetch(ctx, wwwDir, sandbox) {
    function fetch(input, init) {
        var nodeFetch = require('node-fetch');
        createServer(ctx, wwwDir);
        if (typeof input === 'string') {
            // fetch(url)
            return nodeFetch(normalizeUrl(input), init);
        }
        else {
            // fetch(Request)
            input.url = normalizeUrl(input.url);
            return nodeFetch(input, init);
        }
    }
    sandbox.fetch = fetch;
}
function normalizeUrl(url) {
    var Url = require('url');
    var parsedUrl = Url.parse(url);
    if (!parsedUrl.protocol || !parsedUrl.hostname) {
        parsedUrl.protocol = 'http:';
        parsedUrl.host = 'localhost:' + PORT;
        url = Url.format(parsedUrl);
    }
    return url;
}
function patchRaf(sandbox) {
    if (!sandbox.requestAnimationFrame) {
        sandbox.requestAnimationFrame = function (callback) {
            var id = sandbox.setTimeout(function () {
                callback(Date.now());
            }, 0);
            return id;
        };
        sandbox.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
    }
}
function createServer(ctx, wwwDir) {
    if (ctx.localPrerenderServer)
        return;
    var fs = require('fs');
    var path = require('path');
    var http = require('http');
    var Url = require('url');
    ctx.localPrerenderServer = http.createServer(function (request, response) {
        var parsedUrl = Url.parse(request.url);
        var filePath = path.join(wwwDir, parsedUrl.pathname);
        fs.readFile(filePath, 'utf-8', function (err, data) {
            if (err) {
                response.write('Error fetching: ' + parsedUrl.pathname + ' : ' + err);
            }
            else {
                response.write(data);
            }
            response.end();
        });
    });
    ctx.localPrerenderServer.listen(PORT);
}
var PORT = 53536;
function runInContext(code, contextifiedSandbox, options) {
    var vm = require('vm');
    vm.runInContext(code, contextifiedSandbox, options);
}

function createDom() {
    var jsdom = require('jsdom');
    var virtualConsole = new jsdom.VirtualConsole();
    var dom;
    var diagnostics = [];
    virtualConsole.on('jsdomError', function () {
        diagnostics.push({
            level: 'error',
            header: 'DOM Error',
            type: 'hydrate',
            messageText: ([].slice.call(arguments)).join(' ')
        });
    });
    virtualConsole.on('error', function () {
        diagnostics.push({
            level: 'error',
            type: 'hydrate',
            messageText: ([].slice.call(arguments)).join(' ')
        });
    });
    virtualConsole.on('warn', function () {
        diagnostics.push({
            level: 'warn',
            type: 'hydrate',
            messageText: ([].slice.call(arguments)).join(' ')
        });
    });
    return {
        parse: function (opts) {
            dom = new jsdom.JSDOM(opts.html, {
                virtualConsole: virtualConsole,
                url: opts.url,
                referrer: opts.referrer,
                userAgent: opts.userAgent
            });
            return dom.window;
        },
        serialize: function () {
            return dom.serialize();
        },
        destroy: function () {
            dom.window.close();
            dom = null;
        },
        getDiagnostics: function () {
            return diagnostics;
        }
    };
}

function getNodeSys(distRootDir, logger) {
    var fs = require('fs');
    var path = require('path');
    var coreClientFileCache = {};
    function resolveModule(fromDir, moduleId) {
        var Module = require('module');
        fromDir = path.resolve(fromDir);
        var fromFile = path.join(fromDir, 'noop.js');
        var dir = Module._resolveFilename(moduleId, {
            id: fromFile,
            filename: fromFile,
            paths: Module._nodeModulePaths(fromDir)
        });
        var root = path.parse(fromDir).root;
        var packageJsonFilePath;
        while (dir !== root) {
            dir = path.dirname(dir);
            packageJsonFilePath = path.join(dir, 'package.json');
            try {
                fs.accessSync(packageJsonFilePath);
            }
            catch (e) {
                continue;
            }
            return normalizePath(packageJsonFilePath);
        }
        throw new Error("error loading \"" + moduleId + "\" from \"" + fromDir + "\"");
    }
    var packageJsonData;
    try {
        packageJsonData = require(path.join(distRootDir, 'package.json'));
    }
    catch (e) {
        throw new Error("unable to resolve \"package.json\" from: " + distRootDir);
    }
    var typescriptPackageJson;
    try {
        typescriptPackageJson = require(resolveModule(distRootDir, 'typescript'));
    }
    catch (e) {
        throw new Error("unable to resolve \"typescript\" from: " + distRootDir);
    }
    var sysUtil = require('./sys-util');
    var sys = {
        compiler: {
            name: packageJsonData.name,
            version: packageJsonData.version,
            typescriptVersion: typescriptPackageJson.version
        },
        copy: function (src, dest, opts) {
            return new Promise(function (resolve, reject) {
                opts = opts || {};
                sysUtil.fsExtra.copy(src, dest, opts, function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        },
        createDom: createDom,
        emptyDir: function (dir) {
            return new Promise(function (resolve, reject) {
                sysUtil.fsExtra.emptyDir(dir, function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        },
        ensureDir: function (dir) {
            return new Promise(function (resolve, reject) {
                sysUtil.fsExtra.ensureDir(dir, function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        },
        ensureDirSync: function (dir) {
            sysUtil.fsExtra.ensureDirSync(dir);
        },
        ensureFile: function (file) {
            return new Promise(function (resolve, reject) {
                sysUtil.fsExtra.ensureFile(file, function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        },
        fs: fs,
        generateContentHash: function (content, length) {
            var crypto = require('crypto');
            return crypto.createHash('sha1')
                .update(content)
                .digest('base64')
                .replace(/\W/g, '')
                .substr(0, length)
                .toLowerCase();
        },
        getClientCoreFile: function (opts) {
            var filePath = path.join(distRootDir, 'client', opts.staticName);
            return new Promise(function (resolve, reject) {
                if (coreClientFileCache[filePath]) {
                    resolve(coreClientFileCache[filePath]);
                }
                else {
                    fs.readFile(filePath, 'utf-8', function (err, data) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            coreClientFileCache[filePath] = data;
                            resolve(data);
                        }
                    });
                }
            });
        },
        glob: function (pattern, opts) {
            return new Promise(function (resolve, reject) {
                sysUtil.glob(pattern, opts, function (err, files) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(files);
                    }
                });
            });
        },
        loadConfigFile: function (configPath) {
            var config;
            var configFileData;
            try {
                delete require.cache[require.resolve(configPath)];
                configFileData = require(configPath);
                if (!configFileData.config) {
                    logger.error("Invalid Stencil \"" + configPath + "\" configuration file. Missing \"config\" property.");
                    return null;
                }
                config = configFileData.config;
                config.configPath = configPath;
            }
            catch (e) {
                logger.error("Error reading Stencil \"" + configPath + "\" configuration file.");
                return null;
            }
            if (!config.rootDir) {
                config.rootDir = path.dirname(configPath);
            }
            return config;
        },
        isGlob: function (str) {
            return sysUtil.isGlob(str);
        },
        minifyCss: function (input) {
            var CleanCSS = require('./clean-css').cleanCss;
            var result = new CleanCSS().minify(input);
            var diagnostics = [];
            if (result.errors) {
                result.errors.forEach(function (msg) {
                    diagnostics.push({
                        header: 'Minify CSS',
                        messageText: msg,
                        level: 'error',
                        type: 'build'
                    });
                });
            }
            if (result.warnings) {
                result.warnings.forEach(function (msg) {
                    diagnostics.push({
                        header: 'Minify CSS',
                        messageText: msg,
                        level: 'warn',
                        type: 'build'
                    });
                });
            }
            return {
                output: result.styles,
                sourceMap: result.sourceMap,
                diagnostics: diagnostics
            };
        },
        minifyJs: function (input, opts) {
            var UglifyJS = require('uglify-es');
            var result = UglifyJS.minify(input, opts);
            var diagnostics = [];
            if (result.error) {
                diagnostics.push({
                    header: 'Minify JS',
                    messageText: result.error.message,
                    level: 'error',
                    type: 'build'
                });
            }
            return {
                output: result.code,
                sourceMap: result.sourceMap,
                diagnostics: diagnostics
            };
        },
        path: path,
        remove: function (dir) {
            return new Promise(function (resolve, reject) {
                sysUtil.fsExtra.remove(dir, function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        },
        resolveModule: resolveModule,
        semver: sysUtil.semver,
        vm: {
            createContext: createContext,
            runInContext: runInContext
        },
        watch: function (paths, opts) {
            var chokidar = require('chokidar');
            return chokidar.watch(paths, opts);
        }
    };
    Object.defineProperties(sys, {
        // sys on-demand getters
        rollup: { get: function () {
                var rollup = require('rollup');
                rollup.plugins = {
                    commonjs: require('rollup-plugin-commonjs'),
                    nodeResolve: require('rollup-plugin-node-resolve')
                };
                return rollup;
            }
        },
        sass: { get: function () { return require('node-sass'); } },
        typescript: { get: function () { return require('typescript'); } },
        url: { get: function () { return require('url'); } },
        workbox: { get: function () { return require('workbox-build'); } }
    });
    return sys;
}

var NodeLogger = /** @class */ (function () {
    function NodeLogger(opts) {
        this._level = 'info';
        this.process = opts.process;
        this.level = opts.level;
        var sysUtil = require('./sys-util.js');
        this.chalk = sysUtil.chalk;
    }
    Object.defineProperty(NodeLogger.prototype, "level", {
        get: function () {
            return this._level;
        },
        set: function (l) {
            var _this = this;
            if (typeof l === 'string') {
                l = l.toLowerCase().trim();
                if (LOG_LEVELS.indexOf(l) === -1) {
                    this.error("Invalid log level '" + this.chalk.bold(l) + "' (choose from: " + LOG_LEVELS.map(function (l) { return _this.chalk.bold(l); }).join(', ') + ")");
                }
                else {
                    this._level = l;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    NodeLogger.prototype.info = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i] = arguments[_i];
        }
        if (this.shouldLog('info')) {
            var lines = wordWrap(msg);
            this.infoPrefix(lines);
            console.log(lines.join('\n'));
        }
    };
    NodeLogger.prototype.infoPrefix = function (lines) {
        if (lines.length) {
            var d = new Date();
            var prefix = '[' +
                ('0' + d.getMinutes()).slice(-2) + ':' +
                ('0' + d.getSeconds()).slice(-2) + '.' +
                Math.floor((d.getMilliseconds() / 1000) * 10) + ']';
            lines[0] = this.dim(prefix) + lines[0].substr(prefix.length);
        }
    };
    NodeLogger.prototype.warn = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i] = arguments[_i];
        }
        if (this.shouldLog('warn')) {
            var lines = wordWrap(msg);
            this.warnPrefix(lines);
            console.warn(lines.join('\n'));
        }
    };
    NodeLogger.prototype.warnPrefix = function (lines) {
        if (lines.length) {
            var prefix = '[ WARN  ]';
            lines[0] = this.bold(this.chalk.yellow(prefix)) + lines[0].substr(prefix.length);
        }
    };
    NodeLogger.prototype.error = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i] = arguments[_i];
        }
        if (this.shouldLog('error')) {
            var lines = wordWrap(msg);
            this.errorPrefix(lines);
            console.error(lines.join('\n'));
        }
    };
    NodeLogger.prototype.errorPrefix = function (lines) {
        if (lines.length) {
            var prefix = '[ ERROR ]';
            lines[0] = this.bold(this.chalk.red(prefix)) + lines[0].substr(prefix.length);
        }
    };
    NodeLogger.prototype.debug = function () {
        var msg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            msg[_i] = arguments[_i];
        }
        if (this.shouldLog('debug')) {
            msg.push(this.memoryUsage());
            var lines = wordWrap(msg);
            this.debugPrefix(lines);
            console.log(lines.join('\n'));
        }
    };
    NodeLogger.prototype.debugPrefix = function (lines) {
        if (lines.length) {
            var d = new Date();
            var prefix = '[' +
                ('0' + d.getMinutes()).slice(-2) + ':' +
                ('0' + d.getSeconds()).slice(-2) + '.' +
                Math.floor((d.getMilliseconds() / 1000) * 10) + ']';
            lines[0] = this.chalk.cyan(prefix) + lines[0].substr(prefix.length);
        }
    };
    NodeLogger.prototype.color = function (msg, color) {
        return this.chalk[color](msg);
    };
    NodeLogger.prototype.red = function (msg) {
        return this.chalk.red(msg);
    };
    NodeLogger.prototype.green = function (msg) {
        return this.chalk.green(msg);
    };
    NodeLogger.prototype.yellow = function (msg) {
        return this.chalk.yellow(msg);
    };
    NodeLogger.prototype.blue = function (msg) {
        return this.chalk.blue(msg);
    };
    NodeLogger.prototype.magenta = function (msg) {
        return this.chalk.magenta(msg);
    };
    NodeLogger.prototype.cyan = function (msg) {
        return this.chalk.cyan(msg);
    };
    NodeLogger.prototype.gray = function (msg) {
        return this.chalk.gray(msg);
    };
    NodeLogger.prototype.bold = function (msg) {
        return this.chalk.bold(msg);
    };
    NodeLogger.prototype.dim = function (msg) {
        return this.chalk.dim(msg);
    };
    NodeLogger.prototype.memoryUsage = function () {
        return this.dim(" MEM: " + (this.process.memoryUsage().rss / 1000000).toFixed(1) + "MB");
    };
    NodeLogger.prototype.shouldLog = function (level) {
        return LOG_LEVELS.indexOf(level) >= LOG_LEVELS.indexOf(this.level);
    };
    NodeLogger.prototype.createTimeSpan = function (startMsg, debug) {
        if (debug === void 0) { debug = false; }
        return new CmdTimeSpan(this, startMsg, debug);
    };
    NodeLogger.prototype.printDiagnostics = function (diagnostics) {
        var _this = this;
        if (!diagnostics || !diagnostics.length)
            return;
        var outputLines = [''];
        diagnostics.forEach(function (d) {
            outputLines = outputLines.concat(_this.printDiagnostic(d));
        });
        console.log(outputLines.join('\n'));
    };
    NodeLogger.prototype.printDiagnostic = function (d) {
        var _this = this;
        var outputLines = wordWrap([d.messageText]);
        if (d.header && d.header !== 'build error' && d.header !== 'build warn') {
            outputLines.unshift(INDENT + d.header);
        }
        outputLines.push('');
        if (d.lines && d.lines.length) {
            var lines = prepareLines$1(d.lines, 'text');
            lines.forEach(function (l) {
                if (!isMeaningfulLine(l.text)) {
                    return;
                }
                var msg = "L" + l.lineNumber + ":  ";
                while (msg.length < INDENT.length) {
                    msg = ' ' + msg;
                }
                var text = l.text;
                if (l.errorCharStart > -1) {
                    text = _this.highlightError(text, l.errorCharStart, l.errorLength);
                }
                msg = _this.dim(msg);
                if (d.language === 'javascript') {
                    msg += _this.jsSyntaxHighlight(text);
                }
                else if (d.language === 'scss' || d.language === 'css') {
                    msg += _this.cssSyntaxHighlight(text);
                }
                else {
                    msg += text;
                }
                outputLines.push(msg);
            });
            outputLines.push('');
        }
        if (d.level === 'warn') {
            this.warnPrefix(outputLines);
        }
        else if (d.level === 'info') {
            this.infoPrefix(outputLines);
        }
        else {
            this.errorPrefix(outputLines);
        }
        return outputLines;
    };
    NodeLogger.prototype.highlightError = function (errorLine, errorCharStart, errorLength) {
        var rightSideChars = errorLine.length - errorCharStart + errorLength - 1;
        while (errorLine.length + INDENT.length > MAX_LEN) {
            if (errorCharStart > (errorLine.length - errorCharStart + errorLength) && errorCharStart > 5) {
                // larger on left side
                errorLine = errorLine.substr(1);
                errorCharStart--;
            }
            else if (rightSideChars > 1) {
                // larger on right side
                errorLine = errorLine.substr(0, errorLine.length - 1);
                rightSideChars--;
            }
            else {
                break;
            }
        }
        var lineChars = [];
        var lineLength = Math.max(errorLine.length, errorCharStart + errorLength);
        for (var i = 0; i < lineLength; i++) {
            var chr = errorLine.charAt(i);
            if (i >= errorCharStart && i < errorCharStart + errorLength) {
                chr = this.chalk.bgRed(chr === '' ? ' ' : chr);
            }
            lineChars.push(chr);
        }
        return lineChars.join('');
    };
    NodeLogger.prototype.jsSyntaxHighlight = function (text) {
        var _this = this;
        if (text.trim().startsWith('//')) {
            return this.dim(text);
        }
        var words = text.split(' ').map(function (word) {
            if (JS_KEYWORDS.indexOf(word) > -1) {
                return _this.chalk.cyan(word);
            }
            return word;
        });
        return words.join(' ');
    };
    NodeLogger.prototype.cssSyntaxHighlight = function (text) {
        var cssProp = true;
        var safeChars = 'abcdefghijklmnopqrstuvwxyz-_';
        var notProp = '.#,:}@$[]/*';
        var chars = [];
        for (var i = 0; i < text.length; i++) {
            var c = text.charAt(i);
            if (c === ';' || c === '{') {
                cssProp = true;
            }
            else if (notProp.indexOf(c) > -1) {
                cssProp = false;
            }
            if (cssProp && safeChars.indexOf(c.toLowerCase()) > -1) {
                chars.push(this.chalk.cyan(c));
                continue;
            }
            chars.push(c);
        }
        return chars.join('');
    };
    return NodeLogger;
}());
var CmdTimeSpan = /** @class */ (function () {
    function CmdTimeSpan(logger, startMsg, debug) {
        this.debug = debug;
        this.logger = logger;
        this.start = Date.now();
        var msg = startMsg + " " + logger.dim('...');
        if (this.debug) {
            this.logger.debug(msg);
        }
        else {
            this.logger.info(msg);
        }
    }
    CmdTimeSpan.prototype.finish = function (msg, color, bold, newLineSuffix) {
        if (color) {
            msg = this.logger.color(msg, color);
        }
        if (bold) {
            msg = this.logger.bold(msg);
        }
        msg += ' ' + this.logger.dim(this.timeSuffix());
        if (this.debug) {
            this.logger.debug(msg);
        }
        else {
            this.logger.info(msg);
        }
        if (newLineSuffix) {
            console.log('');
        }
    };
    CmdTimeSpan.prototype.timeSuffix = function () {
        var duration = Date.now() - this.start;
        var time;
        if (duration > 1000) {
            time = 'in ' + (duration / 1000).toFixed(2) + ' s';
        }
        else {
            var ms = parseFloat((duration).toFixed(3));
            if (ms > 0) {
                time = 'in ' + duration + ' ms';
            }
            else {
                time = 'in less than 1 ms';
            }
        }
        return time;
    };
    return CmdTimeSpan;
}());
var LOG_LEVELS = ['debug', 'info', 'warn', 'error'];
function wordWrap(msg) {
    var lines = [];
    var words = [];
    msg.forEach(function (m) {
        if (m === null) {
            words.push('null');
        }
        else if (typeof m === 'undefined') {
            words.push('undefined');
        }
        else if (typeof m === 'string') {
            m.replace(/\s/gm, ' ').split(' ').forEach(function (strWord) {
                if (strWord.trim().length) {
                    words.push(strWord.trim());
                }
            });
        }
        else if (typeof m === 'number' || typeof m === 'boolean' || typeof m === 'function') {
            words.push(m.toString());
        }
        else if (Array.isArray(m)) {
            words.push(function () {
                return m.toString();
            });
        }
        else if (Object(m) === m) {
            words.push(function () {
                return m.toString();
            });
        }
        else {
            words.push(m.toString());
        }
    });
    var line = INDENT;
    words.forEach(function (word) {
        if (lines.length > 25) {
            return;
        }
        if (typeof word === 'function') {
            if (line.trim().length) {
                lines.push(line);
            }
            lines.push(word());
            line = INDENT;
        }
        else if (INDENT.length + word.length > MAX_LEN) {
            // word is too long to play nice, just give it its own line
            if (line.trim().length) {
                lines.push(line);
            }
            lines.push(INDENT + word);
            line = INDENT;
        }
        else if ((word.length + line.length) > MAX_LEN) {
            // this word would make the line too long
            // print the line now, then start a new one
            lines.push(line);
            line = INDENT + word + ' ';
        }
        else {
            line += word + ' ';
        }
    });
    if (line.trim().length) {
        lines.push(line);
    }
    return lines;
}
function prepareLines$1(orgLines, code) {
    var lines = JSON.parse(JSON.stringify(orgLines));
    for (var i = 0; i < 100; i++) {
        if (!eachLineHasLeadingWhitespace$1(lines, code)) {
            return lines;
        }
        for (var i_1 = 0; i_1 < lines.length; i_1++) {
            lines[i_1][code] = lines[i_1][code].substr(1);
            lines[i_1].errorCharStart--;
            if (!lines[i_1][code].length) {
                return lines;
            }
        }
    }
    return lines;
}
function eachLineHasLeadingWhitespace$1(lines, code) {
    if (!lines.length) {
        return false;
    }
    for (var i = 0; i < lines.length; i++) {
        if (!lines[i][code] || lines[i][code].length < 1) {
            return false;
        }
        var firstChar = lines[i][code].charAt(0);
        if (firstChar !== ' ' && firstChar !== '\t') {
            return false;
        }
    }
    return true;
}
function isMeaningfulLine(line) {
    if (line) {
        line = line.trim();
        if (line.length) {
            return (MEH_LINES.indexOf(line) < 0);
        }
    }
    return false;
}
var MEH_LINES = [';', ':', '{', '}', '(', ')', '/**', '/*', '*/', '*', '({', '})'];
var JS_KEYWORDS = [
    'abstract', 'any', 'as', 'break', 'boolean', 'case', 'catch', 'class',
    'console', 'const', 'continue', 'debugger', 'declare', 'default', 'delete',
    'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'from',
    'function', 'get', 'if', 'import', 'in', 'implements', 'Infinity',
    'instanceof', 'let', 'module', 'namespace', 'NaN', 'new', 'number', 'null',
    'public', 'private', 'protected', 'require', 'return', 'static', 'set',
    'string', 'super', 'switch', 'this', 'throw', 'try', 'true', 'type',
    'typeof', 'undefined', 'var', 'void', 'with', 'while', 'yield',
];
var INDENT = '           ';
var MAX_LEN = 120;

function loadConfig(config) {
    var logger = new NodeLogger({ process: process });
    if (!config || Array.isArray(config) || typeof config === 'function' || typeof config === 'number' || typeof config === 'boolean') {
        logger.error("Invalid config: " + config);
        process.exit(1);
    }
    var buildConfig;
    var configPath;
    if (typeof config === 'string') {
        configPath = config;
        buildConfig = loadConfigFile(process, configPath, logger);
    }
    else {
        // looks like it's already a build config object
        buildConfig = config;
    }
    if (!buildConfig.logger) {
        // if a logger was not provided then use the
        // defaul stencil command line logger found in bin
        buildConfig.logger = logger;
    }
    if (!buildConfig.sys) {
        // if the config was not provided then use the default node sys
        var path = require('path');
        buildConfig.sys = getNodeSys(path.join(__dirname, '../'), buildConfig.logger);
    }
    return buildConfig;
}
function loadConfigFile(process, configPath, logger) {
    var fs = require('fs');
    var path = require('path');
    var config;
    if (!path.isAbsolute(configPath)) {
        logger.error("Stencil configuration file \"" + configPath + "\" must be an absolute path.");
        process.exit(1);
    }
    try {
        var fileStat = fs.statSync(configPath);
        if (fileStat.isDirectory()) {
            // this is only a directory, so let's just assume we're looking for in stencil.config.js
            // otherwise they could pass in an absolute path if it was somewhere else
            configPath = path.join(configPath, 'stencil.config.js');
        }
        // the passed in config was a string, so it's probably a path to the config we need to load
        var configFileData = require(configPath);
        if (!configFileData.config) {
            logger.error("Invalid Stencil configuration file \"" + configPath + "\". Missing \"config\" property.");
            process.exit(1);
        }
        config = configFileData.config;
        config.configPath = configPath;
        if (!config.rootDir && configPath) {
            config.rootDir = path.dirname(configPath);
        }
    }
    catch (e) {
        logger.error("Error reading Stencil configuration file \"" + configPath + "\".", e);
        process.exit(1);
    }
    return config;
}

function ssrMiddleware(middlewareConfig) {
    // load up the config
    var config = loadConfig(middlewareConfig.config);
    // create the renderer
    var renderer = createRenderer(config);
    var srcIndexHtml;
    try {
        // load the source index.html
        srcIndexHtml = config.sys.fs.readFileSync(config.srcIndexHtml, 'utf-8');
    }
    catch (e) {
        config.logger.error("ssrMiddleware, error loading srcIndexHtml: " + e);
        process.exit(1);
    }
    // middleware fn
    return function (req, res) {
        config.logger.debug("ssr request: " + req.url);
        // hydrate level 4, please!
        renderer.hydrateToString({
            html: srcIndexHtml,
            req: req
        }).then(function (results) {
            // print out any diagnostics
            config.logger.printDiagnostics(results.diagnostics);
            // respond with the hydrated html
            res.send(results.html);
        });
    };
}
/**
 * SSR Path Regex matches urls which end with index.html,
 * urls with a trailing /, and urls with no trailing slash,
 * but also do not have a file extension. The following example
 * urls would all match (with or without a querystring):
 *   /index.html
 *   /about
 *   /about/
 *   /
 *
 * The follwing example url would not match:
 *   /image.jpg
 *   /font.woff
 *
 * Please see the unit tests if any changes are required.
 */
var ssrPathRegex = /^([^.+]|.html)*(\?.*)?$/i;

exports.loadConfig = loadConfig;
exports.ssrMiddleware = ssrMiddleware;
exports.ssrPathRegex = ssrPathRegex;
exports.createRenderer = createRenderer;
