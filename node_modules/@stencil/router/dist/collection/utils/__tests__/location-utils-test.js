import { resolvePathname, createLocation, valueEqual } from '../location-utils';
describe('resolvePathname', function () {
    it('works when from is not given', function () {
        expect(resolvePathname('c')).toEqual('c');
    });
    it('works when from is relative', function () {
        expect(resolvePathname('c', 'a/b')).toEqual('a/c');
    });
    it('works when to is absolute', function () {
        expect(resolvePathname('/c', '/a/b')).toEqual('/c');
    });
    it('works when to is empty', function () {
        expect(resolvePathname('', '/a/b')).toEqual('/a/b');
    });
    it('works when to is a sibling of the parent', function () {
        expect(resolvePathname('../c', '/a/b')).toEqual('/c');
    });
    it('works when to is a sibling path', function () {
        expect(resolvePathname('c', '/a/b')).toEqual('/a/c');
    });
    it('works when from is an index path', function () {
        expect(resolvePathname('c', '/a/')).toEqual('/a/c');
    });
    it('works when to points to the parent directory', function () {
        expect(resolvePathname('..', '/a/b')).toEqual('/');
    });
    // Copied from node's test/parallel/test-url.js
    var nodeURLResolveTestCases = [
        ['/foo/bar/baz', 'quux', '/foo/bar/quux'],
        ['/foo/bar/baz', 'quux/asdf', '/foo/bar/quux/asdf'],
        ['/foo/bar/baz', 'quux/baz', '/foo/bar/quux/baz'],
        ['/foo/bar/baz', '../quux/baz', '/foo/quux/baz'],
        ['/foo/bar/baz', '/bar', '/bar'],
        ['/foo/bar/baz/', 'quux', '/foo/bar/baz/quux'],
        ['/foo/bar/baz/', 'quux/baz', '/foo/bar/baz/quux/baz'],
        ['/foo/bar/baz', '../../../../../../../../quux/baz', '/quux/baz'],
        ['/foo/bar/baz', '../../../../../../../quux/baz', '/quux/baz'],
        ['/foo', '.', '/'],
        ['/foo', '..', '/'],
        ['/foo/', '.', '/foo/'],
        ['/foo/', '..', '/'],
        ['/foo/bar', '.', '/foo/'],
        ['/foo/bar', '..', '/'],
        ['/foo/bar/', '.', '/foo/bar/'],
        ['/foo/bar/', '..', '/foo/'],
        ['foo/bar', '../../../baz', '../../baz'],
        ['foo/bar/', '../../../baz', '../baz'],
        ['/foo/bar/baz', '/../etc/passwd', '/etc/passwd'],
    ];
    nodeURLResolveTestCases.forEach(function (_a) {
        var from = _a[0], to = _a[1], expected = _a[2];
        it("resolvePathname('" + to + "', '" + from + "') == '" + expected + "'", function () {
            expect(resolvePathname(to, from)).toEqual(expected);
        });
    });
});
describe('createLocation', function () {
    describe('with a full path', function () {
        describe('given as a string', function () {
            it('has the correct properties', function () {
                expect(createLocation('/the/path?the=query#the-hash')).toEqual({
                    pathname: '/the/path',
                    search: '?the=query',
                    hash: '#the-hash',
                    query: {
                        'the': 'query'
                    }
                });
            });
        });
        describe('given as an object', function () {
            it('has the correct properties', function () {
                expect(createLocation({ pathname: '/the/path', search: '?the=query', hash: '#the-hash' })).toEqual({
                    pathname: '/the/path',
                    search: '?the=query',
                    hash: '#the-hash',
                    query: {
                        'the': 'query'
                    }
                });
            });
        });
    });
    describe('with a relative path', function () {
        describe('given as a string', function () {
            it('has the correct properties', function () {
                expect(createLocation('the/path?the=query#the-hash')).toEqual({
                    pathname: 'the/path',
                    search: '?the=query',
                    hash: '#the-hash',
                    query: {
                        'the': 'query'
                    }
                });
            });
        });
        describe('given as an object', function () {
            it('has the correct properties', function () {
                expect(createLocation({ pathname: 'the/path', search: '?the=query', hash: '#the-hash' })).toEqual({
                    pathname: 'the/path',
                    search: '?the=query',
                    hash: '#the-hash',
                    query: {
                        'the': 'query'
                    }
                });
            });
        });
    });
    describe('with a path with no pathname', function () {
        describe('given as a string', function () {
            it('has the correct properties', function () {
                expect(createLocation('?the=query#the-hash')).toEqual({
                    pathname: '/',
                    search: '?the=query',
                    hash: '#the-hash',
                    query: {
                        'the': 'query'
                    }
                });
            });
        });
        describe('given as an object', function () {
            it('has the correct properties', function () {
                expect(createLocation({ search: '?the=query', hash: '#the-hash' })).toEqual({
                    pathname: '/',
                    search: '?the=query',
                    hash: '#the-hash',
                    query: {
                        'the': 'query'
                    }
                });
            });
        });
    });
    describe('with a path with no search', function () {
        describe('given as a string', function () {
            it('has the correct properties', function () {
                expect(createLocation('/the/path#the-hash')).toEqual({
                    pathname: '/the/path',
                    search: '',
                    hash: '#the-hash',
                    query: {}
                });
            });
        });
        describe('given as an object', function () {
            it('has the correct properties', function () {
                expect(createLocation({ pathname: '/the/path', hash: '#the-hash' })).toEqual({
                    pathname: '/the/path',
                    search: '',
                    hash: '#the-hash',
                    query: {}
                });
            });
        });
    });
    describe('with a path with no hash', function () {
        describe('given as a string', function () {
            it('has the correct properties', function () {
                expect(createLocation('/the/path?the=query')).toEqual({
                    pathname: '/the/path',
                    search: '?the=query',
                    hash: '',
                    query: {
                        'the': 'query'
                    }
                });
            });
        });
        describe('given as an object', function () {
            it('has the correct properties', function () {
                expect(createLocation({ pathname: '/the/path', search: '?the=query' })).toEqual({
                    pathname: '/the/path',
                    search: '?the=query',
                    hash: '',
                    query: {
                        'the': 'query'
                    }
                });
            });
        });
    });
    describe('with a path that cannot be decoded', function () {
        describe('given as a string', function () {
            it('throws custom message when decodeURI throws a URIError', function () {
                expect(function () {
                    createLocation('/test%');
                }).toThrow('Pathname "/test%" could not be decoded.');
            });
        });
        describe('given as an object', function () {
            it('throws custom message when decodeURI throws a URIError', function () {
                expect(function () {
                    createLocation({ pathname: '/test%' });
                }).toThrow('Pathname "/test%" could not be decoded.');
            });
        });
    });
    describe('key', function () {
        it('has a key property if a key is provided', function () {
            var location = createLocation('/the/path', undefined, 'key');
            expect(location).toHaveProperty('key');
        });
        it('has no key property if no key is provided', function () {
            var location = createLocation('/the/path');
            expect(location).not.toHaveProperty('key');
        });
    });
});
describe('valueEqual', function () {
    describe('undefined and null', function () {
        describe('when both are undefined', function () {
            it('returns true', function () {
                expect(valueEqual(undefined, undefined)).toBe(true);
            });
        });
        describe('when one is null', function () {
            it('returns false', function () {
                expect(valueEqual(undefined, null)).toBe(false);
            });
        });
        describe('when one is null and the other is an object', function () {
            it('returns false', function () {
                expect(valueEqual({}, null)).toBe(false);
                expect(valueEqual(null, {})).toBe(false);
            });
        });
    });
    describe('string primitives', function () {
        describe('that are equal', function () {
            it('returns true', function () {
                expect(valueEqual('asdf', 'asdf')).toBe(true);
            });
        });
        describe('that are not equal', function () {
            it('returns false', function () {
                expect(valueEqual('asdf', 'sdfg')).toBe(false);
            });
        });
    });
    describe('string objects', function () {
        describe('that are equal', function () {
            it('returns true', function () {
                expect(valueEqual(new String('asdf'), new String('asdf'))).toBe(true);
            });
        });
        describe('that are not equal', function () {
            it('returns false', function () {
                expect(valueEqual(new String('asdf'), new String('sdfg'))).toBe(false);
            });
        });
    });
    describe('number primitives', function () {
        describe('that are equal', function () {
            it('returns true', function () {
                expect(valueEqual(123.456, 123.456)).toBe(true);
            });
        });
        describe('that are not equal', function () {
            it('returns false', function () {
                expect(valueEqual(123.456, 123.567)).toBe(false);
            });
        });
    });
    describe('number objects', function () {
        describe('that are equal', function () {
            it('returns true', function () {
                expect(valueEqual(new Number(123.456), new Number(123.456))).toBe(true);
            });
        });
        describe('that are not equal', function () {
            it('returns false', function () {
                expect(valueEqual(new Number(123.456), new Number(123.567))).toBe(false);
            });
        });
    });
    describe('boolean primitives', function () {
        describe('that are equal', function () {
            it('returns true', function () {
                expect(valueEqual(true, true)).toBe(true);
            });
        });
        describe('that are not equal', function () {
            it('returns false', function () {
                expect(valueEqual(true, false)).toBe(false);
            });
        });
    });
    describe('boolean objects', function () {
        describe('that are equal', function () {
            it('returns true', function () {
                expect(valueEqual(new Boolean(true), new Boolean(true))).toBe(true);
            });
        });
        describe('that are not equal', function () {
            it('returns false', function () {
                expect(valueEqual(new Boolean(true), new Boolean(false))).toBe(false);
            });
        });
    });
    describe('date objects', function () {
        var now = Date.now();
        describe('that are equal', function () {
            it('returns true', function () {
                expect(valueEqual(new Date(now), new Date(now))).toBe(true);
            });
        });
        describe('that are not equal', function () {
            it('returns false', function () {
                expect(valueEqual(new Date(now), new Date(now + 1))).toBe(false);
            });
        });
    });
    describe('arrays', function () {
        describe('that are equal', function () {
            it('returns true', function () {
                expect(valueEqual([1, 2, 3], [1, 2, 3])).toBe(true);
            });
        });
        describe('that are not equal', function () {
            it('returns false', function () {
                expect(valueEqual([1, 2, 3], [2, 3, 4])).toBe(false);
            });
        });
    });
    describe('objects with different constructors but the same properties', function () {
        function A(a, b, c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }
        function B(a, b, c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }
        it('returns true', function () {
            expect(valueEqual(new A(1, 2, 3), new B(1, 2, 3))).toBe(true);
        });
    });
});
